<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> üáßüá∑ Introdu√ß√£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> üáßüá∑ Instala√ß√£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> üáßüá∑ Ol√°, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> üáßüá∑ Jogo de Adivinha√ß√£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> üáßüá∑ Conceitos Comuns de Programa√ß√£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> üáßüá∑ Vari√°veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> üáßüá∑ Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> üáßüá∑ Enums e Casamento de Padr√µes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> üáßüá∑ Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> üáßüá∑ Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> üáßüá∑ Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> üáßüá∑ M√≥dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> üáßüá∑ mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> üáßüá∑ Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> üáßüá∑ Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> üáßüá∑ Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> üáßüá∑ Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> üáßüá∑ Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generics</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Syntax</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Lifetime syntax</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust OOP?</a></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introdu√ß√£o" id="introdu√ß√£o"><h1>Introdu√ß√£o</h1></a>
<p>Seja bem vindo(a) ao ‚ÄúLinguagem de Programa√ß√£o Rust‚Äù, um livro introdut√≥rio
sobre Rust. Rust √© uma linguagem de programa√ß√£o focada em seguran√ßa, efici√™ncia
e concorr√™ncia. Seu <em>design</em> lhe permite criar programas com o desempenho e
controle de uma linguagem de baixo n√≠vel, mas com as abstra√ß√µes poderosas de uma
linguagem de alto n√≠vel. Estas propriedades tornam Rust adequado para
programadores que t√™m experi√™ncia em linguagens como C e procuram por uma
alternativa mais segura, bem como para aqueles que v√™m de linguagens como o
Python e que procuram por maneiras de escrever c√≥digo com melhor desempenho sem
sacrificar a expressividade.</p>
<p>Rust executa a maioria das suas verifica√ß√µes de seguran√ßa e decis√µes de
gerenciamento de mem√≥ria em tempo de compila√ß√£o, para que o desempenho de
execu√ß√£o do seu programa n√£o seja impactado. Isso torna a linguagem √∫til em um
n√∫mero de casos para os quais outras linguagens n√£o s√£o adequadas: programas com
requisitos de tempo e espa√ßo previs√≠veis, incorpora√ß√£o de c√≥digo em outras
linguagens e a escrita de c√≥digo de baixo n√≠vel, como <em>drivers</em> de dispositivo e
sistemas operacionais. A linguagem Rust tamb√©m √© fant√°stica para aplica√ß√µes web:
ela est√° por tr√°s do site do registro de pacotes do Rust, <a href="https://crates.io/">crates.io</a>! Estamos
curiosos para saber o que <em>voc√™</em> far√° com Rust.</p>
<p>Este livro tem como p√∫blico-alvo um leitor que j√° sabe como programar em pelo
menos uma linguagem de programa√ß√£o. Ap√≥s ler este livro, voc√™ deve se sentir
confiante para escrever programas em Rust. Ensinaremos Rust atrav√©s de exemplos
focados e pequenos, que se complementam gradualmente para demonstrar o uso de
v√°rias caracter√≠sticas da linguagem Rust, bem como eles funcionam ‚Äúnos
bastidores‚Äù.</p>
<a class="header" href="print.html#sobre-a-tradu√ß√£o" id="sobre-a-tradu√ß√£o"><h2>Sobre a Tradu√ß√£o</h2></a>
<p>Esta √© uma tradu√ß√£o <em>n√£o oficial</em> da <a href="https://rust-lang.github.io/book">nova vers√£o</a> do livro  ‚ÄúThe Rust
Programming Language‚Äù. V√°rias por√ß√µes desta tradu√ß√£o (assim como do original)
ainda est√£o incompletas. A <a href="https://doc.rust-lang.org/book">vers√£o antiga</a> do livro (em ingl√™s) ainda √© a
leitura de refer√™ncia recomendada da linguagem.</p>
<p>Sempre que poss√≠vel, nos exemplos de c√≥digo, optamos por usar nomes de
vari√°veis, fun√ß√µes e arquivos em portugu√™s. Essa escolha foi feita para fins
did√°ticos, e se limita √†s por√ß√µes de c√≥digo de exemplo apresentadas. Os nomes
provenientes da biblioteca padr√£o da linguagem, bem como de <em>crates</em> j√°
existentes s√£o mantidos no original em ingl√™s, para que o c√≥digo funcione
corretamente. (Ex: <code>Usuario</code> em vez de <code>User</code>, mas manteremos nomes como <code>Box</code>
em ingl√™s). Para fins de compatibilidade, utilizaremos somente caracteres sem
acento e cedilha.</p>
<p>Apesar da escolha did√°tica do livro, recomendamos que, ao escrever c√≥digo ‚Äúde
verdade‚Äù em Rust, utilize sempre que poss√≠vel nomes em ingl√™s, especialmente
para projetos <em>open source</em> a fim de tornar seu c√≥digo acess√≠vel para uma maior
audi√™ncia.</p>
<a class="header" href="print.html#contribuindo-com-o-livro" id="contribuindo-com-o-livro"><h2>Contribuindo com o Livro</h2></a>
<p>Este livro √© <em>open source</em>. Se encontrar um erro, por favor n√£o hesite em abrir
uma <em>issue</em> ou enviar um <em>pull request</em> <a href="https://github.com/rust-br/rust-book-pt-br">no GitHub</a>. Leia
<a href="https://github.com/rust-br/rust-book-pt-br/blob/master/CONTRIBUTING-pt-br.md">CONTRIBUTING-pt-br.md</a> para mais detalhes.</p>
<a class="header" href="print.html#instala√ß√£o" id="instala√ß√£o"><h2>Instala√ß√£o</h2></a>
<p>O primeiro passo para se usar a linguagem Rust √© instal√°-la. Voc√™ vai precisar
de uma conex√£o com a internet para executar os comandos contidos neste
cap√≠tulo, pois vamos baixar o Rust da internet.</p>
<p>Iremos mostrar diversos comandos usando o terminal, e todas as linhas que se
referem ao terminal iniciam com <code>$</code>. Voc√™ n√£o precisa digitar o caractere <code>$</code>,
ele serve apenas para indicar o in√≠cio de cada comando. Voc√™ vai notar que
muitos tutorias dispon√≠veis por a√≠ seguem esta conven√ß√£o: <code>$</code> para comandos que
s√£o executados como um usu√°rio normal, e <code>#</code> para comandos que voc√™ deve
executar como administrador. As linhas que n√£o iniciam com o caractere <code>$</code>
mostram o <em>output</em> (sa√≠da) do comando anterior.</p>
<a class="header" href="print.html#instalando-no-linux-ou-mac" id="instalando-no-linux-ou-mac"><h3>Instalando no Linux ou Mac</h3></a>
<p>Se voc√™ est√° em um ambiente Linux ou Mac, tudo o que voc√™ precisa √© abrir um
terminal e digitar o seguinte comando:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Este comando vai baixar um script e iniciar a instala√ß√£o. Talvez seja solicitado
que voc√™ digite sua senha. Se tudo ocorrer bem, a mensagem abaixo vai aparecer:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Claro, se voc√™ n√£o aprova o uso do <code>curl | sh</code>, voc√™ pode baixar o <em>script</em>,
inspecion√°-lo e execut√°-lo da maneira que achar melhor.</p>
<p>O <em>script</em> de instala√ß√£o j√° adiciona automaticamente o Rust √† vari√°vel PATH do
seu sistema logo ap√≥s o seu pr√≥ximo <em>login</em>. Se voc√™ quiser usar o Rust
imediatamente, execute o seguinte comando no seu terminal:</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>Outra op√ß√£o √© adicionar a linha abaixo no seu <code>~/.bash_profile</code>:</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<a class="header" href="print.html#instalando-no-windows" id="instalando-no-windows"><h3>Instalando no Windows</h3></a>
<p>No Windows, visite o <em>site</em>
<a href="https://rustup.rs/">https://rustup.rs</a><!-- ignore --> e siga as instru√ß√µes para
baixar o arquivo rustup-init.exe. Execute este arquivo e siga as demais
instru√ß√µes que aparecerem na sua tela.</p>
<p>O restante dos comandos espec√≠ficos do Windows neste livro partem da premissa de
que voc√™ est√° utilizando o <code>cmd</code> como o seu <em>shell</em>. Se voc√™ est√° usando um
<em>shell</em> diferente, talvez voc√™ poder√° usar os mesmos comandos que os usu√°rios de
Linux ou Mac usam. Se algum comando n√£o funcionar, consulte a documenta√ß√£o
referente ao <em>shell</em> que voc√™ est√° utilizando.</p>
<a class="header" href="print.html#instala√ß√£o-customizada" id="instala√ß√£o-customizada"><h3>Instala√ß√£o customizada</h3></a>
<p>Se, por alguma raz√£o, voc√™ preferir n√£o usar o rustup.rs, consulte <a href="https://www.rust-lang.org/pt-BR/install.html">a p√°gina de
instala√ß√£o do Rust</a> para outras
op√ß√µes de instala√ß√£o.</p>
<a class="header" href="print.html#atualizando-o-rust" id="atualizando-o-rust"><h3>Atualizando o Rust</h3></a>
<p>Tendo o Rust instalado na sua m√°quina, atualizar para a √∫ltima vers√£o √© f√°cil.
Do seu <em>shell</em>, execute o <em>script</em> de atualiza√ß√£o:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<a class="header" href="print.html#desinstalando" id="desinstalando"><h3>Desinstalando</h3></a>
<p>Desinstalar Rust √© t√£o f√°cil quanto instal√°-lo. Do seu <em>shell</em>, execute o
<em>script</em> de desinstala√ß√£o:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#solu√ß√£o-de-problemas" id="solu√ß√£o-de-problemas"><h3>Solu√ß√£o de Problemas</h3></a>
<p>Ap√≥s Rust ser instalado em sua m√°quina, voc√™ pode abrir o seu <em>shell</em>, e digitar
a linha abaixo:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>Voc√™ dever√° ver a vers√£o, o <em>hash</em> e a data do <em>commit</em> em um formato
similar ao seguinte, indicando a √∫ltima est√°vel mais recente no momento da
instala√ß√£o:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Se aparecer a mensagem acima, Rust foi instalado com sucesso!
Parab√©ns!</p>
<p>Se n√£o aparecer a mensagem acima e voc√™ est√° em um ambiente Windows, verifique
se o Rust aparece na vari√°vel <code>%PATH%</code> do seu sistema.</p>
<p>Se mesmo assim n√£o funcionar, existem v√°rios lugares onde voc√™ pode pedir ajuda.
A maneira mais f√°cil √© pedir ajuda no
<a href="irc://irc.mozilla.org/#rust">canal IRC #rust do irc.mozilla.org</a><!-- ignore -->, que voc√™ pode acessar
via <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Voc√™ vai falar com v√°rios outros <em>Rustaceans</em> (um apelido
bobo que usamos entre n√≥s) que podem ajud√°-lo em suas d√∫vidas. Voc√™ tamb√©m pode
buscar ajuda no <a href="https://users.rust-lang.org/">f√≥rum do Rust</a> e no <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<a class="header" href="print.html#documenta√ß√£o-local" id="documenta√ß√£o-local"><h3>Documenta√ß√£o local</h3></a>
<p>O instalador tamb√©m inclui uma c√≥pia local da documenta√ß√£o para que voc√™ possa
acess√°-la <em>offline</em>. Execute o comando <code>rustup doc</code> para abrir a documenta√ß√£o
local no seu navegador.</p>
<p>Sempre que voc√™ se deparar com um tipo ou fun√ß√£o fornecido pela biblioteca
padr√£o que voc√™ n√£o tem certeza do que ele faz, use a documenta√ß√£o da API para
descobrir!</p>
<a class="header" href="print.html#ol√°-mundo" id="ol√°-mundo"><h2>Ol√°, Mundo!</h2></a>
<p>Agora que Rust j√° est√° instalado, vamos escrever nosso primeiro programa. Quando
aprendemos uma nova linguagem de programa√ß√£o, √© tradicional escrever um pequeno
programa que imprime &quot;Ol√°, mundo!&quot; (<em>‚ÄúHello, world!‚Äù</em>) na tela, e √© exatamente
isso que vamos fazer nesta se√ß√£o.</p>
<blockquote>
<p>Nota: Este livro assume que o leitor tem um pouco de familiaridade com a
linha de comando. Rust n√£o exige que voc√™ use um determinado editor ou IDE,
ou seja, voc√™ est√° livre para usar o que bem entender para escrever seu c√≥digo
Rust.</p>
</blockquote>
<a class="header" href="print.html#criando-um-diret√≥rio-de-projeto" id="criando-um-diret√≥rio-de-projeto"><h3>Criando um Diret√≥rio de Projeto</h3></a>
<p>Primeiramente, crie uma pasta para colocar o seu c√≥digo Rust. O Rust n√£o se
importa onde voc√™ vai armazenar o seu c√≥digo, mas neste livro, n√≥s sugerimos
criar um diret√≥rio chamado <em>projetos</em> e armazenar todos os seus projetos ali.
Abra o seu terminal e digite os seguintes comandos:</p>
<p>Linux e Mac:</p>
<pre><code class="language-text">$ mkdir ~/projetos
$ cd ~/projetos
$ mkdir ola_mundo
$ cd ola_mundo
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projetos
&gt; cd %USERPROFILE%\projetos
&gt; mkdir ola_mundo
&gt; cd ola_mundo
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projetos
&gt; cd $env:USERPROFILE\projetos
&gt; mkdir ola_mundo
&gt; cd ola_mundo
</code></pre>
<a class="header" href="print.html#escrevendo-e-executando-um-programa-em-rust" id="escrevendo-e-executando-um-programa-em-rust"><h3>Escrevendo e Executando um Programa em Rust</h3></a>
<p>Crie um novo arquivo <em>main.rs</em>. Arquivos relacionados √† linguagem Rust sempre
terminam com a extens√£o <em>.rs</em>. Se o nome do seu arquivo tem mais de uma palavra,
use um <em>underscore</em> (<code>_</code>) para separ√°-los. Por exemplo, voc√™ deve nomear o seu
arquivo <em>ola_mundo.rs</em> em vez de <em>olamundo.rs</em>.</p>
<p>Agora abra o arquivo <em>main.rs</em> que voc√™ acabou de criar e digite o seguinte
c√≥digo:</p>
<p><span class="filename">Arquivo: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Ol√°, mundo!&quot;);
}
</code></pre></pre>
<p>Salve o arquivo e volte ao seu terminal. No Linux ou OSX, digite os seguintes
comandos:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Ol√°, mundo!
</code></pre>
<p>Para executar o seu programa no Windows, digite <code>.\main.exe</code> em vez de <code>./main</code>.
Independente do seu sistema operacional, voc√™ dever√° ver a mensagem
<code>Ol√°, mundo!</code> no seu terminal. Se voc√™ chegou at√© aqui, parab√©ns! Voc√™ escreveu
o seu primeiro programa em Rust. Isso faz de voc√™ um programador Rust! Seja
bem-vindo!</p>
<a class="header" href="print.html#anatomia-de-um-programa-em-rust" id="anatomia-de-um-programa-em-rust"><h3>Anatomia de um Programa em Rust</h3></a>
<p>Agora vamos ver o que aconteceu com o seu programa &quot;Ol√°, mundo!&quot; em detalhes.
Aqui est√° a primeira pe√ßa do quebra-cabe√ßa:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Estas linhas definem uma <em>fun√ß√£o</em> em Rust. A fun√ß√£o <code>main</code> √© especial: √© a
primeira coisa que √© executada em cada programa escrito em Rust. A primeira
linha diz: &quot;Estou declarando uma fun√ß√£o chamada <code>main</code> que n√£o cont√©m nenhum
par√¢metro e que n√£o retorna nada.&quot; Se existissem par√¢metros, eles estariam
dentro dos par√™nteses, <code>(</code> e <code>)</code>.</p>
<p>Tamb√©m repare que o corpo da fun√ß√£o est√° envolvido por duas chaves, <code>{</code> e <code>}</code>.
Rust requer essas chaves no come√ßo e no fim do corpo de cada fun√ß√£o.
Considera-se boa pr√°tica colocar a chave inicial na mesma linha da declara√ß√£o
da fun√ß√£o, com um espa√ßo entre elas.</p>
<p>Dentro da fun√ß√£o <code>main</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Ol√°, mundo!&quot;);
#}</code></pre></pre>
<p>Esta linha faz todo o trabalho nesse pequeno programa: imprime um texto na tela.
Existem alguns detalhes a se notar aqui. O primeiro √© que o estilo de indenta√ß√£o
do Rust usa quatro espa√ßos, e n√£o um <em>tab</em>.</p>
<p>A segunda parte importante √© o <code>println!</code>. Este comando est√° chamando uma
<em>macro</em>, que √© a forma de se fazer metaprograma√ß√£o em Rust. Se estiv√©ssemos
chamando uma fun√ß√£o, ficaria assim: <code>println</code> (sem o <code>!</code>). Vamos discutir
<em>macros</em> em Rust com mais detalhes no Ap√™ndice D, mas por agora, voc√™ s√≥ precisa
saber que quando usamos um <code>!</code>, significa que estamos chamando uma <em>macro</em> em
vez de uma fun√ß√£o.</p>
<p>Em seguida vem <code>&quot;Ol√°, mundo!&quot;</code>, que √© uma <em>string</em>. N√≥s passamos esta <em>string</em>
como um argumento para a <em>macro</em> <code>println!</code>, que por sua vez imprime a <em>string</em>
na tela. F√°cil!</p>
<p>A linha termina com um ponto e v√≠rgula (<code>;</code>). O <code>;</code> indica que esta express√£o
acabou, e que a pr√≥xima est√° pronta para come√ßar. A maioria das linhas de c√≥digo
em Rust terminam com um <code>;</code>.</p>
<a class="header" href="print.html#compila√ß√£o-e-execu√ß√£o-s√£o-etapas-diferentes" id="compila√ß√£o-e-execu√ß√£o-s√£o-etapas-diferentes"><h3>Compila√ß√£o e Execu√ß√£o S√£o Etapas Diferentes</h3></a>
<p>Na se√ß√£o &quot;Escrevendo e Executando um Programa em Rust&quot;, mostramos como voc√™ pode
executar um programa que voc√™ acabou de criar. A partir de agora, vamos dividir
este processo em partes e examinar cada uma delas.</p>
<p>Antes de executar qualquer programa em Rust, voc√™ deve compil√°-lo. Voc√™ pode
usar o compilador do Rust utilizando o comando <code>rustc</code>, passando o nome do seu
arquivo fonte conforme o exemplo abaixo:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>Se voc√™ j√° programou em C ou C++, ir√° notar que esta etapa √© bem similar ao uso
do <code>gcc</code> ou <code>clang</code>. Ap√≥s a compila√ß√£o ser realizada com sucesso, o Rust deve
gerar como sa√≠da um bin√°rio execut√°vel, que voc√™ pode conferir com o comando
<code>ls</code> no seu terminal, se estiver em um ambiente Linux ou OSX:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>No Windows, digite o seguinte:</p>
<pre><code class="language-cmd">&gt; dir /B %= a op√ß√£o /B serve para mostrar apenas nomes de arquivos =%
main.exe
main.rs
</code></pre>
<p>Temos aqui dois arquivos: o c√≥digo-fonte, que termina com a extens√£o <em>.rs</em>, e o
arquivo execut√°vel (<em>main.exe</em> no Windows, <em>main</em> nos demais sistemas). O que
nos resta fazer √© executar o arquivo <em>main</em> ou <em>main.exe</em>, desta forma:</p>
<pre><code class="language-text">$ ./main  # ou .\main.exe no Windows
</code></pre>
<p>Se o arquivo <em>main.rs</em> tiver o c√≥digo do programa &quot;Ol√°, mundo!&quot;, vai aparecer no
seu terminal a mensagem <code>Ol√°, mundo!</code>.</p>
<p>Se voc√™ vem de uma linguagem din√¢mica como Ruby, Python, ou JavaScript, voc√™
provavelmente n√£o est√° acostumado a ver a compila√ß√£o e a execu√ß√£o como etapas
separadas. Rust √© uma linguagem <em>ahead-of-time compiled</em>, isso significa que
voc√™ pode compilar um programa, envi√°-lo para algu√©m, e essa pessoa pode
executar o seu programa mesmo que n√£o tenha o Rust instalado em seu ambiente. Se
voc√™ enviar a algu√©m um arquivo <code>.rb</code>, <code>.py</code>, ou <code>.js</code>, a pessoa vai precisar
ter instalado um interpretador Ruby, Python, ou JavaScript (respectivamente),
mas nesse caso voc√™ s√≥ precisa de um √∫nico comando para compilar e executar o
seu programa. Em design de linguagens de programa√ß√£o, tudo √© uma rela√ß√£o de
compromisso.</p>
<p>Compilar usando <code>rustc</code> serve bem para programas simples, mas conforme o seu
projeto cresce, com certeza voc√™ vai querer gerenciar todas as op√ß√µes poss√≠veis
para o seu projeto e compartilhar facilmente o seu c√≥digo com outras pessoas e
projetos. Na sequ√™ncia, vamos lhe apresentar uma ferramenta chamada Cargo, que
ajuda a escrever programas em Rust usados no mundo real.</p>
<a class="header" href="print.html#ol√°-cargo" id="ol√°-cargo"><h2>Ol√°, Cargo!</h2></a>
<p>Cargo √© o sistema de <em>build</em> e gerenciador de pacotes (<em>package manager</em>) do
Rust. N√≥s, Rustaceans, usamos Cargo para gerenciar nossos projetos em Rust
porque ele facilita muito as coisas. Por exemplo, Cargo se encarrega do processo
de <em>build</em> do seu c√≥digo, baixa as bibliotecas das quais seu c√≥digo depende e
compila essas bibliotecas. As bibliotecas necess√°rias ao seu c√≥digo n√≥s chamamos
de <em>depend√™ncias</em>.</p>
<p>Programas simples em Rust, como o que escrevemos a pouco, n√£o t√™m nenhuma
depend√™ncia, ent√£o por enquanto, voc√™ s√≥ vai usar a parte do Cargo que cuida do
<em>build</em> do seu c√≥digo. √Ä medida que voc√™ escrever programas mais complexos em
Rust, voc√™ vai querer adicionar depend√™ncias, e utilizando o Cargo, ser√° bem
mais f√°cil fazer isso.</p>
<p>Como a vasta maioria dos projetos em Rust usam Cargo, vamos assumir que voc√™ vai
us√°-lo pelo resto do livro. O Cargo j√° vem instalado com o pr√≥prio Rust, se voc√™
utilizou algum dos instaladores oficiais abordados na se√ß√£o sobre instala√ß√£o. Se
voc√™ utilizou outros meios para instalar Rust, voc√™ pode verificar se tem o
Cargo instalado digitando o seguinte comando no seu terminal:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>Se aparecer um n√∫mero de vers√£o, √≥timo! Mas, se aparecer um erro como <code>command not found</code>, voc√™ deve olhar a documenta√ß√£o do m√©todo de instala√ß√£o utilizado,
para verificar como instalar Cargo em seu ambiente.</p>
<a class="header" href="print.html#criando-um-projeto-com-cargo" id="criando-um-projeto-com-cargo"><h3>Criando um Projeto com Cargo</h3></a>
<p>Vamos criar um novo projeto usando Cargo e ver o que muda em rela√ß√£o ao nosso
primeiro projeto <code>ola_mundo</code>. Volte ao seu diret√≥rio de projetos (ou aonde quer
que voc√™ tenha colocado o seu c√≥digo):</p>
<p>Linux e Mac:</p>
<pre><code class="language-text">$ cd ~/projetos
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projetos
</code></pre>
<p>E ent√£o execute o comando abaixo:</p>
<pre><code class="language-text">$ cargo new ola_cargo --bin
$ cd ola_cargo
</code></pre>
<p>Passamos o argumento <code>--bin</code> para o comando <code>cargo new</code> porque o nosso objetivo
√© fazer uma aplica√ß√£o execut√°vel, em vez de uma biblioteca. Execut√°veis s√£o
arquivos bin√°rios, muitas vezes chamados apenas de <em>bin√°rios</em>. Demos o nome
<code>ola_cargo</code> ao nosso projeto, e o Cargo j√° criou os arquivos dele em uma nova
pasta com o mesmo nome, que agora podemos acessar.</p>
<p>Se listarmos os arquivos na pasta <em>ola_cargo</em>, podemos ver que o Cargo gerou
dois arquivos e um diret√≥rio para n√≥s: um arquivo <em>Cargo.toml</em> e um diret√≥rio
<em>src</em>, com um arquivo <em>main.rs</em> dentro dele. Tamb√©m automaticamente j√°
inicializou um reposit√≥rio git na pasta <em>ola_cargo</em>, junto com um arquivo
<em>.gitignore</em>. Voc√™ pode mudar isso se quiser usar um sistema de controle de
vers√£o diferente, ou se n√£o quiser usar nenhum. Basta usar a flag <code>--vcs</code>.</p>
<p>Abra o arquivo <em>Cargo.toml</em> no seu editor de texto. O conte√∫do dele √© algo
assim:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;ola_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Este arquivo est√° no formato <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tom‚Äôs Obvious,
Minimal Language</em>). TOML √© similar a INI com algumas coisinhas a mais e √©
usado como formato de configura√ß√£o do Cargo.</p>
<p>A primeira linha, <code>[package]</code>, √© um cabe√ßalho de se√ß√£o que indica que o que vem
em seguida est√° configurando um pacote. Ao passo que adicionamos mais
informa√ß√µes a este arquivo, vamos adicionar outras se√ß√µes a ele.</p>
<p>As pr√≥ximas tr√™s linhas indicam as tr√™s configura√ß√µes de que o Cargo precisa
para saber como compilar o seu programa: nome, vers√£o, e o autor. O Cargo
consegue o seu nome e <em>e-mail</em> atrav√©s do seu ambiente. Se n√£o estiver correto,
corrija e depois salve o arquivo.</p>
<p>A √∫ltima linha, <code>[dependencies]</code>, √© o come√ßo da se√ß√£o em que voc√™ deve listar
quaisquer <em>crates</em> (como chamamos os pacotes de c√≥digo em Rust) das quais o seu
projeto ir√° depender, assim o Cargo sabe que deve baixar e compilar estes
pacotes tamb√©m. N√£o vamos precisar de nenhum <em>crate</em> para este projeto, mas sim
para o projeto do jogo de advinha√ß√£o que faremos no pr√≥ximo cap√≠tulo.</p>
<p>Agora vamos dar uma olhada em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>O Cargo gerou um &quot;Ol√°, mundo!&quot; para voc√™, igual ao que escrevemos anteriormente
(por√©m em ingl√™s)! Esta parte √© a mesma. As diferen√ßas entre o nosso projeto
anterior e o projeto gerado pelo Cargo, que vimos at√© agora, foram:</p>
<ul>
<li>Nosso c√≥digo fica dentro do diret√≥rio <em>src</em></li>
<li>A pasta raiz do nosso projeto cont√©m um arquivo de configura√ß√£o <em>Cargo.toml</em></li>
</ul>
<p>O Cargo espera que os seus arquivos de c√≥digo fiquem no diret√≥rio <em>src</em>, de
maneira que a pasta raiz seja apenas para <em>READMEs</em>, informa√ß√µes a respeito de
licen√ßa, arquivos de configura√ß√£o, e tudo mais que n√£o for relacionado a c√≥digo.
Assim, o uso de Cargo lhe ajuda a manter os seus projetos bem organizados. H√° um
lugar pra cada coisa, e cada coisa fica em seu lugar.</p>
<p>Se voc√™ iniciou um projeto que n√£o usa Cargo, como fizemos com nosso projeto na
pasta <em>ola_mundo</em>, voc√™ pode convert√™-lo em um projeto que usa o Cargo. Basta
mover o seu c√≥digo para um diret√≥rio <em>src</em> e criar um arquivo <em>Cargo.toml</em>.</p>
<a class="header" href="print.html#realizando-o-build-e-executando-um-projeto-cargo" id="realizando-o-build-e-executando-um-projeto-cargo"><h3>Realizando o Build e Executando um projeto Cargo</h3></a>
<p>Agora vamos ver o que muda ao compilar e executar o seu projeto &quot;Ol√°, Mundo!&quot;
atrav√©s do Cargo! Para isso, digite os seguintes comandos:</p>
<pre><code class="language-text">$ cargo build
   Compiling ola_cargo v0.1.0 (file:///projetos/ola_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Este comando deve criar um arquivo execut√°vel em <em>target/debug/ola_cargo</em> (ou
<em>target\debug\ola_cargo.exe</em> no Windows), que voc√™ pode executar com o seguinte
comando:</p>
<pre><code class="language-text">$ ./target/debug/ola_cargo # ou .\target\debug\ola_cargo.exe no Windows
Hello, world!
</code></pre>
<p>Bam! Se tudo ocorrer bem, a mensagem <code>Hello, world!</code> deve aparecer no seu terminal.</p>
<p>Executar <code>cargo build</code> pela primeira vez tamb√©m faz com que Cargo crie um novo
arquivo chamado <em>Cargo.lock</em>, com um conte√∫do desse tipo:</p>
<p><span class="filename">Arquivo: Cargo.lock</span></p>
<pre><code class="language-toml">[root]
name = &quot;ola_cargo&quot;
version = &quot;0.1.0&quot;
</code></pre>
<p>O Cargo usa o arquivo <em>Cargo.lock</em> para rastrear as depend√™ncias da sua
aplica√ß√£o. Este projeto n√£o tem depend√™ncias, ent√£o o arquivo √© um pouco
escasso. Na realidade, voc√™ nem vai precisar mexer neste arquivo, apenas deixe
que o Cargo se encarregue dele.</p>
<p>N√≥s acabamos de fazer o <em>build</em> de um projeto utilizando o comando
<code>cargo build</code>, e o executamos com o comando <code>./target/debug/ola_cargo</code>, mas
podemos usar tamb√©m o comando <code>cargo run</code> para compilar e executar em sequ√™ncia:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/ola_cargo`
Hello, world!
</code></pre>
<p>Repare que, desta vez, n√£o vimos nenhuma mensagem de <em>output</em> (sa√≠da) nos
dizendo que Cargo estava compilando <code>ola_cargo</code>. O Cargo entendeu que n√£o houve
nenhuma mudan√ßa nos arquivos, ent√£o ele apenas executou o bin√°rio. Se voc√™
tivesse modificado o seu c√≥digo-fonte, o Cargo teria recompilado o projeto antes
de execut√°-lo, e voc√™ teria visto algo do tipo:</p>
<pre><code class="language-text">$ cargo run
   Compiling ola_cargo v0.1.0 (file:///projetos/ola_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/ola_cargo`
Hello, world!
</code></pre>
<p>Ent√£o, mais algumas diferen√ßas que vimos at√© agora foram:</p>
<ul>
<li>Em vez de usar <code>rustc</code>, fa√ßa o <em>build</em> do projeto usando <code>cargo build</code> (ou
fa√ßa o build e execute de uma vez s√≥ utilizando <code>cargo run</code>)</li>
<li>Em vez de colocar o resultado do <em>build</em> no mesmo diret√≥rio do nosso c√≥digo, o
Cargo ir√° colocar o resultado do <em>build</em> no diret√≥rio <em>target/debug</em>.</li>
</ul>
<p>A outra vantagem de usar o Cargo √© que os comandos s√£o os mesmos, n√£o importa em
qual sistema operacional voc√™ esteja. Por conta disso, a partir de agora, n√£o
vamos mais fornecer instru√ß√µes espec√≠ficas para Linux e Mac ou Windows.</p>
<a class="header" href="print.html#compilando-para-release" id="compilando-para-release"><h3>Compilando para <em>Release</em></h3></a>
<p>Quando o seu projeto est√° finalmente pronto para ser lan√ßado, voc√™ pode usar o
comando <code>cargo build --release</code> para compilar o seu projeto com otimiza√ß√µes.
Isso vai criar um arquivo execut√°vel na pasta <em>target/release</em> em vez de
<em>target/debug</em>. Estas otimiza√ß√µes fazem o seu c√≥digo Rust executar de maneira
mais r√°pida, mas por outro lado, tamb√©m fazem o programa levar mais tempo para
compilar. Por isso existem dois perfis diferentes: um para desenvolvimento,
quando voc√™ deseja recompilar rapidamente e com mais frequ√™ncia, e outro para
compilar a vers√£o final do seu programa, que vai ser entregue ao usu√°rio e n√£o
ser√° recompilada, e queremos que rode da maneira mais r√°pida poss√≠vel. Se voc√™
est√° fazendo um <em>benchmarking</em> do tempo de execu√ß√£o do seu c√≥digo, certifique-se
de executar o comando <code>cargo build --release</code>, e usar o execut√°vel que se
encontra na pasta <em>target/release</em>.</p>
<a class="header" href="print.html#cargo-como-conven√ß√£o" id="cargo-como-conven√ß√£o"><h3>Cargo como Conven√ß√£o</h3></a>
<p>Em projetos simples, o Cargo n√£o oferece tanto valor assim em rela√ß√£o a usar
apenas o <code>rustc</code>, mas vai fazer diferen√ßa √† medida que voc√™ continua. Em
projetos mais complexos, compostos de m√∫ltiplos <em>crates</em>, √© bem mais f√°cil
deixar o Cargo coordenar o processo de <em>build</em>. Com o Cargo, voc√™ pode apenas
executar o comando <code>cargo build</code>, e tudo dever√° funcionar da maneira correta.
Mesmo esse projeto sendo simples, ele utiliza muito das ferramentas que voc√™
ir√° usar pelo resto da sua carreira em Rust. Na verdade, voc√™ pode come√ßar a
trabalhar em praticamente qualquer projeto em Rust usando os seguintes comandos:</p>
<pre><code class="language-text">$ git clone algumaurl.com/algumprojeto
$ cd algumprojeto
$ cargo build
</code></pre>
<blockquote>
<p>Nota: Se voc√™ deseja conhecer o Cargo em mais detalhes, confira o
<a href="http://doc.crates.io/guide.html">Guia oficial do Cargo</a><!-- ignore --> (em ingl√™s), que aborda todas as suas
caracter√≠sticas.</p>
</blockquote>
<a class="header" href="print.html#jogo-de-adivinha√ß√£o" id="jogo-de-adivinha√ß√£o"><h1>Jogo de Adivinha√ß√£o</h1></a>
<p>Vamos entrar de cabe√ßa no Rust e colocar a m√£o na massa! Este cap√≠tulo vai lhe
apresentar alguns conceitos bem comuns no Rust, mostrando como us√°-los em um
programa de verdade. Voc√™ vai aprender sobre <code>let</code>, <code>match</code>, m√©todos, fun√ß√µes
associadas, crates externos, e mais! Os cap√≠tulos seguintes v√£o explorar essas
ideias em mais detalhes. Neste cap√≠tulo, voc√™ vai praticar o b√°sico.</p>
<p>Vamos implementar um cl√°ssico problema de programa√ß√£o para iniciantes: um jogo
de adivinha√ß√£o. Eis como ele funciona: o programa vai gerar um n√∫mero inteiro
aleat√≥rio entre 1 e 100. Ent√£o, ele vai pedir ao jogador que digite um palpite.
Ap√≥s darmos nosso palpite, ele vai nos indicar se o palpite √© muito baixo ou
muito alto. Uma vez que o palpite estiver correto, ele vai nos dar os parab√©ns e
sair.</p>
<a class="header" href="print.html#preparando-um-novo-projeto" id="preparando-um-novo-projeto"><h2>Preparando um Novo Projeto</h2></a>
<p>Para iniciar um novo projeto, v√° ao seu diret√≥rio de projetos que voc√™ criou no
Cap√≠tulo 1, e execute os comandos do Cargo a seguir:</p>
<pre><code class="language-text">$ cargo new jogo_de_advinhacao --bin
$ cd jogo_de_advinhacao
</code></pre>
<p>O primeiro comando, <code>cargo new</code>, recebe o nome do projeto (<code>jogo_de_advinhacao</code>)
como primeiro argumento. A flag <code>--bin</code> diz ao Cargo que fa√ßa um projeto
bin√°rio, similar ao do Cap√≠tulo 1. O segundo comando muda a pasta atual para o
diret√≥rio do projeto.</p>
<p>Confira o arquivo <em>Cargo.toml</em> gerado:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;jogo_de_advinhacao&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Se as informa√ß√µes sobre o autor, que o Cargo obt√©m do seu ambiente, n√£o
estiverem corretas, fa√ßa os reparos necess√°rios e salve o arquivo.</p>
<p>Assim como no Cap√≠tulo 1, <code>cargo new</code> gera um programa &quot;Hello, world!&quot; para n√≥s.
Confira em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Agora vamos compilar esse programa &quot;Hello, world!&quot; e execut√°-lo de uma vez s√≥
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jogo_de_advinhacao`
Hello, world!
</code></pre>
<p>O comando <code>run</code> √© uma boa op√ß√£o quando precisamos iterar rapidamente em um
projeto, que √© o caso neste jogo: n√≥s queremos testar rapidamente cada itera√ß√£o
antes de movermos para a pr√≥xima.</p>
<p>Abra novamente o arquivo <em>src/main.rs</em>. Escreveremos todo nosso c√≥digo nele.</p>
<a class="header" href="print.html#processando-um-palpite" id="processando-um-palpite"><h2>Processando um Palpite</h2></a>
<p>A primeira parte do programa vai pedir uma entrada ao usu√°rio, processar essa
entrada, e conferir se ela est√° no formato esperado. Pra come√ßar, vamos permitir
que o jogador entre com um palpite. Coloque este c√≥digo no arquivo
<em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-1: C√≥digo para ler um palpite do usu√°rio e
imprim√≠-lo na tela.</span></p>
<p>Esse c√≥digo tem muita informa√ß√£o, vamos ver uma parte de cada vez. Para obter a
entrada do usu√°rio, e ent√£o imprimir o resultado como sa√≠da, precisaremos trazer
ao escopo a biblioteca <code>io</code> (de entrada/sa√≠da). A biblioteca <code>io</code> prov√©m da
biblioteca padr√£o (chamada de <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Por padr√£o, o Rust traz apenas alguns tipos para o escopo de todos os programas
no <a href="../../std/prelude/index.html"><em>prel√∫dio</em></a><!-- ignore -->. Se um tipo que voc√™ quiser usar n√£o
estiver no prel√∫dio, voc√™ ter√° que import√°-lo explicitamente atrav√©s do <code>use</code>.
A biblioteca <code>std::io</code> oferece v√°rias ferramentas de entrada/sa√≠da, incluindo a
funcionalidade de ler dados de entrada do usu√°rio.</p>
<p>Como visto no Cap√≠tulo 1, a fun√ß√£o <code>main</code> √© o ponto de entrada do programa:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>A sintaxe <code>fn</code> declara uma nova fun√ß√£o, o <code>()</code> indica que n√£o h√° par√¢metros, e
o <code>{</code> inicia o corpo da fun√ß√£o.</p>
<p>Como voc√™ tamb√©m j√° aprendeu no Cap√≠tulo 1, <code>println!</code> √© uma macro que imprime
uma string na tela:</p>
<pre><code class="language-rust ignore">println!(&quot;Advinhe o n√∫mero!&quot;);

println!(&quot;Digite o seu palpite.&quot;);
</code></pre>
<p>Este c√≥digo est√° exibindo uma mensagem que diz de que se trata o jogo e solicita
uma entrada do usu√°rio.</p>
<a class="header" href="print.html#armazenando-valores-em-vari√°veis" id="armazenando-valores-em-vari√°veis"><h3>Armazenando Valores em Vari√°veis</h3></a>
<p>Pr√≥ximo passo, vamos criar um local para armazenar a entrada do usu√°rio:</p>
<pre><code class="language-rust ignore">let mut palpite = String::new();
</code></pre>
<p>Agora o programa est√° ficando interessante! Tem muita coisa acontecendo nesta
pequena linha. Repare que esta √© uma declara√ß√£o <code>let</code>, que √© usada para criar
<em>vari√°veis</em>. Segue outro exemplo:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Essa linha cria uma nova vari√°vel chamada <code>foo</code>, e a vincula ao valor <code>bar</code>. Em
Rust, vari√°veis s√£o imut√°veis por padr√£o. O exemplo a seguir mostra como usar
<code>mut</code> antes do nome da vari√°vel para torn√°-la mut√°vel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // imut√°vel
let mut bar = 5; // mut√°vel
#}</code></pre></pre>
<blockquote>
<p>Nota: A sintaxe <code>//</code> inicia um coment√°rio, que continua at√© o fim da linha.
Rust ignora tudo o que estiver nos coment√°rios.</p>
</blockquote>
<p>Agora voc√™ sabe que <code>let mut palpite</code> vai introduzir uma vari√°vel mut√°vel de
nome <code>palpite</code>. No outro lado do s√≠mbolo <code>=</code> est√° o valor ao qual <code>palpite</code> est√°
vinculado, que √© o resultado da chamada <code>String::new</code>, uma fun√ß√£o que retorna
uma nova inst√¢ncia de <code>String</code>. <a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore --> √© um tipo
fornecido pela biblioteca padr√£o que representa uma cadeia expans√≠vel de
caracteres codificados em UTF-8.</p>
<p>A sintaxe <code>::</code> na linha <code>::new</code> indica que <code>new</code> √© uma <em>fun√ß√£o associada</em> do
tipo <code>String</code>. Uma fun√ß√£o associada √© implementada sobre um tipo, neste caso
<code>String</code>, em vez de uma inst√¢ncia particular de <code>String</code>. Algumas linguagens
d√£o a isso o nome <em>m√©todo est√°tico</em>.</p>
<p>Esta fun√ß√£o <code>new()</code> cria uma nova <code>String</code> vazia. Voc√™ encontrar√° uma fun√ß√£o
<code>new()</code> em muitos tipos, j√° que √© um nome comum para uma fun√ß√£o que produz um
novo valor de algum tipo.</p>
<p>Para resumir, a linha <code>let mut palpite = String::new();</code> criou uma vari√°vel
mut√°vel que est√° atualmente vinculada a uma nova inst√¢ncia vazia de uma
<code>String</code>. Ufa!</p>
<p>Lembre-se de que inclu√≠mos a funcionalidade de entrada/sa√≠da da biblioteca
padr√£o por meio do <code>use std::io;</code> na primeira linha do programa. Agora vamos
chamar uma fun√ß√£o associada, <code>stdin</code>, em <code>io</code>:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite)
    .expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Se n√£o tiv√©ssemos a linha <code>use std::io</code> no in√≠cio do programa, poder√≠amos ter
escrito esta chamada como <code>std::io::stdin</code>. A fun√ß√£o <code>stdin</code> retorna uma
inst√¢ncia de <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, um tipo que representa
um manipulador (<em>handle</em>) da entrada padr√£o do seu terminal.</p>
<p>A pr√≥xima parte do c√≥digo, <code>.read_line(&amp;mut palpite)</code>, chama o m√©todo
<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> do <em>handle</em> da entrada padr√£o para obter
entrada do usu√°rio. Tamb√©m estamos passando um argumento para <code>read_line</code>:
<code>&amp;mut palpite</code>.</p>
<p>O trabalho da fun√ß√£o <code>read_line</code> √© receber o que o usu√°rio digita na entrada
padr√£o e colocar isso numa string, por isso ela recebe essa string como
argumento. A string do argumento deve ser mut√°vel para que o m√©todo consiga
alterar o seu conte√∫do, adicionando a entrada do usu√°rio.</p>
<p>O s√≠mbolo <code>&amp;</code> indica que o argumento √© uma <em>refer√™ncia</em>, o que permite m√∫ltiplas
partes do seu c√≥digo acessar um certo dado sem precisar criar v√°rias c√≥pias dele
na mem√≥ria. Refer√™ncias s√£o uma caracter√≠stica complexa, e uma das maiores
vantagens do Rust √© o qu√£o f√°cil e seguro √© usar refer√™ncias. Voc√™ n√£o precisa
conhecer muitos desses detalhes para finalizar esse programa. O Cap√≠tulo 4 vai
explicar sobre refer√™ncias de forma mais aprofundada. Por enquanto, tudo que
voc√™ precisa saber √© que, assim como as vari√°veis, refer√™ncias s√£o imut√°veis por
padr√£o. Por isso, precisamos escrever <code>&amp;mut palpite</code>, em vez de apenas
<code>&amp;palpite</code>, para fazer com que o palpite seja mut√°vel.</p>
<p>Ainda n√£o finalizamos completamente esta linha de c√≥digo. Embora esta seja uma
√∫nica linha de texto, √© apenas a primeira parte de uma linha l√≥gica de c√≥digo. A
segunda parte √© a chamada para este m√©todo:</p>
<pre><code class="language-rust ignore">.expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Quando voc√™ chama um m√©todo com a sintaxe <code>.foo()</code>, geralmente √© bom introduzir
uma nova linha e outro espa√ßo para ajudar a dividir linhas muito compridas.
Poder√≠amos ter feito assim:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite).expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Por√©m, uma linha muito comprida fica dif√≠cil de ler. Ent√£o √© melhor dividirmos a
linha em duas, uma para cada m√©todo chamado. Agora vamos falar sobre o que essa
linha faz.</p>
<a class="header" href="print.html#tratando-potenciais-falhas-com-o-tipo-result" id="tratando-potenciais-falhas-com-o-tipo-result"><h3>Tratando Potenciais Falhas com o Tipo <code>Result</code></h3></a>
<p>Como mencionado anteriormente, <code>read_line</code> coloca o que o usu√°rio escreve dentro
da string que passamos como argumento, mas tamb√©m retorna um valor - neste
caso, um <a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust tem uma variedade de
tipos com o nome <code>Result</code> em sua biblioteca padr√£o: um <a href="../../std/result/enum.Result.html"><code>Result</code></a>
gen√©rico e as vers√µes espec√≠ficas dos subm√≥dulos, como <code>io::Result</code>.</p>
<p>Os tipos <code>Result</code> s√£o <a href="ch06-00-enums.html"><em>enumera√ß√µes</em></a><!-- ignore -->, comumente chamadas
de <em>enums</em>. Uma enumera√ß√£o √© um tipo que pode ter um conjunto fixo de valores,
os quais s√£o chamados de <em>variantes</em> da enum. O Cap√≠tulo 6 vai abordar enums em
mais detalhes.</p>
<p>Para <code>Result</code>, as variantes s√£o <code>Ok</code> ou <code>Err</code>. <code>Ok</code> indica que a opera√ß√£o teve
sucesso, e dentro da variante <code>Ok</code> est√° o valor resultante. <code>Err</code> significa que
a opera√ß√£o falhou, e cont√©m informa√ß√µes sobre como ou por que isso ocorreu.</p>
<p>O prop√≥sito destes tipos <code>Result</code> √© codificar informa√ß√µes de manipula√ß√£o de
erros. Valores do tipo <code>Result</code>, assim como qualquer tipo, possuem m√©todos
definidos. Uma inst√¢ncia de <code>io::Result</code> tem um <a href="../../std/result/enum.Result.html#method.expect">m√©todo <code>expect</code></a><!-- ignore -->
que voc√™ pode chamar. Se esta inst√¢ncia de <code>io::Result</code> √© um <code>Err</code>, <code>expect</code> vai
terminar o programa com erro e mostrar a mensagem que voc√™ passou como argumento
ao <code>expect</code>. Se o m√©todo <code>read_line</code> retornar um <code>Err</code>, provavelmente seria o
resultado de um erro vindo do sistema operacional que est√° por tr√°s. Se esta
inst√¢ncia de <code>io::Result</code> √© um <code>Ok</code>, <code>expect</code> vai obter o valor contido no <code>Ok</code>
e retorn√°-lo para que voc√™ possa us√°-lo. Neste caso, o valor √© o n√∫mero de bytes
dos dados que o usu√°rio inseriu atrav√©s da entrada padr√£o.</p>
<p>Se n√£o chamarmos <code>expect</code>, nosso programa vai compilar, mas vamos ter um aviso:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut palpite);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust avisa que n√£o usamos o valor <code>Result</code>, retornado por <code>read_line</code>, indicando
que o programa deixou de tratar um poss√≠vel erro. A maneira correta de suprimir
o aviso √© realmente escrevendo um tratador de erro, mas como queremos que o
programa seja encerrado caso ocorra um problema, podemos usar <code>expect</code>. Voc√™
aprender√° sobre recupera√ß√£o de erros no Cap√≠tulo 9.</p>
<a class="header" href="print.html#exibindo-valores-com-curingas-do-println" id="exibindo-valores-com-curingas-do-println"><h3>Exibindo Valores com Curingas do <code>println!</code></h3></a>
<p>Tirando a chave que delimita a fun√ß√£o <code>main</code>, h√° apenas uma linha mais a ser
discutida no c√≥digo que fizemos at√© agora, que √© a seguinte:</p>
<pre><code class="language-rust ignore">println!(&quot;Voc√™ disse: {}&quot;, guess);
</code></pre>
<p>Esta linha imprime a string na qual salvamos os dados inseridos pelo usu√°rio. O
<code>{}</code> √© um curinga que reserva o lugar de um valor. Voc√™ pode imprimir mais de um
valor usando <code>{}</code>: o primeiro conjunto de <code>{}</code> guarda o primeiro valor listado
ap√≥s a string de formata√ß√£o, o segundo conjunto guarda o segundo valor, e
assim por diante. Imprimir m√∫ltiplos valores em uma s√≥ chamada a <code>println!</code>
seria assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} e y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Esse c√≥digo imprime <code>x = 5 e y = 10</code>.</p>
<a class="header" href="print.html#testando-a-primeira-parte" id="testando-a-primeira-parte"><h3>Testando a Primeira Parte</h3></a>
<p>Vamos testar a primeira parte do jogo de advinha√ß√£o. Voc√™ pode execut√°-lo usando
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
Digite o seu palpite.
6
Voc√™ disse: 6
</code></pre>
<p>Nesse ponto, a primeira parte do jogo est√° feita: podemos coletar entrada do
teclado e mostr√°-la na tela.</p>
<a class="header" href="print.html#gerando-um-n√∫mero-secreto" id="gerando-um-n√∫mero-secreto"><h2>Gerando um N√∫mero Secreto</h2></a>
<p>A seguir, precisamos gerar um n√∫mero secreto que o usu√°rio vai tentar advinhar.
O n√∫mero secreto deve ser diferente a cada execu√ß√£o, para que o jogo tenha gra√ßa
em ser jogado mais de uma vez. Vamos usar um n√∫mero aleat√≥rio entre 1 e 100,
para que o jogo n√£o seja t√£o dif√≠cil. Rust ainda n√£o inclui uma funcionalidade
de gera√ß√£o de n√∫meros aleat√≥rios em sua biblioteca padr√£o. Por√©m, a equipe Rust
fornece um <a href="https://crates.io/crates/rand">crate <code>rand</code></a>.</p>
<a class="header" href="print.html#usando-um-crate-para-ter-mais-funcionalidades" id="usando-um-crate-para-ter-mais-funcionalidades"><h3>Usando um Crate para Ter Mais Funcionalidades</h3></a>
<p>Lembre-se que um <em>crate</em> √© um pacote de c√≥digo Rust. O projeto que estamos
construindo √© um <em>crate bin√°rio</em>, que √© um execut√°vel. J√° o <code>rand</code> √© um
<em>crate de biblioteca</em>, que cont√©m c√≥digo cujo objetivo √© ser usado por outros
programas.</p>
<p>√â no uso de crates externos que Cargo realmente brilha. Antes que possamos
escrever o c√≥digo usando <code>rand</code>, precisamos modificar o arquivo <em>Cargo.toml</em>
para incluir o crate <code>rand</code> como uma depend√™ncia. Abra o arquivo e adicione
esta linha no final, abaixo do cabe√ßalho da se√ß√£o <code>[dependencies]</code> que o Cargo
criou para voc√™:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>No arquivo <em>Cargo.toml</em>, tudo que vem depois de um cabe√ßalho √© parte de uma
se√ß√£o que segue at√© o in√≠cio de outra. A se√ß√£o <code>[dependencies]</code> √© onde voc√™ diz
ao Cargo de quais crates externos o seu projeto depende, e quais vers√µes desses
crates voc√™ exige. Neste caso, especificamos o crate <code>rand</code> com a vers√£o
sem√¢ntica <code>0.3.14</code>. Cargo compreende <a href="https://semver.org/lang/pt-BR/">Versionamento Sem√¢ntico</a><!-- ignore -->
(√†s vezes chamado <em>SemVer</em>), um padr√£o para escrever n√∫meros de vers√µes. O
n√∫mero <code>0.3.14</code> √©, na verdade, uma forma curta de escrever <code>^0.3.14</code>, que
significa &quot;qualquer vers√£o que tenha uma API p√∫blica compat√≠vel com a vers√£o
0.3.14&quot;.</p>
<p>Agora, sem mudar c√≥digo algum, vamos compilar nosso projeto, conforme mostrado
na Listagem 2-2:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">Listagem 2-2: Resultado da execu√ß√£o de <code>cargo build</code>
depois de adicionar o crate <code>rand</code> como depend√™ncia.</span></p>
<p>Talvez pra voc√™ apare√ßam vers√µes diferentes (mas elas s√£o todas compat√≠veis com
o c√≥digo, gra√ßas ao Versionamento Sem√¢ntico!), e as linhas talvez apare√ßam em
ordem diferente.</p>
<p>Agora que temos uma depend√™ncia externa, Cargo busca as vers√µes mais recentes de
tudo no <em>registro</em>, que √© uma c√≥pia dos dados do <a href="https://crates.io">Crates.io</a>.
Crates.io √© onde as pessoas do ecossistema Rust postam seus projetos
<em>open source</em> para que os outros possam usar.</p>
<p>Ap√≥s atualizar o registro, Cargo verifica a se√ß√£o <code>[dependencies]</code> e baixa todas
as que voc√™ n√£o tem ainda. Neste caso, embora tenhamos listado apenas <code>rand</code>
como depend√™ncia, o Cargo tamb√©m puxou uma c√≥pia da <code>libc</code>, porque <code>rand</code>
depende da <code>libc</code> para funcionar. Depois de baix√°-las, o Cargo as compila e
ent√£o compila nosso projeto.</p>
<p>Se, logo em seguida, voc√™ executar <code>cargo build</code> novamente sem fazer mudan√ßas,
n√£o vai aparecer nenhuma mensagem de sa√≠da. O Cargo sabe que j√° baixou e
compilou as depend√™ncias, e voc√™ n√£o alterou mais nada sobre elas no seu arquivo
<em>Cargo.toml</em>. Cargo tamb√©m sabe que voc√™ n√£o mudou mais nada no seu c√≥digo, e
por isso n√£o o recompila. Sem nada a fazer, ele simplesmente sai. Se voc√™ abrir
<em>src/main.rs</em>, fizer uma modifica√ß√£o trivial, salvar e compilar de novo, vai
aparecer uma mensagem de apenas duas linhas:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Essas linhas mostram que o Cargo s√≥ atualiza o <em>build</em> com a sua pequena mudan√ßa
no arquivo <em>src/main.rs</em>. Suas depend√™ncias n√£o mudaram, ent√£o o Cargo sabe que
pode reutilizar o que j√° tiver sido baixado e compilado para elas. Ele apenas
recompila a sua parte do c√≥digo.</p>
<a class="header" href="print.html#o-arquivo-cargolock-garante-builds-reproduz√≠veis" id="o-arquivo-cargolock-garante-builds-reproduz√≠veis"><h4>O Arquivo <em>Cargo.lock</em> Garante <em>Builds</em> Reproduz√≠veis</h4></a>
<p>O Cargo tem um mecanismo que assegura que voc√™ pode reconstruir o mesmo artefato
toda vez que voc√™ ou outra pessoa compilar o seu c√≥digo. O Cargo vai usar apenas
as vers√µes das depend√™ncias que voc√™ especificou, at√© que voc√™ indique o
contr√°rio. Por exemplo, o que acontece se, na semana que vem, sair a vers√£o
<code>v0.3.15</code> contendo uma corre√ß√£o de bug, mas tamb√©m uma regress√£o que n√£o
funciona com o seu c√≥digo?</p>
<p>A resposta para isso est√° no arquivo <em>Cargo.lock</em>, que foi criado na primeira
vez que voc√™ executou <code>cargo build</code>, e agora est√° no seu diret√≥rio
<em>jogo_de_advinhacao</em>. Quando voc√™ compila o seu projeto pela primeira vez, o
Cargo descobre as vers√µes de todas as depend√™ncias que preenchem os crit√©rios
e ent√£o as escreve no arquivo <em>Cargo.lock</em>. Quando voc√™ compilar o seu projeto
futuramente, o Cargo ver√° que o arquivo <em>Cargo.lock</em> existe e usar√° as vers√µes
especificadas l√°, em vez de refazer todo o trabalho descobrir as vers√µes
novamente. Isto lhe permite ter um <em>build</em> reproduz√≠vel automaticamente. Em
outras palavras, seu projeto vai continuar com a vers√£o <code>0.3.14</code> at√© que voc√™
fa√ßa uma atualiza√ß√£o expl√≠cita, gra√ßas ao arquivo <em>Cargo.lock</em>.</p>
<a class="header" href="print.html#atualizando-um-crate-para-obter-uma-nova-vers√£o" id="atualizando-um-crate-para-obter-uma-nova-vers√£o"><h4>Atualizando um Crate para Obter uma Nova Vers√£o</h4></a>
<p>Quando voc√™ <em>quiser</em> atualizar um crate, o Cargo tem outro comando, <code>update</code>,
que faz o seguinte:</p>
<ol>
<li>Ignora o arquivo <em>Cargo.lock</em> e descobre todas as vers√µes mais recentes que
atendem as suas especifica√ß√µes no <em>Cargo.toml</em>.</li>
<li>Se funcionar, o Cargo escreve essas vers√µes no arquivo <em>Cargo.lock</em>.</li>
</ol>
<p>Mas, por padr√£o, o Cargo vai procurar as vers√µes maiores que <code>0.3.0</code> e menores
que <code>0.4.0</code>. Se o crate <code>rand</code> j√° tiver lan√ßado duas novas vers√µes, <code>0.3.15</code> e
<code>0.4.0</code>, voc√™ ver√° a seguinte mensagem ao executar <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>Nesse ponto, voc√™ vai notar tamb√©m uma mudan√ßa no seu arquivo <em>Cargo.lock</em>
dizendo que a vers√£o do crate <code>rand</code> que voc√™ est√° usando agora √© a <code>0.3.15</code>.</p>
<p>Se voc√™ quisesse usar a vers√£o <code>0.4.0</code>, ou qualquer vers√£o da s√©rie <code>0.4.x</code> do
<code>rand</code>, voc√™ teria que atualizar o seu <em>Cargo.toml</em> dessa forma:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Na pr√≥xima vez que voc√™ executar <code>cargo build</code>, o Cargo vai atualizar o registro
de crates dispon√≠veis e reavaliar os seus requisitos sobre o <code>rand</code> de acordo
com a nova vers√£o que voc√™ especificou.</p>
<p>H√° muito mais a ser dito sobre <a href="http://doc.crates.io">Cargo</a><!-- ignore --> e o <a href="http://doc.crates.io/crates-io.html">seu
ecossistema</a><!-- ignore --> que vai ser discutido no Cap√≠tulo 14,
mas por ora isto √© tudo que voc√™ precisa saber. Cargo facilita muito reutilizar
bibliotecas, de forma que os <em>rust√°ceos</em> consigam escrever projetos menores que
s√£o montados a partir de diversos pacotes.</p>
<a class="header" href="print.html#gerando-um-n√∫mero-aleat√≥rio" id="gerando-um-n√∫mero-aleat√≥rio"><h3>Gerando um N√∫mero Aleat√≥rio</h3></a>
<p>Agora vamos <em>usar</em>, de fato, o <code>rand</code>. O pr√≥ximo passo √© atualizar o
<em>src/main.rs</em> conforme mostrado na Listagem 2-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-3: Mudan√ßas necess√°rias do c√≥digo para gerar um
n√∫mero aleat√≥rio.</span></p>
<p>Estamos adicionando a linha <code>extern crate rand</code> ao topo do arquivo para indicar
ao Rust que estamos usando uma depend√™ncia externa. Isto tamb√©m √© equivalente a
um <code>use rand;</code>, assim podemos chamar qualquer coisa que esteja no crate <code>rand</code>
prefixando-a com <code>rand::</code>.</p>
<p>Em seguida, adicionamos outra linha <code>use</code>: <code>use rand::Rng</code>. <code>Rng</code> √© um trait
que define m√©todos a serem implementados pelos geradores de n√∫meros aleat√≥rios,
e esse trait deve estar dentro do escopo para que possamos usar esses m√©todos. O
Cap√≠tulo 10 vai abordar traits em mais detalhes.</p>
<p>Tem outras duas linhas que adicionamos no meio. A fun√ß√£o <code>rand::thread_rng</code> nos
d√° o gerador de n√∫meros aleat√≥rios que vamos usar, um que √© local √† <em>thread</em>
corrente e que √© inicializado pelo sistema operacional. Depois, vamos chamar o
m√©todo <code>gen_range</code> no gerador de n√∫meros aleat√≥rios. Esse m√©todo est√° definido
pelo trait <code>Rng</code> que trouxemos ao escopo por meio do <code>use rand::Rng</code>. Este
m√©todo recebe dois argumentos e gera um n√∫mero aleat√≥rio entre eles. Ele inclui
o limite inferior mas exclui o superior, ent√£o precisamos passar <code>1</code> e <code>101</code>
para obter um n√∫mero de 1 a 100.</p>
<p>Saber quais traits devem ser usadas e quais fun√ß√µes e m√©todos de um crate
devem ser chamados n√£o √© nada trivial. As instru√ß√µes de como usar um crate
est√£o na documenta√ß√£o de cada um. Outra coisa boa do Cargo √© que voc√™ pode rodar
o comando <code>cargo doc --open</code> que vai construir localmente a documenta√ß√£o
fornecida por todas as suas depend√™ncias e abr√≠-las no seu navegador. Se voc√™
estiver interessado em outras funcionalidades do crate <code>rand</code>, por exemplo,
execute <code>cargo doc --open</code> e clique em <code>rand</code>, no menu ao lado esquerdo.</p>
<p>A segunda linha que adicionamos imprime o n√∫mero secreto. Isto √© √∫til enquanto
estamos desenvolvendo o programa para podermos test√°-lo, mas vamos retir√°-la da
vers√£o final. Um jogo n√£o √© muito interessante se ele mostra a resposta logo no
in√≠cio!</p>
<p>Tente rodar o programa algumas vezes:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 7
Digite o seu palpite.
4
Voc√™ disse: 4
$ cargo run
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 83
Digite o seu palpite.
5
Voc√™ disse: 5
</code></pre>
<p>Voc√™ j√° deve obter n√∫meros aleat√≥rios diferentes, e eles devem ser todos entre 1
e 100. Bom trabalho!</p>
<a class="header" href="print.html#comparando-o-palpite-com-o-n√∫mero-secreto" id="comparando-o-palpite-com-o-n√∫mero-secreto"><h2>Comparando o Palpite com o N√∫mero Secreto</h2></a>
<p>Agora que n√≥s temos a entrada do usu√°rio e o n√∫mero secreto, vamos compar√°-los.
Esta estapa √© mostrada na Listagem 2-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listagem 2-4: Tratando os poss√≠veis resultados da
compara√ß√£o de dois n√∫meros.</span></p>
<p>A primeira novidade aqui √© outro <code>use</code>, que traz ao escopo um tipo da biblioteca
padr√£o chamado <code>std::cmp::Ordering</code>. <code>Ordering</code> √© outra enum, igual a <code>Result</code>,
mas as suas variantes s√£o <code>Less</code>, <code>Greater</code> e <code>Equal</code> (elas significam menor,
maior e igual, respectivamente). Estes s√£o os tr√™s poss√≠veis resultados quando
voc√™ compara dois valores.</p>
<p>Depois, adicionamos cinco novas linhas no final que usam o tipo <code>Ordering</code>:</p>
<pre><code class="language-rust ignore">match palpite.cmp(&amp;numero_secreto) {
    Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
    Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
    Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
}
</code></pre>
<p>O m√©todo <code>cmp</code> compara dois valores, e pode ser chamado a partir de qualquer
coisa que possa ser comparada. Ele recebe uma refer√™ncia de qualquer coisa que
voc√™ queira comparar. Neste caso, est√° comparando o <code>palpite</code> com o
<code>numero_secreto</code>. <code>cmp</code> retorna uma variante do tipo <code>Ordering</code>, que trouxemos
ao escopo com <code>use</code>. N√≥s usamos uma express√£o <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->
para decidir o que fazer em seguida, com base em qual variante de <code>Ordering</code> foi
retornada pelo m√©todo <code>cmp</code>, que foi chamado com os valores <code>palpite</code> e
<code>numero_secreto</code>.</p>
<p>Uma express√£o <code>match</code> √© composta de <em>bra√ßos</em>. Um bra√ßo consiste em um <em>padr√£o</em>
mais o c√≥digo que deve ser executado se o valor colocado no in√≠cio do <code>match</code> se
encaixar no padr√£o deste bra√ßo. O Rust pega o valor passado ao <code>match</code> e o
compara com o padr√£o de cada bra√ßo na sequ√™ncia. A express√£o <code>match</code> e os
padr√µes s√£o ferramentas poderosas do Rust que lhe permitem expressar uma
variedade de situa√ß√µes que seu c√≥digo pode encontrar, e ajuda a assegurar que
voc√™ tenha tratado todas elas. Essas ferramentas ser√£o abordadas em detalhes nos
cap√≠tulos 6 e 18, respectivamente.</p>
<p>Vamos acompanhar um exemplo do que aconteceria na express√£o <code>match</code> usada aqui.
Digamos que o usu√°rio tenha colocado 50 como palpite, e o n√∫mero secreto
aleat√≥rio desta vez √© 38. Quando o c√≥digo compara 50 com 38, o m√©todo <code>cmp</code> vai
retornar <code>Ordering::Greater</code>, porque 50 √© maior que 38. <code>Ordering::Greater</code> √© o
valor passado ao <code>match</code>. Ele olha para o padr√£o <code>Ordering::Less</code> do primeiro
bra√ßo, mas o valor <code>Ordering::Greater</code> n√£o casa com <code>Ordering::Less</code>, ent√£o ele
ignora o c√≥digo desse bra√ßo e avan√ßa para o pr√≥ximo. J√° o padr√£o do pr√≥ximo
bra√ßo, <code>Ordering::Greater</code>, <em>casa</em> com <code>Ordering::Greater</code>! O c√≥digo associado a
este bra√ßo vai ser executado e mostrar <code>Muito alto!</code> na tela. A express√£o
<code>match</code> termina porque j√° n√£o tem mais necessidade de verificar o √∫ltimo bra√ßo
nesse caso particular.</p>
<p>Por√©m, o c√≥digo da Listagem 2-4 ainda n√£o vai compilar. Vamos tentar:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match palpite.cmp(&amp;numero_secreto) {
   |                       ^^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `jogo_de_advinhacao`.
</code></pre>
<p>O que este erro est√° dizendo √© que temos <em>tipos incompat√≠veis</em>. Rust tem um
sistema de tipos forte e est√°tico. Por√©m, Rust tamb√©m tem infer√™ncia de tipos.
Quando escrevemos <code>let palpite = String::new()</code>, Rust foi capaz de inferir que
<code>palpite</code> deveria ser uma <code>String</code>, ent√£o ele n√£o nos faz escrever o tipo. O
<code>numero_secreto</code>, por outro lado, √© de um tipo num√©rico. Existem alguns tipos
num√©ricos capazes de guardar um valor entre 1 e 100: <code>i32</code>, que √© um n√∫mero de
32 bits; <code>u32</code>, um n√∫mero de 32 bits sem sinal; <code>i64</code>, um n√∫mero de 64 bits; e
mais alguns outros. O tipo num√©rico padr√£o do Rust √© <code>i32</code>, que √© o tipo do
<code>numero_secreto</code>, a n√£o ser que adicionemos, em algum lugar, uma informa√ß√£o de
tipo que fa√ßa o Rust inferir outro tipo num√©rico. A raz√£o do erro √© que o Rust
n√£o pode comparar uma string e um tipo num√©rico.</p>
<p>Em √∫ltima an√°lise, queremos converter a <code>String</code> que lemos como entrada em um
tipo num√©rico de verdade, de forma que possamos compar√°-lo numericamente com o
palpite. Podemos fazer isso com mais duas linhas no corpo da fun√ß√£o <code>main</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    let palpite: u32 = palpite.trim().parse()
        .expect(&quot;Por favor, digite um n√∫mero!&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
    }
}
</code></pre>
<p>As duas linhas novas s√£o:</p>
<pre><code class="language-rust ignore">let palpite: u32 = palpite.trim().parse()
    .expect(&quot;Por favor, digite um n√∫mero!&quot;);
</code></pre>
<p>N√≥s criamos uma vari√°vel chamada <code>palpite</code>. Mas espera, o programa j√° n√£o tinha
uma vari√°vel chamada <code>palpite</code>? Sim, mas o Rust nos permite <em>sombrear</em> o
<code>palpite</code> anterior com um novo. Isto √© geralmente usado em situa√ß√µes em que voc√™
quer converter um valor de um tipo em outro. O sombreamento nos permite
reutilizar o nome <code>palpite</code>, em vez de nos for√ßar a criar dois nomes √∫nicos como
<code>palpite_str</code> e <code>palpite</code>, por exemplo. (O Cap√≠tulo 3 vai cobrir sombreamento em
mais detalhes).</p>
<p>N√≥s vinculamos <code>palpite</code> √† express√£o <code>palpite.trim().parse()</code>. O <code>palpite</code>, na
express√£o, refere-se ao <code>palpite</code> original contendo a <code>String</code> de entrada do
usu√°rio. O m√©todo <code>trim</code>, em uma inst√¢ncia de <code>String</code>, vai eliminar quaisquer
espa√ßos em branco no in√≠cio e no fim. <code>u32</code> pode conter apenas caracteres
num√©ricos, mas o usu√°rio precisa pressionar <span class="keystroke">Enter</span>
para satisfazer o <code>read_line</code>. Quando o usu√°rio pressiona
<span class="keystroke">Enter</span>, um caractere de nova linha √© inserido na
string. Por exemplo, se o usu√°rio digitar <span class="keystroke">5</span> e
depois <span class="keystroke">Enter</span>, <code>palpite</code> ficaria assim: <code>5\n</code>. O
<code>\n</code> representa uma linha nova, a tecla <span class="keystroke">Enter</span>.
O m√©todo <code>trim</code> elimina o <code>\n</code>, deixando apenas <code>5</code>.</p>
<p>O <a href="../../std/primitive.str.html#method.parse">m√©todo <code>parse</code> em strings</a><!-- ignore --> converte uma string para
algum tipo de n√∫mero. Dado que ele pode interpretar uma variedade de tipos
num√©ricos, precisamos dizer ao Rust qual o tipo exato de n√∫mero n√≥s queremos, e
para isso usamos <code>let palpite: u32</code>. Os dois pontos (<code>:</code>) depois de <code>palpite</code>
informam ao Rust que estamos anotando seu tipo. O Rust tem alguns tipos
num√©ricos embutidos, o <code>u32</code> visto aqui √© um inteiro de 32 bits sem sinal. √â uma
boa escolha padr√£o para um n√∫mero positivo pequeno. Voc√™ vai aprender sobre
outros tipos num√©ricos no Cap√≠tulo 3. Al√©m disso, a anota√ß√£o <code>u32</code> neste
programa de exemplo e a compara√ß√£o com <code>numero_secreto</code> significam que o Rust
vai inferir que <code>numero_secreto</code> tamb√©m deve ser um <code>u32</code>. Ent√£o agora a
compara√ß√£o vai ser feita entre valores do mesmo tipo!</p>
<p>A chamada para <code>parse</code> poderia facilmente causar um erro. Por exemplo, se a
string contiver <code>Aüëç%</code>, n√£o haveria como converter isto em um n√∫mero. Como ele
pode falhar, o m√©todo <code>parse</code> retorna um <code>Result</code>, assim como o m√©todo
<code>read_line</code>, conforme discutido anteriormente na se√ß√£o &quot;Tratando Potenciais
Falhas com o Tipo <code>Result</code>. Vamos tratar este <code>Result</code> da mesma forma usando o
m√©todo <code>expect</code> de novo. Se o <code>parse</code> retornar uma variante <code>Err</code> da enum
<code>Result</code>, por n√£o conseguir criar um n√∫mero a partir da string, a chamada ao
<code>expect</code> vai causar um <em>crash</em> no jogo e exibir a mensagem que passamos a ele.
Se o <code>parse</code> conseguir converter uma string em um n√∫mero, ele vai retornar a
variante <code>Ok</code> da enum <code>Result</code> e <code>expect</code> vai retornar o n√∫mero que queremos
extrair do valor <code>Ok</code>.</p>
<p>Agora vamos executar o programa!</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 58
Digite o seu palpite.
  76
Voc√™ disse: 76
Muito alto!
</code></pre>
<p>Boa! At√© mesmo colocando alguns espa√ßos antes de digitar o palpite, o programa
ainda descobriu que o palpite do usu√°rio √© 76. Execute o programa mais algumas
vezes para verificar os diferentes comportamentos com diferentes tipos de
entrada: advinhe o n√∫mero corretamente, digite um n√∫mero muito alto, e digite um
n√∫mero muito baixo.</p>
<p>Agora j√° temos a maior parte do jogo funcionando, mas o usu√°rio s√≥ consegue dar
um palpite uma vez. Vamos mudar isso adicionando la√ßos!</p>
<a class="header" href="print.html#permitindo-m√∫ltiplos-palpites-usando-looping" id="permitindo-m√∫ltiplos-palpites-usando-looping"><h2>Permitindo M√∫ltiplos Palpites Usando <em>Looping</em></h2></a>
<p>A palavra-chave <code>loop</code> nos d√° um la√ßo (<em>loop</em>) infinito. Use-a para dar aos
usu√°rios mais chances de advinhar o n√∫mero:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um n√∫mero!&quot;);

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
        }
    }
}
</code></pre>
<p>Como voc√™ pode ver, movemos tudo para dentro do la√ßo a partir da mensagem
pedindo o palpite do usu√°rio. Certifique-se de indentar essas linhas mais quatro
espa√ßos cada uma, e execute o programa novamente. Repare que h√° um novo
problema, porque o programa est√° fazendo exatamente o que dissemos para ele
fazer: pedir sempre outro palpite! Parece que o usu√°rio n√£o consegue sair!</p>
<p>O usu√°rio pode sempre interromper o programa usando as teclas
<span class="keystroke">ctrl-c</span>. Mas h√° uma outra forma de escapar deste
monstro insaci√°vel que mencionamos na discuss√£o do m√©todo <code>parse</code>, na se√ß√£o
&quot;Comparando o Palpite com o N√∫mero Secreto&quot;: se o usu√°rio fornece uma resposta
n√£o-num√©rica, o programa vai sofrer um <em>crash</em>. O usu√°rio pode levar vantagem
disso para conseguir sair, como mostrado abaixo:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 59
Digite o seu palpite.
45
Voc√™ disse: 45
Muito baixo!
Digite o seu palpite.
60
Voc√™ disse: 60
Muito alto!
Digite o seu palpite.
59
Voc√™ disse: 59
Voc√™ acertou!
Digite o seu palpite.
sair
thread 'main' panicked at 'Por favor, digite um n√∫mero!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/jogo_de_advinhacao` (exit code: 101)
</code></pre>
<p>Digitar <code>sair</code>, na verdade, sai do jogo, mas isso tamb√©m acontece com qualquer
outra entrada n√£o num√©rica. Por√©m, isto n√£o √© o ideal. Queremos que o jogo
termine automaticamente quando o n√∫mero √© advinhado corretamente.</p>
<a class="header" href="print.html#saindo-ap√≥s-um-palpite-correto" id="saindo-ap√≥s-um-palpite-correto"><h3>Saindo Ap√≥s um Palpite Correto</h3></a>
<p>Vamos programar o jogo para sair quando o usu√°rio vencer, colocando um <code>break</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um n√∫mero!&quot;);

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Voc√™ acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adicionando a linha <code>break</code> ap√≥s o <code>Voc√™ acertou!</code>, o programa vai sair do la√ßo
quando o usu√°rio advinhar corretamente o n√∫mero secreto. Sair do la√ßo tamb√©m
significa sair do programa, pois o la√ßo √© a √∫ltima parte da <code>main</code>.</p>
<a class="header" href="print.html#tratando-entradas-inv√°lidas" id="tratando-entradas-inv√°lidas"><h3>Tratando Entradas Inv√°lidas</h3></a>
<p>Para refinar ainda mais o comportamento do jogo, em vez de causar um <em>crash</em> no
programa quando o usu√°rio insere uma entrada n√£o num√©rica, vamos fazer o jogo
ignor√°-la para que o usu√°rio possa continuar tentando. Podemos fazer isso
alterando a linha em que o <code>palpite</code> √© convertido de <code>String</code> para <code>u32</code>:</p>
<pre><code class="language-rust ignore">let palpite: u32 = match palpite.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Trocando uma chamada a <code>expect</code> por uma express√£o <code>match</code> √© a forma como voc√™
geralmente deixa de causar um <em>crash</em> em um erro e passa a trat√°-lo, de fato.
Lembre-se que o m√©todo <code>parse</code> retorna um valor do tipo <code>Result</code>, uma enum que
cont√©m a variante <code>Ok</code> ou <code>Err</code>. Estamos usando um <code>match</code> aqui, assim como
fizemos com o <code>Ordering</code> resultante do m√©todo <code>cmp</code>.</p>
<p>Se o <code>parse</code> consegue converter a string em um n√∫mero, ele vai retornar um <code>Ok</code>
contendo o n√∫mero resultante. Esse valor <code>Ok</code> vai casar com o padr√£o do primeiro
bra√ßo, e o <code>match</code> vai apenas retornar o valor <code>num</code> produzido pelo <code>parse</code> e
colocado dentro do <code>Ok</code>. Esse n√∫mero vai acabar ficando exatamente onde
queremos, na vari√°vel <code>palpite</code> que estamos criando.</p>
<p>Se o <code>parse</code> <em>n√£o</em> conseguir converter a string em um n√∫mero, ele vai retornar
um <code>Err</code> que cont√©m mais informa√ß√µes sobre o erro. O valor <code>Err</code> n√£o casa com o
padr√£o <code>Ok(num)</code> do primeiro bra√ßo do <code>match</code>, mas casa com o padr√£o <code>Err(_)</code> do
segundo bra√ßo. O <code>_</code> √© um valor &quot;pega tudo&quot;. Neste exemplo, estamos dizendo que
queremos casar todos os valores <code>Err</code>, n√£o importa qual informa√ß√£o h√° dentro
deles. Ent√£o o programa vai executar o c√≥digo do segundo bra√ßo, <code>continue</code>, que
significa ir para a pr√≥xima itera√ß√£o do <code>loop</code> e pedir outro palpite.
Efetivamente, o programa ignora todos os erros que o <code>parse</code> vier a encontrar!</p>
<p>Agora, tudo no programa deve funcionar como esperado. Vamos tentar execut√°-lo
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 61
Digite o seu palpite.
10
Voc√™ disse: 10
Muito baixo!
Digite o seu palpite.
99
Voc√™ disse: 99
Muito alto!
Digite o seu palpite.
foo
Digite o seu palpite.
61
Voc√™ disse: 61
Voc√™ acertou!
</code></pre>
<p>Demais! Com apenas um √∫ltimo ajuste, vamos finalizar o jogo de adivinha√ß√£o:
lembre-se que o programa ainda est√° mostrando o n√∫mero secreto. Isto foi bom
para testar, mas estraga o jogo. Vamos apagar o <code>println!</code> que revela o n√∫mero
secreto. A Listagem 2-5 mostra o c√≥digo final:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = match palpite.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Voc√™ acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 2-5: C√≥digo completo do jogo de advinha√ß√£o.
</span></p>
<a class="header" href="print.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Neste ponto, voc√™ construiu com sucesso o jogo de adivinha√ß√£o! Parab√©ns!</p>
<p>Este projeto foi uma forma pr√°tica de apresentar v√°rios conceitos novos de Rust:
<code>let</code>, <code>match</code>, m√©todos, fun√ß√µes associadas, uso de crates externos, e outros.
Nos pr√≥ximos cap√≠tulos, voc√™ vai aprender sobre esses conceitos em mais
detalhes. O Cap√≠tulo 3 aborda conceitos que a maioria das linguagens de
programa√ß√£o tem, como vari√°veis, tipos de dados e fun√ß√µes, e mostra como us√°-los
em Rust. O Cap√≠tulo 4 explora posse (<em>ownership</em>), que √© a caracter√≠stica do
Rust mais diferente das outras linguagens. O Cap√≠tulo 5 discute structs e a
sintaxe de m√©todos, e o Cap√≠tulo 6 se dedica a explicar enums.</p>
<a class="header" href="print.html#-conceitos-comuns-de-programa√ß√£o" id="-conceitos-comuns-de-programa√ß√£o"><h1>üáßüá∑ Conceitos Comuns de Programa√ß√£o</h1></a>
<a class="header" href="print.html#-vari√°veis-e-mutabilidade" id="-vari√°veis-e-mutabilidade"><h1>üáßüá∑ Vari√°veis e Mutabilidade</h1></a>
<a class="header" href="print.html#data-types" id="data-types"><h1>Data Types</h1></a>
<a class="header" href="print.html#how-functions-work" id="how-functions-work"><h1>How Functions Work</h1></a>
<a class="header" href="print.html#comments" id="comments"><h1>Comments</h1></a>
<a class="header" href="print.html#control-flow" id="control-flow"><h1>Control Flow</h1></a>
<a class="header" href="print.html#entendendo-ownership" id="entendendo-ownership"><h1>Entendendo <em>Ownership</em></h1></a>
<p><em>Ownership</em> (posse) √© a caracter√≠stica mais √∫nica do Rust, que o permite ter
garantias de seguran√ßa de mem√≥ria sem precisar de um <em>garbage collector</em>. Logo,
√© importante entender como funciona ownership no Rust. Neste cap√≠tulo, falaremos
sobre ownership e tamb√©m sobre v√°rias caracter√≠sticas relacionadas: <em>borrowing</em>,
<em>slices</em> e como o Rust disp√µe seus dados na mem√≥ria.</p>
<a class="header" href="print.html#o-que-√â-ownership" id="o-que-√â-ownership"><h2>O Que √â Ownership?</h2></a>
<p>A caracter√≠stica central do Rust √© <em>ownership</em>. Embora seja bem direta de
explicar, ela tem implica√ß√µes profundas em todo o resto da linguagem.</p>
<p>Todos os programas t√™m que decidir de que forma v√£o usar a mem√≥ria do computador
durante a execu√ß√£o. Algumas linguagens possuem <em>garbage collection</em> (coleta de
lixo), que constantemente busca segmentos de mem√≥ria que j√° n√£o s√£o mais
utilizados enquanto o programa executa; em outras linguagens, o programador deve
alocar e liberar mem√≥ria de forma expl√≠cita. Rust usa uma terceira abordagem: a
mem√≥ria √© gerenciada atrav√©s de um sistema de posse, que tem um conjunto de
regras verificadas em tempo de compila√ß√£o. Nenhuma caracter√≠stica relacionada ao
ownership implica qulaquer custo em tempo de execu√ß√£o.</p>
<p>Como ownership √© um conceito novo para muitos programadores, leva um pouco de
tempo para se acostumar. A boa not√≠cia √© que quanto mais experiente voc√™ se
torna em Rust e nas regras do sistema de posse, mais voc√™ ser√° capaz de
escrever, naturalmente, c√≥digo seguro e eficiente. Fique a√≠!</p>
<p>Quando voc√™ entender ownership, voc√™ ter√° uma funda√ß√£o s√≥lida para entender as
caracter√≠sticas que fazem o Rust ser √∫nico. Neste cap√≠tulo, voc√™ vai aprender
ownership trabalhando em alguns exemplos com foco em uma estrutura de dados
muito comum: <em>strings</em>.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="print.html#a-pilha-e-a-heap" id="a-pilha-e-a-heap"><h3>A Pilha e a <em>Heap</em></h3></a>
<p>Em muitas linguagens de programa√ß√£o, n√£o temos que pensar muito sobre a pilha
e sobre a <em>heap</em>. Mas em uma linguagem de programa√ß√£o de sistemas, como Rust,
o fato de um valor estar na pilha ou na heap tem impacto na forma como a
linguagem se comporta e no porqu√™ de termos que tomar certas decis√µes. Vamos
descrever partes do ownership em rela√ß√£o √† pilha e √† heap mais para a frente
neste cap√≠tulo, ent√£o aqui vai uma explica√ß√£o preparat√≥ria.</p>
<p>Tanto a pilha como a heap s√£o partes da mem√≥ria que est√£o dispon√≠veis ao seu
c√≥digo para uso em tempo de execu√ß√£o, mas elas s√£o estruturadas de formas
diferentes. A pilha armazena valores na ordem em que eles chegam, e os remove
na ordem inversa. Isto √© chamado de <em>last in, first out</em> (√∫ltimo a chegar,
primeiro a sair). Imagine uma pilha de pratos: quando voc√™ coloca mais pratos,
voc√™ os p√µe em cima da pilha, e quando voc√™ precisa de um prato, voc√™ pega o
que est√° no topo. Adicionar ou remover pratos do meio ou do fundo n√£o funciona
t√£o bem! Dizemos fazer um <em>push</em> na pilha quando nos refererimos a inserir
dados, e fazer um <em>pop</em> da pilha quando nos referimos a remover dados.</p>
<p>A pilha √© r√°pida por conta da forma como ela acessa os dados: ela nunca tem
que procurar um lugar para colocar novos dados, ou um lugar de onde obter
dados, este lugar √© sempre o topo da pilha. Outra propriedade que faz a pilha
ser r√°pida √© que todos os dados contidos nela devem ocupar um tamanho fixo e
conhecido.</p>
<p>Para dados com um tamanho desconhecido em tempo de compila√ß√£o, ou com um
tamanho que pode mudar, podemos usar a heap em vez da pilha. A heap √© menos
organizada: quando colocamos dados na heap, n√≥s pedimos um certo espa√ßo de
mem√≥ria. O sistema operacional encontra um espa√ßo vazio em algum lugar na heap
que seja grande o suficiente, marca este espa√ßo como em uso, e nos retorna um
<em>ponteiro</em>, que √© o endere√ßo deste local. Este processo √© chamado de
<em>alocar na heap</em>, e √†s vezes se abrevia esta frase como apenas &quot;aloca√ß√£o&quot;.
Colocar valores na pilha n√£o √© considerado uma aloca√ß√£o. Como o ponteiro tem
um tamanho fixo e conhecido, podemos armazen√°-lo na pilha, mas quando queremos
os dados, de fato, temos que seguir o ponteiro.</p>
<p>Imagine que voc√™ est√° sentado em um restaurante. Quando voc√™ entra, voc√™ diz
o n√∫mero de pessoas que est√£o com voc√™, o atendente encontra uma mesa vazia
que acomode todos e os leva para l√°. Se algu√©m do seu grupo chegar mais tarde,
poder√° perguntar onde voc√™s est√£o para encontr√°-los.</p>
<p>Acessar dados na heap √© mais lento do que acessar dados na pilha, porque voc√™
precisa seguir um ponteiro para chegar l√°. Processadores de hoje em dia s√£o
mais r√°pidos se n√£o precisarem pular tanto de um lugar para outro na mem√≥ria.
Continuando com a analogia, considere um gar√ßom no restaurante anotando os
pedidos de v√°rias mesas. √â mais eficiente anotar todos os pedidos de uma √∫nica
mesa antes de passar para a mesa seguinte. Anotar um pedido da mesa A, depois
um da mesa B, depois outro da mesa A, e outro da mesa B novamente seria um
processo bem mais lento. Da mesma forma, um processador pode cumprir melhor
sua tarefa se trabalhar em dados que est√£o pr√≥ximos uns dos outros (assim como
est√£o na pilha) em vez de dados afastados entre si (como podem estar na heap).
Alocar um espa√ßo grande na heap tamb√©m pode levar tempo.</p>
<p>Quando nosso c√≥digo chama uma fun√ß√£o, os valores passados para ela (incluindo
poss√≠veis ponteiros para dados na heap) e as vari√°veis locais da fun√ß√£o s√£o
colocados na pilha. Quando a fun√ß√£o termina, esses valores s√£o removidos dela.</p>
<p>Rastrear quais partes do c√≥digo est√£o usando quais dados na heap, minimizar a
quantidade de dados duplicados na heap e limpar segmentos inutilizados da heap
para que n√£o fiquemos sem espa√ßo s√£o todos problemas tratados pelo ownership.
Uma vez que voc√™ entende ownership, voc√™ n√£o vai mais precisar pensar tanto
sobre a pilha e a heap, mas saber que ownership existe para gerenciar os dados
na heap pode ajudar a explicar como e por que ele funciona.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="print.html#regras-de-ownership" id="regras-de-ownership"><h3>Regras de Ownership</h3></a>
<p>Primeiro, vamos dar uma olhada nas regras de ownership. Mantenha em mente essas
regras quando trabalharmos com os exemplos em seguida:</p>
<blockquote>
<ol>
<li>Cada valor em Rust possui uma vari√°vel que √© dita seu <em>owner</em> (sua dona).</li>
<li>Pode apenas haver um owner por vez.</li>
<li>Quando o owner sai fora de escopo, o valor ser√° destru√≠do.</li>
</ol>
</blockquote>
<a class="header" href="print.html#escopo-de-vari√°veis" id="escopo-de-vari√°veis"><h3>Escopo de Vari√°veis</h3></a>
<p>J√° analisamos um exemplo de programa em Rust no Cap√≠tulo 2. Agora que j√°
passamos da sintaxe b√°sica, n√£o vamos incluir o c√≥digo <code>fn main() {</code> nos
pr√≥ximos exemplos, ent√£o se voc√™ estiver acompanhando, ter√° que coloc√°-los
manualmente dentro de uma fun√ß√£o <code>main</code>. Como resultado, nossos exemplos ser√£o
um pouco mais concisos, mantendo o foco nos detalhes que realmente interessam.</p>
<p>Como um primeiro exemplo de ownership, vamos olhar para o <em>escopo</em> de algumas
vari√°veis. Um escopo √© a √°rea dentro de um programa para a qual um item √©
v√°lido. Digamos que n√≥s temos uma vari√°vel como esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;ol√°&quot;;
#}</code></pre></pre>
<p>A vari√°vel <code>s</code> se refere a uma string literal cujo valor √© fixo no c√≥digo. A
vari√°vel √© v√°lida do ponto em que √© declarada at√© o fim do atual <em>escopo</em>. A
Listagem 4-1 tem coment√°rios indicando onde a vari√°vel <code>s</code> √© v√°lida:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // s n√£o √© v√°lida aqui, ainda n√£o est√° declarada
    let s = &quot;texto&quot;;   // s √© v√°lida deste ponto em diante

    // faz alguma coisa com s
}                      // agora este escopo terminou, e s n√£o √© mais v√°lida
#}</code></pre></pre>
<p><span class="caption">Listagem 4-1: Uma vari√°vel e o escopo em que ela √©
v√°lida.</span></p>
<p>Em outras palavras, existem dois pontos no tempo que s√£o importantes aqui:</p>
<ol>
<li>Quando <code>s</code> <em>entra no escopo</em>, ela √© v√°lida.</li>
<li>Permanece dessa maneira at√© que ela <em>saia de escopo</em>.</li>
</ol>
<p>Neste ponto, a rela√ß√£o entre escopos e quando vari√°veis s√£o v√°lidas √© similar a
outras linguagens de programa√ß√£o. Agora vamos construir sobre este entendimento,
apresentando o tipo <code>String</code>.</p>
<a class="header" href="print.html#o-tipo-string" id="o-tipo-string"><h3>O Tipo <code>String</code></h3></a>
<p>Para ilustrar as regras de ownership, precisamos de um tipo de dados que seja
mais complexo do que aqueles abordados no Cap√≠tulo 3. Os tipos abordados na
se√ß√£o &quot;Tipos de Dados&quot; s√£o todos armazenados na pilha, e retirados dela quando
seu escopo termina, mas queremos ver dados que s√£o armazenados na heap e
explorar como o Rust faz para saber quando limpar esses dados.</p>
<p>Vamos usar <code>String</code> como exemplo aqui, e concentrar nas partes de <code>String</code> que
est√£o relacionadas ao ownership. Esses aspectos tamb√©m se aplicam aos outros
tipos complexos de dados fornecidos pela biblioteca padr√£o e os que voc√™ mesmo
cria. Vamos discutir <code>String</code> mais a fundo no Cap√≠tulo 8.</p>
<p>J√° vimos strings literais, em que um valor de string √© fixado pelo c√≥digo do
nosso programa. Strings literais s√£o convenientes, mas nem sempre s√£o adequadas
para situa√ß√µes em que queremos usar texto. Um motivo √© que elas s√£o imut√°veis.
Outro √© que nem todos os valores de string s√£o conhecidos enquanto escrevemos
nosso c√≥digo: por exemplo, o que fazer se queremos obter uma entrada do usu√°rio
e armazen√°-la? Para essas situa√ß√µes, Rust tem um segundo tipo de strings,
<code>String</code>. Este tipo √© alocado na heap, e como tal, √© capaz de armazenar uma
quantidade de texto que √© desconhecida em tempo de compila√ß√£o. Voc√™ pode criar
uma <code>String</code> de uma string literal usando a fun√ß√£o <code>from</code>, da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);
#}</code></pre></pre>
<p>O <code>::</code> √© um operador que nos permite indicar que o <em>namespace</em> desta fun√ß√£o
<code>from</code>, em particular, √© o tipo <code>String</code>, de forma que n√£o precisamos usar um
nome espec√≠fico como <code>string_from</code>. Vamos discutir esta sintaxe na se√ß√£o
&quot;Sintaxe do M√©todo&quot; do Cap√≠tulo 5, e quando falarmos sobre <em>namespaces</em> com
m√≥dulos no Cap√≠tulo 7.</p>
<p>Este tipo de string <em>pode</em> ser alterada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;ol√°&quot;);

s.push_str(&quot;, mundo!&quot;); // push_str() adiciona um literal √† String

println!(&quot;{}&quot;, s); // Isso vai exibir `ol√°, mundo!`
#}</code></pre></pre>
<p>Mas ent√£o, qual √© a diferen√ßa aqui? Por que <code>String</code> pode ser alterada enquanto
literais n√£o podem? A diferen√ßa est√° em como esses dois tipos lidam com mem√≥ria.</p>
<a class="header" href="print.html#mem√≥ria-e-aloca√ß√£o" id="mem√≥ria-e-aloca√ß√£o"><h3>Mem√≥ria e Aloca√ß√£o</h3></a>
<p>No caso de uma string literal, sabemos o seu conte√∫do em tempo de compila√ß√£o,
ent√£o o texto √© injetado diretamente para dentro do execut√°vel final, o que
faz strings literais serem r√°pidas e eficientes. Mas essas propriedades prov√™m
apenas da sua imutabilidade. Infelizmente, n√£o podemos colocar um segmento de
mem√≥ria dentro do bin√°rio para cada texto cujo tamanho √© desconhecido em tempo
de compila√ß√£o, e cujo tamanho pode mudar ao longo da execu√ß√£o do programa.</p>
<p>Com o tipo <code>String</code>, para poder acomodar um trecho mut√°vel e expans√≠vel de
texto, precisamos alocar uma quantidade de mem√≥ria na heap, que √© desconhecida
em tempo de compila√ß√£o, para manter o seu conte√∫do. Isto significa que:</p>
<ol>
<li>A mem√≥ria deve ser solicitada ao sistema operacional em tempo de execu√ß√£o.</li>
<li>Precisamos de uma forma de retornar esta mem√≥ria ao sistema operacional
quando tivermos finalizado nossa <code>String</code>.</li>
</ol>
<p>A primeira parte √© feita por n√≥s: quando chamamos <code>String::from</code>, sua
implementa√ß√£o solicita a mem√≥ria de que precisa. Isso √© meio que universal em
linguagens de programa√ß√£o.</p>
<p>No entanto, a segunda parte √© diferente. Em linguagnes com um <em>garbage collector
(GC)</em>, o GC rastreia e limpa a mem√≥ria que n√£o est√° mais sendo usada, e n√≥s,
como programadores, n√£o precisamos pensar sobre isso. Sem um GC, √©
resposabilidade do programador identificar quando a mem√≥ria n√£o est√° mais sendo
usada e chamar, explicitamente, um c√≥digo que a retorne, assim como fizemos para
solicit√°-la. Fazer isso corretamente tem sido, historicamente, um problema
dif√≠cil de programa√ß√£o. Se esquecermos, vamos desperdi√ßar mem√≥ria. Se fizermos
cedo demais, teremos uma vari√°vel inv√°lida. Se fizermos duas vezes, tamb√©m ser√°
um bug. Precisamos casar exatamente um <code>allocate</code> (alocar) com exatamente um
<code>free</code> (liberar).</p>
<p>Rust segue um caminho diferente: a mem√≥ria √© automaticamente retornada assim que
a vari√°vel que a possui sai de escopo. Aqui est√° uma vers√£o do nosso exemplo de
escopo da Listagem 4-1 usando uma <code>String</code> em vez de uma string literal:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;texto&quot;); // s √© v√°lida deste ponto em diante

    // faz alguma coisa com s
}                                  // agora este escopo terminou, e s n√£o √©
                                   // mais v√°lida
#}</code></pre></pre>
<p>Existe um ponto natural em que podemos retornar ao sistema operacional a mem√≥ria
da qual precisa nossa <code>String</code>: quando <code>s</code> sai de escopo. Quando uma vari√°vel
sai de escopo, o Rust chama para n√≥s uma fun√ß√£o especial. Essa fun√ß√£o √© chamada
<code>drop</code>, e √© a√≠ que o autor de <code>String</code> pode colocar o c√≥digo que retorna
a mem√≥ria. Rust chama <code>drop</code> automaticamente ao fechar chaves (<code>}</code>).</p>
<blockquote>
<p>Nota: Em C++, esta forma de desalocar recursos no fim do tempo de vida √∫til de
um item √†s vezes √© chamado de <em>Resource Acquisition Is Initialization</em> (RAII,
do ingl√™s, Aquisi√ß√£o de Recurso √â Inicializa√ß√£o). A fun√ß√£o <code>drop</code> em Rust vai
lhe ser bastante familar se voc√™ j√° tiver usado padr√µes RAII.</p>
</blockquote>
<p>Este padr√£o tem um profundo impacto na forma de escrever c√≥digo em Rust. Pode
parecer simples agora, mas o comportamento do c√≥digo pode ser inesperado em
situa√ß√µes mais complicadas, quando queremos que m√∫ltiplas vari√°veis usem os
dados que alocamos na heap. Vamos explorar algumas dessas situa√ß√µes agora.</p>
<a class="header" href="print.html#formas-de-intera√ß√£o-entre-vari√°veis-e-dados-move" id="formas-de-intera√ß√£o-entre-vari√°veis-e-dados-move"><h4>Formas de Intera√ß√£o Entre Vari√°veis e Dados: <em>Move</em></h4></a>
<p>M√∫ltiplas vari√°veis podem interagir com os mesmos dados de diferentes formas em
Rust. Vamos ver um exemplo usando um n√∫mero inteiro na Listagem 4-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">Listagem 4-2: Atribuindo o valor inteiro da vari√°vel <code>x</code>
para <code>y</code>.</span></p>
<p>Provavelmente podemos advinhar o que isto faz com base nas nossas experi√™ncias
com outras linguagens: &quot;Associe o valor <code>5</code> a <code>x</code>; depois fa√ßa uma c√≥pia do
valor em <code>x</code> e a associe a <code>y</code>.&quot; Agora temos duas vari√°veis, <code>x</code> e <code>y</code>, e ambas
s√£o iguais a <code>5</code>. √â isto mesmo que acontece, porque n√∫meros inteiros s√£o valores
simples que possuem um tamanho fixo e conhecido, e esses dois valores <code>5</code> s√£o
colocados na pilha.</p>
<p>Agora vamos ver a vers√£o usando <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;texto&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>Isso parece bem similar ao c√≥digo anterior, ent√£o poder√≠amos assumir que
funcionaria da mesma forma, isto √©, a segunda linha faria uma c√≥pia do valor em
<code>s1</code> e a associaria a <code>s2</code>. Mas n√£o √© exatamente isso que acontece.</p>
<p>Para explicar isso mais detalhadamente, vamos ver como a <code>String</code> funciona por
baixo dos panos na Figura 4-1. Uma <code>String</code> √© feita de tr√™s partes, mostradas
√† esquerda: um ponteiro para a mem√≥ria que guarda o conte√∫do da string, um
tamanho, e uma capacidade. Este grupo de dados √© armazenado na pilha. No lado
direito est√° a mem√≥ria na heap que guarda o conte√∫do.</p>
<p><img alt="String na mem√≥ria" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-1: Representa√ß√£o na mem√≥ria de uma <code>String</code>
contendo o valor <code>&quot;texto&quot;</code> associado a <code>s1</code>.</span></p>
<p>O tamanho representa quanta mem√≥ria, em bytes, o conte√∫do da <code>String</code> est√°
usando atualmente. A capacidade √© a quantidade total de mem√≥ria, em bytes, que
a <code>String</code> recebeu do sistema operacional. A diferen√ßa entre tamanho e
capacidade √© importante, mas n√£o neste contexto, ent√£o n√£o h√° problema em
ignorar a capacidade por enquanto.</p>
<p>Quando atribu√≠mos <code>s1</code> a <code>s2</code>, os dados da <code>String</code> s√£o copiados, o que
significa que estamos copiando o ponteiro, o tamanho e a capacidade que est√£o na
pilha. N√£o estamos copiando os dados que est√£o na heap, aos quais o ponteiro se
refere. Em outras palavras, a representa√ß√£o dos dados na mem√≥ria ocorre como
na Figura 4-2.</p>
<p><img alt="s1 e s2 apontando para o mesmo valor" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-2: Representa√ß√£o na mem√≥ria da vari√°vel <code>s2</code>, que
tem uma c√≥pia do ponteiro, tamanho e capacidade de <code>s1</code>.</span></p>
<p>A representa√ß√£o <em>n√£o</em> ocorre como na Figura 4-3, que √© como ficaria a mem√≥ria se
o Rust tamb√©m copiasse os dados da heap. Se o Rust fizesse isso, a opera√ß√£o
<code>s2 = s1</code> seria potencialmente bastante custosa em termos de desempenho em tempo
de execu√ß√£o caso os dados na heap fossem grandes.</p>
<p><img alt="s1 e s2 em dois lugares" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-3: Outra possibilidade do que <code>s2 = s1</code> poderia
fazer se o Rust tamb√©m copiasse os dados da heap.</span></p>
<p>Anteriormente, dissemos que, quando uma vari√°vel sai de escopo, o Rust
automaticamente chama a fun√ß√£o <code>drop</code> e limpa a mem√≥ria da heap para esta
vari√°vel. Mas a Figura 4-2 mostra que os dois ponteiros est√£o apontando para o
mesmo lugar. Isso √© um problema: quando <code>s2</code> e <code>s1</code> saem de escopo, os dois v√£o
tentar liberar a mesma mem√≥ria. Isso √© conhecido como erro de <em>double free</em>
(libera√ß√£o dupla), e √© um dos bugs de seguran√ßa de mem√≥ria que mencionamos
anteriormente. Liberar mem√≥ria duas vezes pode levar √† corrup√ß√£o da mem√≥ria,
o que pode, por sua vez, trazer potenciais vulnerabilidades de seguran√ßa.</p>
<p>Para garantir a seguran√ßa de mem√≥ria, h√° um outro detalhe sobre o que acontece
nesta situa√ß√£o em Rust. Em vez de tentar copiar a mem√≥ria alocada, o Rust
considera que <code>s1</code> deixa de ser v√°lida, e portanto, o Rust n√£o precisa liberar
nenhuma mem√≥ria quando <code>s1</code> sai de escopo. Veja s√≥ o que acontece quando voc√™
tenta usar <code>s1</code> depois que <code>s2</code> √© criada, n√£o vai funcionar:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;texto&quot;);
let s2 = s1;

println!(&quot;{}&quot;, s1);
</code></pre>
<p>Voc√™ vai ter um erro como este, porque o Rust lhe impede de usar a refer√™ncia
que foi invalidada:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:20
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}&quot;, s1);
  |                    ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>Se voc√™ j√° ouviu os termos &quot;c√≥pia rasa&quot; e &quot;c√≥pia profunda&quot; (<em>shallow copy</em> e
<em>deep copy</em>) enquanto trabalhava com outras linguagens, o conceito de copiar o
ponteiro, tamanho e capacidade sem copiar os dados provavelmente parece uma
c√≥pia rasa. Mas como o Rust tamb√©m invalida a primeira vari√°vel, em vez de
chamar isto de c√≥pia rasa, isto √© conhecido como um <em>move</em>. Aqui poder√≠amos
dizer que <code>s1</code> foi <em>movida</em> para <code>s2</code>. Ent√£o, o que realmente acontece √©
mostrado na Figura 4-4.</p>
<p><img alt="s1 movida para s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-4: Representa√ß√£o na mem√≥ria depois de <code>s1</code> ter
sido invalidada.</span></p>
<p>Isso resolve o nosso problema! Tendo apenas <code>s2</code> v√°lida, quando ela sair de
escopo, somente ela vai liberar a mem√≥ria, e pronto.</p>
<p>Ademais, isto implica uma decis√£o de projeto: Rust nunca vai criar <em>deep copies</em>
dos seus dados. Logo, para qualquer c√≥pia <em>autom√°tica</em> que aconte√ßa, pode-se
assumir que ela n√£o ser√° custosa em termos de desempenho em tempo de execu√ß√£o.</p>
<a class="header" href="print.html#formas-de-intera√ß√£o-entre-vari√°veis-e-dados-clone" id="formas-de-intera√ß√£o-entre-vari√°veis-e-dados-clone"><h4>Formas de Intera√ß√£o Entre Vari√°veis e Dados: Clone</h4></a>
<p>Se n√≥s <em>queremos</em> fazer uma c√≥pia profunda dos dados da <code>String</code> que est√£o na
heap, e n√£o apenas os dados que est√£o na pilha, podemos usar um m√©todo comum
chamado <code>clone</code>. Vamos discutir sintaxe de m√©todos no Cap√≠tulo 5, mas como os
m√©todos constituem uma caracter√≠stica comum em v√°rias linguagens de programa√ß√£o,
voc√™ provavelmente j√° os viu antes.</p>
<p>Aqui est√° um exemplo de uso do m√©todo <code>clone</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;texto&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>Isto funciona bem, e √© assim que voc√™ pode, explicitamente, produzir o
comportamento mostrado na Figura 4-3, onde os dados da heap <em>s√£o</em> copiados.</p>
<p>Quando voc√™ ver uma chamada para <code>clone</code>, voc√™ sabe que algum c√≥digo arbitr√°rio
est√° sendo executado, e que este c√≥digo talvez seja custoso. √â um indicador
visual de que algo diferente est√° acontecendo.</p>
<a class="header" href="print.html#dados-somente-da-pilha-copy" id="dados-somente-da-pilha-copy"><h4>Dados Somente da Pilha: Copy</h4></a>
<p>H√° um outro detalhezinho de que ainda n√£o falamos. Este c√≥digo usando n√∫meros
inteiros, parte do qual foi mostrado anteriormente na Listagem 4-2, funciona e √©
v√°lido:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Mas este c√≥digo parece contradizer o que acabamos de aprender: n√£o temos uma
chamada ao m√©todo <code>clone</code>, mas <code>x</code> ainda √© v√°lido e n√£o foi movido para <code>y</code>.</p>
<p>O motivo √© que tipos como n√∫meros inteiros t√™m um tamanho conhecido em tempo de
compila√ß√£o e s√£o armazenados inteiramente na pilha, e por isso, c√≥pias desses
valores s√£o r√°pidas de se fazer. Isso significa que n√£o h√° raz√£o para impedir
<code>x</code> de ser v√°lido ap√≥s criarmos a vari√°vel <code>y</code>. Em outras palavras, n√£o h√°
diferen√ßa entre c√≥pia rasa e profunda aqui, ent√£o chamar o m√©todo <code>clone</code> n√£o
faria nada diferente de uma c√≥pia rasa, por isso podemos deix√°-lo de lado.</p>
<p>O Rust tem uma anota√ß√£o especial chamada de <em>trait</em> <code>Copy</code>, que podemos colocar
em tipos como n√∫meros inteiros, que s√£o armazenados na pilha (falaremos mais
sobre traits no Cap√≠tulo 10). Se um tipo possui o trait <code>Copy</code>, uma vari√°vel
anterior vai continuar sendo utiliz√°vel depois de uma atribui√ß√£o. O Rust n√£o vai
nos deixar anotar um tipo com o trait <code>Copy</code> se este tipo, ou qualquer uma de
suas partes, tiver implementado o trait <code>Drop</code>. Se o tipo precisa que algo
especial aconte√ßa quando o valor sair de escopo e h√° uma anota√ß√£o <code>Copy</code> neste
tipo, vamos ter um erro de compila√ß√£o. Para aprender sobre como inserir a
anota√ß√£o <code>Copy</code> ao seu tipo, veja o Ap√™ndice C em Traits Deriv√°veis.</p>
<p>Ent√£o quais tipos s√£o <code>Copy</code>? Voc√™ pode verificar a documenta√ß√£o de um
determinado tipo para se certificar, mas como regra geral, qualquer grupo de
valores simples escalares podem ser <code>Copy</code>, e nada que precise de aloca√ß√£o ou
que seja uma forma de recurso √© <code>Copy</code>. Aqui est√£o alguns tipos que s√£o <code>Copy</code>:</p>
<ul>
<li>Todos os tipos inteiros, como <code>u32</code>.</li>
<li>O tipo booleano, <code>bool</code>, com valores <code>true</code> e <code>false</code>.</li>
<li>O tipo caractere, <code>char</code>.</li>
<li>Todos os tipos de ponto flutuante, como <code>f64</code>.</li>
<li>Tuplas, mas apenas aquelas que cont√©m tipos que tamb√©m s√£o <code>Copy</code>.
<code>(i32, i32)</code> √© <code>Copy</code>, mas <code>(i32, String)</code> n√£o.</li>
</ul>
<a class="header" href="print.html#ownership-e-fun√ß√µes" id="ownership-e-fun√ß√µes"><h3>Ownership e Fun√ß√µes</h3></a>
<p>A sem√¢ntica para passar um valor a uma fun√ß√£o √© similar √† de atribuir um valor
a uma vari√°vel. Passar uma vari√°vel a uma fun√ß√£o ir√° mover ou copiar, assim como
acontece em uma atribui√ß√£o. A Listagem 4-3 tem um exemplo com algumas anota√ß√µes
mostrando onde as vari√°veis entram e saem de escopo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;texto&quot;);  // s entra em escopo.

    toma_posse(s);                  // move o valor de s para dentro da fun√ß√£o...
                                    // ... e ele n√£o √© mais v√°lido aqui.

    let x = 5;                      // x entra em escopo.

    faz_uma_copia(x);               // x seria movido para dentro da fun√ß√£o,
                                    // mas i32 √© Copy, ent√£o est√° tudo bem em
                                    // usar x daqui para a frente.

} // Aqui, x sai de escopo, e depois s. Mas como o valor de s foi movido, nada
  // de especial acontece.

fn toma_posse(uma_string: String) { // uma_string entra em escopo.
    println!(&quot;{}&quot;, uma_string);
} // Aqui, uma_string sai de escopo, e o m√©todo `drop` √© chamado. A mem√≥ria que
  // guarda seus dados √© liberada.

fn faz_uma_copia(um_inteiro: i32) { // um_inteiro entra em escopo.
    println!(&quot;{}&quot;, um_inteiro);
} // Aqui, um_inteiro sai de escopo. Nada de especial acontece.
</code></pre></pre>
<p><span class="caption">Listagem 4-3: Fun√ß√µes com anota√ß√µes de ownership e
escopo</span></p>
<p>Se tent√°ssemos usar <code>s</code> ap√≥s a chamada para <code>toma_posse</code>, o Rust iria lan√ßar um
erro de compila√ß√£o. Essas verifica√ß√µes est√°ticas nos protegem de certo enganos.
Tente adicionar um c√≥digo √† fun√ß√£o <code>main</code> que usa <code>s</code> e <code>x</code> para ver onde voc√™
pode us√°-los e onde as regras de ownership lhe impedem de faz√™-lo.</p>
<a class="header" href="print.html#retorno-de-valores-e-escopo" id="retorno-de-valores-e-escopo"><h3>Retorno de Valores e Escopo</h3></a>
<p>Retornar valores tamb√©m pode transferir a posse de um valor. Aqui est√° um
exemplo com anota√ß√µes similares √†quelas da Listagem 4-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = entrega_valor();           // entrega_valor move o valor retornado
                                        // para s1.

    let s2 = String::from(&quot;texto&quot;);     // s2 entra em escopo.

    let s3 = pega_e_entrega_valor(s2);  // s2 √© movido para dentro da fun√ß√£o
                                        // pega_e_entrega_valor, que tamb√©m
                                        // move o valor retornado para s3.
} // Aqui, s3 sai de escopo e √© destru√≠da. s2 sai de escopo, mas j√° foi movida,
  // ent√£o nada demais acontece. s1 sai de escopo e √© destru√≠da.

fn entrega_valor() -&gt; String {               // entrega_valor move o valor
                                             // retornado para dentro da fun√ß√£o
                                             // que a chamou.

    let uma_string = String::from(&quot;ol√°&quot;);    // uma_string entra em escopo.

    uma_string                               // uma_string √© retornada e movida
                                             // para a fun√ß√£o que chamou
                                             // entrega_valor.
}

// pega_e_entrega_valor vai pegar uma String e retorn√°-la.
fn pega_e_entrega_valor(uma_string: String) -&gt; String { // uma_string entra em
                                                        // escopo.

    uma_string  // uma_string √© retornada e movida para a fun√ß√£o que chamou
                // pega_e_entrega_valor.
}
</code></pre></pre>
<p>A posse de uma vari√°vel segue o mesmo padr√£o toda vez: atribuir um valor a outra
vari√°vel ir√° mov√™-lo. Quando uma vari√°vel que inclui dados na heap sai de
escopo, o valor ser√° destru√≠do pelo m√©todo <code>drop</code>, a n√£o ser que os dados tenham
sido movidos para outra vari√°vel.</p>
<p>Obter e retornar a posse de um valor em cada fun√ß√£o √© um pouco tedioso. O que
fazer se queremos deixar uma fun√ß√£o usar um valor sem tomar posse dele? √â meio
irritante saber que qualquer coisa que passemos a uma fun√ß√£o tamb√©m precisa ser
passado de volta se quisermos us√°-lo novamente, al√©m de algum poss√≠vel resultado
proveniente do corpo da fun√ß√£o que tamb√©m queremos retornar.</p>
<p>√â poss√≠vel retornar m√∫ltiplos valores usando uma tupla, da seguinte forma:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;texto&quot;);

    let (s2, tamanho) = calcula_tamanho(s1);

    println!(&quot;O tamanho de '{}' √© {}.&quot;, s2, tamanho);
}

fn calcula_tamanho(s: String) -&gt; (String, usize) {
    let tamanho = s.len(); // len() retorna o tamanho de uma String.

    (s, tamanho)
}
</code></pre></pre>
<p>Mas isto √© muita cerim√¥nia e trabalho para um conceito que deveria ser comum.
Para nossa sorte, Rust tem uma ferramenta para este conceito, e ela √© chamada de
<em>refer√™ncias</em>.</p>
<a class="header" href="print.html#refer√™ncias-e-borrowing" id="refer√™ncias-e-borrowing"><h2>Refer√™ncias e <em>Borrowing</em></h2></a>
<p>O problema de usar tuplas, que vimos no fim da se√ß√£o anterior, √© que precisamos
retornar a <code>String</code>, de forma que ainda possamos us√°-la ap√≥s a chamada √† fun√ß√£o
<code>calcula_tamanho</code>, para dentro da qual a <code>String</code> foi movida.</p>
<p>Aqui est√° uma forma de como voc√™ poderia definir e usar uma fun√ß√£o
<code>calcula_tamanho</code> que recebe uma <em>refer√™ncia</em> para um objeto como par√¢metro, em
vez de pegar este valor para si:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;texto&quot;);

    let tamanho = calcula_tamanho(&amp;s1);

    println!(&quot;O tamanho de '{}' √© {}.&quot;, s1, tamanho);
}

fn calcula_tamanho(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>Primeiro, repare que todo aquele c√≥digo usando uma tupla na declara√ß√£o da
vari√°vel e no retorno da fun√ß√£o j√° se foi. Segundo, note que passamos <code>&amp;s1</code> para
<code>calcula_tamanho</code>, e na sua defini√ß√£o, temos <code>&amp;String</code> em vez de apenas
<code>String</code>.</p>
<p>Esses <code>&amp;</code> s√£o <em>refer√™ncias</em>, e eles permitem que voc√™ se refira a algum valor
sem tomar posse dele. A Figura 4-5 mostra um diagrama.</p>
<p><img alt="&String s apontando para String s1" src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">Figura 4-5: <code>&amp;String s</code> apontando para <code>String s1</code></span></p>
<blockquote>
<p>Nota: O oposto de referenciar usando <code>&amp;</code> √© <em>derreferenciar</em>, feito por meio do
operador derreferenciador, <code>*</code>. Veremos alguns usos do operador
derreferenciador no Cap√≠tulo 8 e vamos discutir detalhes da derreferencia√ß√£o
no Cap√≠tulo 15.</p>
</blockquote>
<p>Vamos olhar mais de perto esta chamada de fun√ß√£o:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calcula_tamanho(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;texto&quot;);

let tamanho = calcula_tamanho(&amp;s1);
#}</code></pre></pre>
<p>A sintaxe <code>&amp;s1</code> nos permite criar uma refer√™ncia que <em>se refere</em> ao valor <code>s1</code>,
mas n√£o o possui. Como ela n√£o o possui, o valor a que ela aponta n√£o ser√°
destru√≠do quando a refer√™ncia sair de escopo.</p>
<p>Da mesma forma, a assinatura da fun√ß√£o usa <code>&amp;</code> para indicar que o tipo do
par√¢metro <code>s</code> √© uma refer√™ncia. Vamos adicionar algumas anota√ß√µes para explicar:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calcula_tamanho(s: &amp;String) -&gt; usize { // s √© uma refer√™ncia para uma String
    s.len()
} // Aqui, s sai de escopo. Mas como ela n√£o possui o valor a que se refere,
  // nada acontece.
#}</code></pre></pre>
<p>O escopo no qual a vari√°vel <code>s</code> √© v√°lida √© o mesmo escopo de qualquer par√¢metro
de fun√ß√£o, mas n√£o destru√≠mos o valor apontado pela refer√™ncia quando ela sai de
escopo, pois ela n√£o tem posse dele. Fun√ß√µes que t√™m refer√™ncias como
par√¢metros, em vez dos pr√≥prios valores, n√£o precisam retornar os valores para
devolver a posse deles, j√° que nunca tiveram esta posse.</p>
<p>Colocar refer√™ncias como par√¢metros de fun√ß√µes √© chamado de <em>borrowing</em> (do
ingl√™s, empr√©stimo). Assim como na vida real, se uma pessoa possui alguma coisa,
voc√™ pode pegar emprestado dela. Quando voc√™ termina de usar, voc√™ deve
devolver.</p>
<p>E o que acontece se tentarmos modificar alguma coisa que pegamos emprestado?
Tente rodar o c√≥digo da Listagem 4-4. Alerta de spoiler: n√£o funciona!</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;texto&quot;);

    modifica(&amp;s);
}

fn modifica(uma_string: &amp;String) {
    uma_string.push_str(&quot; longo&quot;);
}
</code></pre>
<p><span class="caption">Listagem 4-4: Tentativa de modificar um valor emprestado</span></p>
<p>Aqui est√° o erro:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*uma_string` as mutable
 --&gt; main.rs:8:5
  |
7 | fn modifica(uma_string: &amp;String) {
  |                         ------- use `&amp;mut String` here to make mutable
8 |     uma_string.push_str(&quot; longo&quot;);
  |     ^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>Assim como as vari√°veis s√£o imut√°veis por padr√£o, refer√™ncias tamb√©m s√£o. N√£o
temos permiss√£o para modificar algo para o qual temos uma refer√™ncia.</p>
<a class="header" href="print.html#refer√™ncias-mut√°veis" id="refer√™ncias-mut√°veis"><h3>Refer√™ncias Mut√°veis</h3></a>
<p>Podemos corrigir o erro no c√≥digo da Listagem 4-4 com um pequeno ajuste:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;texto&quot;);

    modifica(&amp;mut s);
}

fn modifica(uma_string: &amp;mut String) {
    uma_string.push_str(&quot; longo&quot;);
}
</code></pre></pre>
<p>Primeiro, temos que fazer com que <code>s</code> seja <code>mut</code>. Depois, temos que criar uma
refer√™ncia mut√°vel com <code>&amp;mut s</code> e aceitar uma refer√™ncia mut√°vel com
<code>uma_string: &amp;mut String</code>.</p>
<p>Mas refer√™ncias mut√°veis possuem uma grande restri√ß√£o: voc√™ s√≥ pode ter uma
refer√™ncia mut√°vel para um determinado dado em um determinado escopo. Este
c√≥digo vai falhar:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;texto&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<p>Aqui est√° o erro:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; main.rs:5:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
6 | }
  | - first borrow ends here
</code></pre>
<p>Esta restri√ß√£o permite a muta√ß√£o, mas de uma forma bem controlada. Isto √© algo
com que novos Rust√°ceos passam trabalho, porque a maioria das linguagens de
programa√ß√£o permitem modificar um valor quando voc√™ quiser. O benef√≠cio de ter
esta restri√ß√£o √© que o Rust previne <em>data races</em> em tempo de compila√ß√£o.</p>
<p>Um <em>data race</em> √© parecido com uma condi√ß√£o de corrida, e acontece quando esses
tr√™s fatores ocorrem:</p>
<ol>
<li>Dois ou mais ponteiros acessam o mesmo dado ao mesmo tempo.</li>
<li>Ao menos um dos ponteiros √© usado para escrever sobre o dado.</li>
<li>N√£o h√° nenhum mecanismo sendo usado para sincronizar o acesso ao dado.</li>
</ol>
<p>Data races causam comportamento indefinido e pode ser dif√≠ceis de diagnosticar
e corrigir quando voc√™ est√° tentando rastre√°-los em tempo de execu√ß√£o. Rust
previne este problema de acontecer porque n√£o vai nem deixar compilar um c√≥digo
com data races!</p>
<p>Como sempre, podemos usar chaves (<code>{}</code>) para criar um novo escopo, permitindo
m√∫ltiplas refer√™ncias mut√°veis, mas n√£o <em>simult√¢neas</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;texto&quot;);

{
    let r1 = &amp;mut s;

} // aqui r1 sai de escopo, ent√£o j√° podemos criar uma nova refer√™ncia sem
  // problema nenhum.

let r2 = &amp;mut s;
#}</code></pre></pre>
<p>Existe uma regra parecida para combinar refer√™ncias mut√°veis e imut√°veis. Este
c√≥digo resulta em erro:</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;texto&quot;);

let r1 = &amp;s; // sem problema
let r2 = &amp;s; // sem problema
let r3 = &amp;mut s; // PROBLEMA GRANDE
</code></pre>
<p>Aqui est√° o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
 --&gt; main.rs:6:19
  |
4 |     let r1 = &amp;s; // sem problema
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // sem problema
6 |     let r3 = &amp;mut s; // PROBLEMA GRANDE
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Eita! N√≥s <em>tamb√©m</em> n√£o podemos ter uma refer√™ncia mut√°vel enquanto temos uma
imut√°vel. Usu√°rios de uma refer√™ncia imut√°vel n√£o esperam que os valores mudem
de repente! Por√©m, m√∫ltiplas refer√™ncias imut√°veis s√£o permitidas, pois ningu√©m
que esteja apenas lendo os dados ser√° capaz de afetar a leitura que est√° sendo
feita em outra parte do c√≥digo.</p>
<p>Mesmo que esses erros sejam frustrantes √†s vezes, lembre-se que √© o compilador
do Rust apontando um bug potencial antecipadamente (em tempo de compila√ß√£o,
em vez de execu√ßao), e mostrando exatamente onde est√° o problema, em vez de voc√™
ter que investigar por que algumas vezes os seus dados n√£o s√£o aquilo que voc√™
esperava que fosse.</p>
<a class="header" href="print.html#refer√™ncias-soltas" id="refer√™ncias-soltas"><h3>Refer√™ncias Soltas</h3></a>
<p>Em linguagens com ponteiros, √© f√°cil criar erroneamente um <em>ponteiro solto</em>, um
ponteiro que referencia um local na mem√≥ria que pode ter sido dado para outra
parte do programa, basta liberar alguma mem√≥ria e preservar um ponteiro para
ela. Por outro lado, em Rust, o compilador garante que nenhuma refer√™ncia ser√°
uma refer√™ncia solta: se temos uma refer√™ncia para algum dado, o compilador vai
se certificar que esse dado n√£o vai sair de escopo antes da refer√™ncia.</p>
<p>Vamos tentar criar uma refer√™ncia solta, que o Rust vai impedir com um erro em
tempo de compila√ß√£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let referencia_para_o_nada = soltar();
}

fn soltar() -&gt; &amp;String {
    let s = String::from(&quot;texto&quot;);

    &amp;s
}
</code></pre>
<p>Aqui est√° o erro:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; main.rs:5:16
  |
5 | fn soltar() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p>Esta mensagem de erro se refere a uma caracter√≠stica que n√£o abordamos ainda:
<em>lifetimes</em>. Vamos discutir lifetimes em detalhe no Cap√≠tulo 10. Mas, se voc√™
desconsiderar a parte sobre lifetimes, a mensagem mostra a raz√£o deste c√≥digo
ser um problema:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<blockquote>
<p>Tradu√ß√£o: o tipo de retorno desta fun√ß√£o cont√©m um valor emprestado, mas n√£o
h√° nenhum valor que se possa pegar emprestado.</p>
</blockquote>
<p>Vamos dar uma olhada mais de perto no que est√° acontecendo, exatamente, em cada
est√°gio da nossa fun√ß√£o <code>soltar</code>:</p>
<pre><code class="language-rust ignore">fn soltar() -&gt; &amp;String { // soltar retorna uma refer√™ncia a uma String

    let s = String::from(&quot;texto&quot;); // s √© uma nova String

    &amp;s // retornamos uma refer√™ncia a uma String, s
} // Aqui, s sai de escopo e √© destru√≠da. Sua mem√≥ria √© devolvida.
  // Perigo!
</code></pre>
<p>Como <code>s</code> √© criada dentro da fun√ß√£o <code>soltar</code>, quando o c√≥digo desta fun√ß√£o
termina, <code>s</code> √© desalocada. Mas n√≥s tentamos retornar uma refer√™ncia para ela.
Isto significa que esta refer√™ncia apontaria para uma <code>String</code> inv√°lida! Isso
n√£o √© bom. Rust n√£o vai nos deixar fazer isso.</p>
<p>A solu√ß√£o aqui √© retornar a <code>String</code> diretamente:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn n√£o_soltar() -&gt; String {
    let s = String::from(&quot;texto&quot;);

    s
}
#}</code></pre></pre>
<p>Isto funciona sem nenhum problema. A <code>String</code> √© movida para fora, e nada √©
desalocado.</p>
<a class="header" href="print.html#as-regras-de-refer√™ncias" id="as-regras-de-refer√™ncias"><h3>As Regras de Refer√™ncias</h3></a>
<p>Vamos recapitular o que discutimos sobre refer√™ncias:</p>
<ol>
<li>Em um dado momento, voc√™ pode ter <em>um ou outro</em>, mas n√£o os dois:</li>
</ol>
<ul>
<li>Uma refer√™ncia mut√°vel.</li>
<li>Qualquer n√∫mero de refer√™ncias imut√°veis.</li>
</ul>
<ol start="2">
<li>Refer√™ncias devem ser v√°lidas sempre.</li>
</ol>
<p>Em seguida, vamos ver um tipo diferente de refer√™ncias: <em>slices</em>.</p>
<a class="header" href="print.html#slices" id="slices"><h2><em>Slices</em></h2></a>
<p>Outro tipo de dados em que n√£o h√° ownership √© a <em>slice</em> (do ingl√™s, fatia).
Slices lhe permitem referenciar uma sequ√™ncia cont√≠gua de elementos em uma
cole√ß√£o em vez de referenciar a cole√ß√£o inteira.</p>
<p>Aqui est√° um pequeno problema de programa√ß√£o: escrever uma fun√ß√£o que pega uma
string e retorna a primeira palavra que encontrar dentro dela. Se a fun√ß√£o n√£o
encontrar um espa√ßo na string, significa que a string inteira √© uma palavra s√≥,
ent√£o a string toda deve ser retornada.</p>
<p>Vamos pensar sobre a assinatura desta fun√ß√£o:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; ?
</code></pre>
<p>Esta fun√ß√£o, <code>primeira_palavra</code>, tem uma <code>&amp;String</code> como par√¢metro. N√≥s n√£o
queremos tomar posse dela, ent√£o tudo bem. Mas o que n√≥s dever√≠amos retornar?
N√£o temos uma forma de falar sobre <em>parte</em> de uma string. No entanto, poder√≠amos
retornar o √≠ndice do final de uma palavra. Vamos tentar fazer isso, conforme
mostrado na Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<p><span class="caption">Listagem 4-5: A fun√ß√£o <code>primeira_palavra</code>, que retorna um
√≠ndice para um byte da <code>String</code> passada como par√¢metro.</span></p>
<p>Vamos dividir este c√≥digo em algumas partes. Como precisamos varrer a <code>String</code>
elemento por elemento, e verificar se algum valor √© um espa√ßo, vamos converter
nossa <code>String</code> em um array de bytes usando o m√©todo <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Depois, criamos um iterador sobre o array de bytes usando o m√©todo <code>iter</code>:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Vamos discutir sobre iteradores em mais detalhes no Cap√≠tulo 13. Por enquanto,
saiba que <code>iter</code> √© um m√©todo que retorna cada elemento em uma cole√ß√£o, e
<code>enumerate</code> encapsula o resultado do <code>iter</code> e retorna cada elemento como parte
de uma tupla. O primeiro elemento da tupla √© o √≠ndice, e o segundo elemento √©
uma refer√™ncia ao valor. Isto √© um pouco mais conveniente do que calcular o
√≠ndice n√≥s mesmos.</p>
<p>Como o m√©todo <code>enumerate</code> retorna uma tupla, podemos usar padr√µes para
desestruturar esta tupla, assim como qualquer outra coisa em Rust. Ent√£o, no
<code>for</code>, especificamos um padr√£o que tem <code>i</code> para o √≠ndice na tupla e <code>&amp;item</code> para
o byte. Como pegamos uma refer√™ncia ao elemento atrav√©s do
<code>.iter().enumerate()</code>, usamos um <code>&amp;</code> neste padr√£o.</p>
<p>N√≥s procuramos o byte que representa um espa√ßo usando a sintaxe de byte literal.
Se encontrarmos um espa√ßo, retornamos a posi√ß√£o dele. Caso contr√°rio, retornamos
o tamanho da string usando <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>Agora temos uma forma de descobrir o √≠ndice do fim da primeira palavra na
string, mas tem um problema. Estamos retornando um <code>usize</code> por si s√≥, mas ele s√≥
possui um significado no contexto da <code>&amp;String</code>. Em outras palavras, como √© um
valor separado da <code>String</code>, n√£o h√° garantia de que ele ainda ser√° v√°lido no
futuro. Considere o programa na Listagem 4-6, que usa a fun√ß√£o da Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = primeira_palavra(&amp;s); // palavra vai ter o valor 5.

    s.clear(); // Isso esvazia a String, deixando ela igual a &quot;&quot;.

    // palavra ainda tem o valor 5 aqui, mas j√° n√£o h√° mais uma string para a
    // qual o valor 5 fa√ßa algum sentido. palavra agora √© totalmente inv√°lida!
}
</code></pre></pre>
<p><span class="caption">Listagem 4-6: Armazenando o resultado de uma chamada √†
fun√ß√£o <code>primeira_palavra</code>, e depois, mudando o conte√∫do da <code>String</code>.</span></p>
<p>Este programa compila sem erros, e tamb√©m o faria se us√°ssemos a vari√°vel
<code>palavra</code> depois de chamar <code>s.clear()</code>. <code>palavra</code> n√£o est√° conectada ao estado
de <code>s</code> de nenhuma forma, ent√£o, <code>palavra</code> ainda cont√©m o valor <code>5</code>. Poder√≠amos
usar esse valor <code>5</code> com a vari√°vel <code>s</code> para tentar extrair a primeira palavra da
string, mas isso seria um bug, pois o conte√∫do de <code>s</code> j√° mudou ap√≥s termos salvo
o valor <code>5</code> na vari√°vel <code>word</code>.</p>
<p>Ter que se preocupar sobre o √≠ndice da <code>palavra</code> ficar fora de sincronia com os
dados em <code>s</code> √© tedioso e propenso a erros! Gerenciar esses √≠ndices √© ainda mais
delicado se escrevermos uma fun√ß√£o <code>segunda_palavra</code>. Sua assinatura teria que
ser algo do tipo:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Agora estamos rastreando os √≠ndices do in√≠cio <em>e</em> do final, e temos ainda mais
valores que s√£o calculados a partir dos dados em um estado particular, mas que
n√£o est√£o vinculados a este estado de nenhuma forma. Agora temos tr√™s vari√°veis
n√£o relacionadas flutuando que precisam ser mantidas em sincronia.</p>
<p>Felizmente, Rust possui uma solu√ß√£o para este problema: slices de string.</p>
<a class="header" href="print.html#slices-de-string" id="slices-de-string"><h3>Slices de String</h3></a>
<p>Uma <em>slice de string</em> √© uma refer√™ncia para uma parte de uma <code>String</code>, e tem a
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto longo&quot;);

let texto = &amp;s[0..5];
let longo = &amp;s[6..11];
#}</code></pre></pre>
<p>Isto √© similar a pegar uma refer√™ncia √† <code>String</code> inteira, mas com um <code>[0..5]</code> a
mais. Em vez de uma refer√™ncia √† <code>String</code> inteira, trata-se de uma refer√™ncia a
uma por√ß√£o da <code>String</code>. A sintaxe <code>in√≠cio..fim</code> representa um <em>range</em>
(uma faixa) que come√ßa em <code>in√≠cio</code> e continua at√©, mas n√£o incluindo, <code>fim</code>.</p>
<p>Podemos criar slices usando um range entre colchetes especificando
<code>[√≠ndice_inicial..√≠ndice_final]</code>, em que <code>√≠ndice_inicial</code> √© a primeira posi√ß√£o
inclusa na slice, e <code>√≠ndice_final</code> √© um a mais que a √∫ltima posi√ß√£o inclusa na
slice. Internamente, a estrutura de dados de uma slice armazena a posi√ß√£o
inicial e o tamanho da slice, que corresponde a <code>√≠ndice_final</code> menos
<code>√≠ndice_inicial</code>. Ent√£o, no caso do <code>let longo = &amp;s[6..11];</code>, <code>longo</code> seria uma
slice que cont√©m um ponteiro para o s√©timo byte de <code>s</code> (√≠ndice 6) e um tamanho
igual a 5.</p>
<p>A Figura 4-6 mostra isto em um diagrama.</p>
<p><img alt="mundo contendo um ponteiro para o 7o byte da String s e um tamanho 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-6: Slice referente a uma parte de uma
<code>String</code></span></p>
<p>Com a sintaxe de range do Rust (<code>..</code>), se voc√™ quiser come√ßar com o primeiro
elemento (√≠ndice zero), voc√™ pode omitir o valor antes dos dois pontos. Em
outras palavras, estas formas s√£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>Da mesma forma, se a sua slice inclui o √∫ltimo byte da <code>String</code>, voc√™ pode
omitir o √∫ltimo n√∫mero. Isso significa que as seguintes formas s√£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[3..tamanho];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>Voc√™ tamb√©m pode omitir ambos os valores para pegar uma slice da string inteira.
Logo, essas duas formas s√£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[0..tamanho];
let slice = &amp;s[..];
#}</code></pre></pre>
<blockquote>
<p>Nota: Os √≠ndices do range de uma slice de string devem coincidir com os
limites entre caracteres UTF-8 v√°lidos. Se voc√™ tentar criar uma slice de
string no meio de um caractere que tenha mais de um byte, seu programa vai
terminar com erro. Para introduzir slices de string, estamos utilizando
apenas caracteres ASCII nesta se√ß√£o; uma discuss√£o mais detalhada sobre
manipula√ß√£o de caracteres UTF-8 ser√° feita na se√ß√£o &quot;Strings&quot; do Cap√≠tulo 8.</p>
</blockquote>
<p>Com toda essa informa√ß√£o em mente, vamos reescrever a fun√ß√£o <code>primeira_palavra</code>
para retornar uma slice. O tipo que representa &quot;slice de string&quot; √© escrito como
<code>&amp;str</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>Pegamos o √≠ndice para o fim da palavra da mesma forma como fizemos na Listagem
4-5, buscando a primeira ocorr√™ncia de um espa√ßo. Quando o encontramos,
retornamos uma slice de string usando o in√≠cio da string e o √≠ndice do espa√ßo
como √≠ndices inicial e final, respectivamente.</p>
<p>Agora, quando chamamos <code>primeira_palavra</code>, pegamos de volta um √∫nico valor que
est√° vinculado √† string. O valor √© composto de uma refer√™ncia para o ponto
inicial da slice e o n√∫mero de elementos que ela cont√©m.</p>
<p>Retornar uma slice tamb√©m funcionaria para uma fun√ß√£o <code>segunda_palavra</code>:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Agora, temos uma API bem direta que √© bem mais dif√≠cil de bagun√ßar, uma vez que
o compilador vai se certificar que as refer√™ncias dentro da <code>String</code>
permanecer√£o v√°lidas. Lembra do bug do programa na Listagem 4-6, quando
obtivemos o √≠ndice para o fim da primeira palavra mas depois limpamos a string,
invalidando o √≠ndice obtido? Aquele c√≥digo era logicamente incorreto, mas n√£o
mostrava nenhum erro imediato. Os problemas apareceriam mais tarde quando
tent√°ssemos usar o √≠ndice da primeira palavra com uma string que foi esvaziada.
Slices tornam esse bug imposs√≠vel de acontecer e nos permitem saber que temos um
problema no c√≥digo muito mais cedo. Na vers√£o usando slice, a fun√ß√£o
<code>primeira_palavra</code> vai lan√ßar um erro em tempo de compila√ß√£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = first_word(&amp;s);

    s.clear(); // Erro!
}
</code></pre>
<p>Aqui est√° o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let word = primeira_palavra(&amp;s);
  |                                  - immutable borrow occurs here
5 |
6 |     s.clear(); // Erro!
  |     ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Voltando √†s regras de borrowing, lembre-se que, se temos uma refer√™ncia imut√°vel
para algum valor, n√£o podemos tamb√©m obter uma refer√™ncia mut√°vel do mesmo. Como
<code>clear</code> precisa truncar a <code>String</code>, esse m√©todo tenta obter uma refer√™ncia
mut√°vel, e acaba falhando. O Rust n√£o s√≥ tornou nossa API mais f√°cil de usar,
como tamb√©m eliminou uma classe inteira de erros em tempo de compila√ß√£o!</p>
<a class="header" href="print.html#strings-literais-s√£o-slices" id="strings-literais-s√£o-slices"><h4>Strings Literais S√£o Slices</h4></a>
<p>Lembre-se de que falamos sobre strings literais serem armazenadas dentro do
bin√°rio. Agora que conhecemos slices, podemos entender strings literais
adequadamente:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Ol√°, mundo!&quot;;
#}</code></pre></pre>
<p>O tipo de <code>s</code> aqui √© <code>&amp;str</code>: √© uma slice apontando para aquele ponto espec√≠fico
do bin√°rio. Tamb√©m √© por isso que strings literais s√£o imut√°veis; <code>&amp;str</code> √© uma
refer√™ncia imut√°vel.</p>
<a class="header" href="print.html#slices-de-strings-como-par√¢metros" id="slices-de-strings-como-par√¢metros"><h4>Slices de Strings como Par√¢metros</h4></a>
<p>Saber que voc√™ pode obter slices de literais e <code>String</code>s nos levam a mais um
aprimoramento da fun√ß√£o <code>primeira_palavra</code>, e aqui est√° sua assinatura:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Um Rust√°ceo mais experiente escreveria esta fun√ß√£o conforme a seguir, permitindo
utilizar a mesma fun√ß√£o com <code>String</code>s e <code>&amp;str</code>s:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Se temos uma slice de string, podemos pass√°-la diretamente. Se temos uma
<code>String</code>, podemos passar uma slice da <code>String</code> inteira. Definir uma fun√ß√£o que
recebe uma slice em vez de uma refer√™ncia para uma String deixa nossa API mais
gen√©rica e √∫til sem perder nenhuma funcionalidade:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let minha_string = String::from(&quot;texto longo&quot;);

    // primeira_palavra funciona com slices de `String`s
    let palavra = primeira_palavra(&amp;minha_string[..]);

    let minha_string_literal = &quot;texto longo&quot;;

    // primeira_palavra funciona com strings literais
    let palavra = primeira_palavra(&amp;minha_string_literal[..]);
    
    // uma vez que strings literais *s√£o* slices de strings,
    // isso tamb√©m funciona, sem nem usar sintaxe de slice!
    let palavra = primeira_palavra(minha_string_literal);
}
</code></pre></pre>
<a class="header" href="print.html#outras-slices" id="outras-slices"><h3>Outras Slices</h3></a>
<p>Slices de string, como voc√™ pode imaginar, s√£o espec√≠ficas de strings. Mas h√°
tamb√©m um tipo de slice mais gen√©rico. Considere esta array:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Assim como √†s vezes queremos nos referir a uma parte de uma string, podemos
tamb√©m querer nos referir a uma parte de uma array, e far√≠amos isso da seguinte
forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>Essa slice tem o tipo <code>&amp;[i32]</code>. Ela funciona da mesma forma que as slices de
string, armazenando uma refer√™ncia para o primeiro elemento e um tamanho. Voc√™
vai usar esse tipo de slice para todos os tipos de cole√ß√µes. Vamos discutir
essas cole√ß√µes em mais detalhe quando falarmos sobre vetores no Cap√≠tulo 8.</p>
<a class="header" href="print.html#resumo-1" id="resumo-1"><h2>Resumo</h2></a>
<p>Os conceitos de ownership, borrowing, e slices s√£o o que garante a seguran√ßa de
mem√≥ria dos programas em Rust em tempo de compila√ß√£o. A linguagem Rust lhe d√°
controle sobre o uso da mem√≥ria, assim como outras linguagens de programa√ß√£o de
sistemas, mas como o dono dos dados limpa automaticamente a mem√≥ria quando ele
sai de escopo, voc√™ n√£o tem que escrever e debugar c√≥digo extra para ter esse
controle.</p>
<p>O ownership afeta o funcionamento de v√°rias outras partes do Rust, por isso
vamos falar um pouco mais sobre esses conceitos neste livro daqui para a frente.
Vamos seguir para o pr√≥ximo cap√≠tulo e ver como agrupar dados em uma <code>struct</code>.</p>
<a class="header" href="print.html#usando-structs-para-estruturar-dados-relacionados" id="usando-structs-para-estruturar-dados-relacionados"><h1>Usando Structs para Estruturar Dados Relacionados</h1></a>
<p>Uma <em>struct</em>, ou <em>estrutura</em>, √© um tipo de dados personalizado que nos permite
nomear e criar um conjunto de v√°rios valores relacionados que comp√µem um grupo
de dados. Se voc√™ estiver familiarizado com uma linguagem orientada a objeto,
um <em>struct</em> √© como os atributos de dados de um objeto. Neste cap√≠tulo, vamos
comparar e diferenciar tuplas com structs, demonstrar como usar structs e
discutir como definir os m√©todos e fun√ß√µes associadas √†s structs para
especificar o comportamento associado com os dados de uma struct. Os conceitos
de struct e <em>enum</em> (que ser√° discutido no Cap√≠tulo 6) s√£o os blocos necess√°rios
para a cria√ß√£o de novos tipos para o seu programa, para tirar o m√°ximo proveito
da verifica√ß√£o de tipo no tempo de compila√ß√£o do Rust.</p>
<a class="header" href="print.html#method-syntax" id="method-syntax"><h1>Method Syntax</h1></a>
<a class="header" href="print.html#enums-e-casamento-de-padr√µes-pattern-matching" id="enums-e-casamento-de-padr√µes-pattern-matching"><h1>Enums e Casamento de Padr√µes (<em>Pattern Matching</em>)</h1></a>
<p>Neste cap√≠tulo vamos ver <em>enumera√ß√µes</em>, tamb√©m chamadas de <em>enums</em>. Enums
permitem definir um tipo por meio da enumera√ß√£o de seus poss√≠veis valores.
Primeiro, vamos definir e usar uma enum para mostrar como ela pode atrelar
significado aos nossos dados. Depois, vamos explorar uma enum particularmente
√∫til, chamada <code>Option</code>, que expressa um valor que tanto pode ser algo quanto
pode n√£o ser nada. Em seguida, vamos ver como o casamento de padr√µes por meio
da express√£o <code>match</code> facilita a execu√ß√£o de c√≥digos diferentes para diferentes
valores de uma enum. Por fim, vamos abordar o <code>if let</code>, outra forma concisa e
conveniente que voc√™ pode usar para tratar enums no seu c√≥digo.</p>
<p>Enums s√£o ferramentas que aparecem em muitas linguagens, mas suas
caracter√≠sticas variam de uma para outra. Em Rust, enums s√£o mais parecidas com
os <em>tipos de dados alg√©bricos</em> das linguagens de programa√ß√£o funcional como F#,
OCaml e Haskell.</p>
<a class="header" href="print.html#definindo-uma-enum" id="definindo-uma-enum"><h2>Definindo uma Enum</h2></a>
<p>Vamos ver um caso em que enums podem ser mais apropriadas do que structs e
descobrir como elas podem ser √∫teis. Digamos que estamos trabalhando com
endere√ßos IP. Atualmente, existem duas vers√µes do protocolo IP que s√£o mais
utilizadas: a quatro e a seis. Estas s√£o as √∫nicas possibilidades para um
endere√ßo IP com que o nosso programa vai trabalhar: n√≥s podemos <em>enumerar</em>
todos os poss√≠veis valores, √© da√≠ que vem o nome enumera√ß√£o.</p>
<p>Um endere√ßo IP qualquer pode ser ou da vers√£o quatro ou da vers√£o seis, mas
nunca das duas ao mesmo tempo. Esta propriedade dos endere√ßos IP faz com que a
enum seja bem apropriada para este caso, pois enums s√≥ podem assumir o valor de
uma de suas variantes. Os endere√ßos de ambas as vers√µes, seja quatro ou seis,
ainda s√£o, fundamentalmente, endere√ßos IP, e deveriam ser tratados pelo mesmo
tipo no c√≥digo em situa√ß√µes que se aplicam a qualquer vers√£o de endere√ßo IP.</p>
<p>Podemos expressar esse conceito em c√≥digo definindo uma enum <code>VersaoIp</code> e
listando os poss√≠veis tipos de que um endere√ßo IP pode ser: <code>V4</code> e <code>V6</code>. Estas
s√£o as chamadas <em>variantes</em> da enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>VersaoIp</code> √© um tipo de dados que agora n√≥s podemos usar em qualquer lugar no
nosso c√≥digo.</p>
<a class="header" href="print.html#valores-de-uma-enum" id="valores-de-uma-enum"><h3>Valores de uma Enum</h3></a>
<p>Podemos criar inst√¢ncias de cada uma das duas variantes de <code>VersaoIp</code>, da
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
let quatro = VersaoIp::V4;
let seis = VersaoIp::V6;
#}</code></pre></pre>
<p>Repare que as variantes pertencem ao <em>namespace</em> da enum, e se usa <code>::</code> para
separar os dois. Isso √© √∫til porque agora ambos os valores <code>VersaoIp::V4</code> e
<code>VersaoIp::V6</code> s√£o do mesmo tipo: <code>VersaoIp</code>. Agora n√≥s podemos, por exemplo,
definir uma fun√ß√£o que usa qualquer <code>VersaoIp</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
fn rotear(versao_ip: VersaoIp) { }
#}</code></pre></pre>
<p>E podemos ainda chamar esta fun√ß√£o passando qualquer uma das variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
# fn rotear(versao_ip: VersaoIp) { }
#
rotear(VersaoIp::V4);
rotear(VersaoIp::V6);
#}</code></pre></pre>
<p>O uso de enums tem ainda mais vantagens. Pensando mais a fundo sobre o nosso
tipo de endere√ßo IP, ainda n√£o temos uma forma de representar o <em>endere√ßo</em> em
si, apenas sabemos qual a <em>vers√£o</em> dele. Tendo em vista o que voc√™ acabou de
aprender sobre structs no Cap√≠tulo 5, voc√™ poderia abordar esse problema assim
como visto na Listagem 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}

struct EnderecoIp {
    versao: VersaoIp,
    endereco: String,
}

let local = EnderecoIp {
    versao: VersaoIp::V4,
    endereco: String::from(&quot;127.0.0.1&quot;),
};

let loopback = EnderecoIp {
    versao: VersaoIp::V6,
    endereco: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listagem 6-1: Representa√ß√£o do endere√ßo e da variante
<code>VersaoIp</code> de um endere√ßo IP usando uma <code>struct</code></span></p>
<p>Aqui n√≥s definimos uma struct <code>EnderecoIp</code> que tem dois membros: <code>versao</code>, do
tipo <code>VersaoIp</code> (que definimos anteriormente) e <code>endereco</code>, do tipo <code>String</code>.
Temos duas inst√¢ncias dessa struct. A primeira, <code>local</code>, tem o valor
<code>VersaoIp::V4</code> como sua <code>versao</code>, e um endere√ßo associado igual a <code>127.0.0.1</code>.
A segunda inst√¢ncia, <code>loopback</code>, tem como sua <code>versao</code> a outra variante de
<code>VersaoIp</code>, <code>V6</code>, e o endere√ßo <code>::1</code> associado a ela. N√≥s usamos uma struct
para encapsular os valores de <code>versao</code> e <code>endereco</code>, agora a variante est√°
associada ao valor.</p>
<p>Podemos representar o mesmo conceito de uma forma mais concisa usando apenas
uma enum, em vez de uma enum dentro de uma struct, colocando dados dentro de
cada variante da enum, diretamente. Esta nova defini√ß√£o da enum <code>EnderecoIp</code>
diz que ambas as variantes, <code>V4</code> e <code>V6</code>, ter√£o uma <code>String</code> associada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(String),
    V6(String),
}

let local = EnderecoIp::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Podemos anexar dados a cada variante da enum diretamente, assim n√£o existe mais
a necessidade de uma struct adicional.</p>
<p>H√° uma outra vantagem de se usar uma enum em vez de uma struct: cada variante
pode conter dados de diferentes tipos e quantidades. Os endere√ßos IP da vers√£o
quatro t√™m sempre quatro componentes num√©ricas, cada uma com valor de 0 a 255.
Se quis√©ssemos representar endere√ßos <code>V4</code> como quatro valores <code>u8</code>, e ao mesmo
tempo manter os endere√ßos <code>V6</code> como uma <code>String</code>, n√£o poder√≠amos usar uma
struct. J√° as enums podem facilmente atender a este caso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(u8, u8, u8, u8),
    V6(String),
}

let local = EnderecoIp::V4(127, 0, 0, 1);

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Acabamos de ver algumas possibilidades que poder√≠amos usar para representar
endere√ßos IP das duas vers√µes por meio de uma enum. Acontece que essa
necessidade de representar endere√ßos IP, incluindo sua vers√£o, √© t√£o comum que
a biblioteca padr√£o j√° possui uma defini√ß√£o que podemos usar! (<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">Veja a
documenta√ß√£o em ingl√™s</a><!-- ignore -->). Vamos ver como a biblioteca
padr√£o define <code>IpAddr</code>: ele tem basicamente a mesma enum e as mesmas variantes
que n√≥s definimos e usamos anteriormente, mas os dados do endere√ßo s√£o
embutidos dentro das variantes na forma de duas structs separadas, que s√£o
definidas de um jeito diferente pra cada variante.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // detalhes omitidos
}

struct Ipv6Addr {
    // detalhes omitidos
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>Esse c√≥digo mostra que voc√™ pode colocar qualquer tipo de dados dentro de uma
variante de enum: strings, tipos num√©ricos ou structs, por exemplo. Voc√™ pode
at√© mesmo incluir outra enum! Al√©m disso, os tipos definidos pela biblioteca
padr√£o n√£o s√£o t√£o mais complicados do que o que talvez voc√™ pensaria em fazer.</p>
<p>Repare que, mesmo havendo um <code>IpAddr</code>definido pela biblioteca padr√£o, n√≥s ainda
podemos criar e utilizar nossa pr√≥pria defini√ß√£o (com o mesmo nome, inclusive)
sem nenhum conflito, porque n√£o trouxemos a defini√ß√£o da biblioteca padr√£o para
dentro do nosso escopo. Falaremos mais sobre a inclus√£o de tipos em um escopo
no Cap√≠tulo 7.</p>
<p>Vamos ver outro exemplo de uma enum na Listagem 6-2: esta tem uma grande
variedade de tipos embutidos nas suas variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-2: Enum <code>Mensagem</code>, cujas variantes cont√™m,
cada uma, diferentes tipos e quantidades de dados</span></p>
<p>Esta enum tem quatro variantes de diferentes tipos:</p>
<ul>
<li><code>Sair</code> n√£o tem nenhum dado associado.</li>
<li><code>Mover</code> cont√©m uma struct an√¥nima.</li>
<li><code>Escrever</code> cont√©m uma √∫nica <code>String</code>.</li>
<li><code>MudarCor</code> cont√©m tr√™s valores do tipo <code>i32</code>.</li>
</ul>
<p>Definir uma enum com variantes iguais √†s da Listagem 6-2 √© similar a definir
diferentes tipos de struct, exceto que a enum n√£o usa a palavra-chave <code>struct</code>,
e todas as variantes s√£o agrupadas dentro do tipo <code>Mensagem</code>. As structs
seguintes podem guardar os mesmos dados que as variantes da enum anterior:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MensagemSair; // unit struct
struct MensagemMover {
    x: i32,
    y: i32,
}
struct MensagemEscrever(String); // tuple struct
struct MensagemMudarCor(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>Mas se usarmos structs diferentes, cada uma tendo seu pr√≥prio tipo, n√£o vamos
conseguir t√£o facilmente definir uma fun√ß√£o que possa receber qualquer um
desses tipos de mensagens, assim como fizemos com a enum <code>Mensagem</code>, definida
na Listagem 6-2, que consiste em um tipo √∫nico.</p>
<p>H√° mais uma similaridade entre enums e structs: da mesma forma como podemos
definir m√©todos em structs usando <code>impl</code>, tamb√©m podemos definir m√©todos em
enums. Aqui est√° um m√©todo chamado <code>invocar</code>, que poderia ser definido na nossa
enum <code>Mensagem</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Mensagem {
#     Sair,
#     Mover { x: i32, y: i32 },
#     Escrever(String),
#     MudarCor(i32, i32, i32),
# }
#
impl Mensagem {
    fn invocar(&amp;self) {
        // o corpo do m√©todo √© definido aqui
    }
}

let m = Mensagem::Escrever(String::from(&quot;ol√°&quot;));
m.invocar();
#}</code></pre></pre>
<p>O corpo do m√©todo usaria o valor <code>self</code> para obter a mensagem sobre a qual o
m√©todo foi chamado. Neste exemplo, criamos a vari√°vel <code>m</code>, que cont√©m o valor
<code>Mensagem::Escrever(String::from(&quot;ol√°&quot;))</code>, e √© isso que <code>self</code> vai ser no corpo
do m√©todo <code>invocar</code> quando <code>m.invocar()</code> for executado.</p>
<p>Vamos ver agora outra enum da biblioteca padr√£o que tamb√©m √© muito √∫til e
comum: <code>Option</code>.</p>
<a class="header" href="print.html#a-enum-option-e-suas-vantagens-sobre-valores-nulos" id="a-enum-option-e-suas-vantagens-sobre-valores-nulos"><h3>A Enum <code>Option</code> e Suas Vantagens Sobre Valores Nulos</h3></a>
<p>Na se√ß√£o anterior, vimos como a enum <code>EnderecoIp</code> nos permite usar o sistema de
tipos do Rust para codificar em nosso programa mais informa√ß√£o do que apenas os
dados que queremos representar. Essa se√ß√£o explora um caso de estudo da
<code>Option</code>, que √© outra enum definida pela biblioteca padr√£o. O tipo <code>Option</code> √©
muito utilizado, pois engloba um cen√°rio muito comum, em que um valor pode ser
algo ou pode n√£o ser nada. Expressar esse conceito por meio do sistema de tipos
significa que o compilador pode verificar se voc√™ tratou, ou n√£o, todos os
casos que deveriam ser tratados, podendo evitar <em>bugs</em> que s√£o extremamente
comuns em outras linguagens de programa√ß√£o.</p>
<p>O <em>design</em> de uma linguagem de programa√ß√£o √© geralmente tratado em termos de
quais caracter√≠sticas s√£o inclu√≠das, mas as que s√£o exclu√≠das tamb√©m t√™m
import√¢ncia. Rust n√£o tem o valor nulo (<em>null</em>) que outras linguagens t√™m. O
valor nulo quer dizer que n√£o h√° nenhum valor. Em linguagens que t√™m essa
caracter√≠stica, as vari√°veis sempre est√£o em um dos dois estados: nulo ou n√£o
nulo.</p>
<p>Em uma confer√™ncia, Tony Hoare, inventor do valor nulo, disse o seguinte:</p>
<blockquote>
<p>Eu o chamo meu erro de um bilh√£o de d√≥lares. Naquela √©poca, eu estava
projetando o primeiro sistema abrangente de tipos para refer√™ncias em uma
linguagem orientada a objetos. Meu objetivo era garantir que todo uso de
refer√™ncias deveria ser absolutamente seguro, com verifica√ß√£o autom√°tica
feita pelo compilador. Mas n√£o pude resistir √† tenta√ß√£o de colocar uma
refer√™ncia nula, simplesmente porque era t√£o f√°cil de implementar. Isso tem
provocado in√∫meros erros, vulnerabilidades, e falhas de sistemas que
provavelmente causaram um bilh√£o de d√≥lares de dor e danos nos √∫ltimos
quarenta anos.</p>
</blockquote>
<p>O problema com valores nulos √© que, se voc√™ tentar usar um valor nulo como se
fosse n√£o nulo, vai acontecer algum tipo de erro. Pelo fato dessa propriedade
de nulo e n√£o nulo ser t√£o sutil, √© extremamente f√°cil cometer esse tipo de
erro.</p>
<p>Por√©m, o conceito que o valor nulo tenta expressar ainda √© √∫til: um valor nulo
representa algo que, por algum motivo, est√° inv√°lido ou ausente no momento.</p>
<p>O problema, na verdade, n√£o est√° no conceito, mas na implementa√ß√£o em
particular. Por isso, Rust n√£o possui valores nulos, mas sim uma enum que
engloba o conceito de um valor estar presente ou ausente. Esta enum √© a
<code>Option&lt;T&gt;</code>, que est√° definida na biblioteca padr√£o da seguinte forma:
(<a href="https://doc.rust-lang.org/std/option/enum.Option.html">Veja a documenta√ß√£o em ingl√™s</a><!-- ignore -->).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T), // algum valor
    None, // nenhum valor
}
#}</code></pre></pre>
<p>A enum <code>Option&lt;T&gt;</code> √© t√£o √∫til que ela j√° vem inclusa no prel√∫dio: voc√™ n√£o
precisa traz√™-la explicitamente para o seu escopo. Al√©m disso, o mesmo ocorre
com suas variantes: voc√™ pode usar <code>Some</code> e <code>None</code> diretamente sem prefix√°-las
com <code>Option::</code>. <code>Option&lt;T&gt;</code> continua sendo uma enum como qualquer outra, e
<code>Some(T)</code> e <code>None</code> ainda s√£o variantes do tipo <code>Option&lt;T&gt;</code>.</p>
<p>A sintaxe do <code>&lt;T&gt;</code> √© uma caracter√≠stica do Rust de que n√£o falamos ainda.
Trata-se de um par√¢metro de tipo gen√©rico, vamos abord√°-lo com mais detalhe no
Cap√≠tulo 10. Por ora, tudo que voc√™ precisa saber √© que <code>&lt;T&gt;</code> significa que a
variante <code>Some</code> da enum <code>Option</code> pode conter um dado de qualquer tipo. Aqui v√£o
alguns exemplos de <code>Option</code> contendo tipos de n√∫mero e texto:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_numero = Some(5);
let algum_texto = Some(&quot;um texto&quot;);

let numero_ausente: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>Se usamos <code>None</code> em vez de <code>Some</code>, precisamos dizer ao Rust qual √© o tipo de
<code>Option&lt;T&gt;</code> que n√≥s temos, porque o compilador n√£o consegue inferir qual tipo
estar√° contido na variante <code>Some</code> apenas olhando para um valor <code>None</code>.</p>
<p>Quando temos um <code>Some</code>, sabemos que um valor est√° presente, contido dentro do
<code>Some</code>. J√° quando temos um <code>None</code>, de certa forma, significa o mesmo que um
valor nulo: n√£o temos um valor que seja v√°lido. Ent√£o por que a <code>Option&lt;T&gt;</code> √©
t√£o melhor que usar um valor nulo?</p>
<p>Em resumo, √© porque <code>Option&lt;T&gt;</code> e <code>T</code> (podendo <code>T</code> ser de qualquer tipo) s√£o
tipos diferentes, por isso, o compilador n√£o vai permitir usar um valor do tipo
<code>Option&lt;T&gt;</code> como se ele definitivamente tivesse um valor v√°lido. Por exemplo,
o c√≥digo seguinte n√£o vai compilar, porque ele est√° tentando somar um <code>i8</code> a um
<code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let soma = x + y;
</code></pre>
<p>Quando executamos esse c√≥digo, temos uma mensagem de erro como essa:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intenso! O que essa mensagem quer dizer √© que o Rust n√£o consegue entender como
somar um <code>i8</code> e um <code>Option&lt;i8&gt;</code>, porque eles s√£o de tipos diferentes. Quando
temos um valor de um tipo como <code>i8</code> em Rust, o compilador tem certeza de que
temos sempre um valor v√°lido. Podemos prosseguir com confian√ßa, sem ter de
verificar se o valor √© nulo antes de us√°-lo. Somente quando temos um
<code>Option&lt;i8&gt;</code> (ou qualquer que seja o tipo com que estamos trabalhando), vamos
ter de nos preocupar com a possibilidade de n√£o haver um valor, e o compilador
vai se certificar de que n√≥s estamos tratando este caso antes de usar o valor.</p>
<p>Em outras palavras, voc√™ tem que converter um <code>Option&lt;T&gt;</code> em um <code>T</code> antes de
poder executar opera√ß√µes com ele. Geralmente, isso ajuda a detectar um dos
problemas mais comuns com valores nulos: assumir que algo n√£o √© nulo quando,
na verdade, ele √©.</p>
<p>S√≥ de n√£o ter que se preocupar com a possibilidade de ter deixado um valor nulo
escapar j√° lhe d√° mais confian√ßa em seu c√≥digo. Pra ter um valor que pode ser
nulo em algum momento, voc√™ precisa, explicitamente, marc√°-lo como sendo do
tipo <code>Option&lt;T&gt;</code>. A partir da√≠, sempre que for usar o valor, voc√™ ser√° obrigado
a tratar, de forma expl√≠cita, o caso do valor sendo nulo. Sempre que houver um
valor que n√£o seja um <code>Option&lt;T&gt;</code>, voc√™ <em>pode</em> assumir, com seguran√ßa, que o
valor n√£o √© nulo. Esta foi uma decis√£o deliberada de projeto do Rust para
limitar as sutilezas dos valores nulos e aumentar a seguran√ßa do c√≥digo.</p>
<p>Ent√£o, como obter o valor <code>T</code> da variante <code>Some</code> quando se tem um <code>Option&lt;T&gt;</code>,
para que se possa usar seu valor? A enum <code>Option&lt;T&gt;</code> possui diversos m√©todos
que s√£o √∫teis em uma variedade de situa√ß√µes, voc√™ pode pesquis√°-los na
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">documenta√ß√£o</a><!-- ignore --> (em ingl√™s). Ser√° extremamente √∫til na sua
jornada com Rust se familizarizar com os m√©todos da enum <code>Option&lt;T&gt;</code>.</p>
<p>Em geral, pra usar um valor <code>Option&lt;T&gt;</code>, queremos ter um c√≥digo que trate cada
uma das variantes. Queremos um c√≥digo que s√≥ ser√° executado quando tivermos um
valor <code>Some(T)</code>, e esse c√≥digo ter√° permiss√£o para usar o valor <code>T</code> que est√°
embutido. Queremos tamb√©m um outro c√≥digo que seja executado se tivermos um
valor <code>None</code>, e esse c√≥digo n√£o ter√° um valor <code>T</code> dispon√≠vel. A express√£o
<code>match</code> √© uma instru√ß√£o de controle de fluxo que faz exatamente isso quando
usada com enums: ela executa c√≥digos diferentes dependendo de qual variante
tiver a enum, e esse c√≥digo poder√° usar os dados contidos na variante
encontrada.</p>
<a class="header" href="print.html#operador-match-de-controle-de-fluxo" id="operador-match-de-controle-de-fluxo"><h2>Operador <code>match</code> de Controle de Fluxo</h2></a>
<p>O Rust tem um excelente operador de controle de fluxo chamado <code>match</code>, que nos
permite comparar um valor com uma s√©rie de padr√µes e executar um c√≥digo com
base no padr√£o que casar. Padr√µes podem ser compostos de valores literais,
vari√°veis, caracteres-curinga e v√°rias outras coisas. O Cap√≠tulo 18 aborda
todos os tipos de padr√µes e o que eles fazem. A grande utilidade do <code>match</code> vem
da expressividade dos padr√µes e das an√°lises feitas pelo compilador, tendo
certeza de que todos os casos poss√≠veis est√£o sendo tratados.</p>
<p>Imagine que express√£o <code>match</code> funciona como uma m√°quina de contar moedas: as
moedas passam por um canal que possui furos de v√°rios tamanhos, e cada moeda
cai no primeiro furo em que ela couber. Da mesma forma, os valores passam por
cada padr√£o de um <code>match</code>, e logo no primeiro padr√£o que o valor &quot;se encaixar&quot;,
o bloco de c√≥digo que estiver associado a ele ser√° executado.</p>
<p>Aproveitando que acabamos de falar sobre moedas, vamos us√°-las como exemplo de
utiliza√ß√£o do <code>match</code>! Podemos escrever uma fun√ß√£o que recebe uma moeda
qualquer dos Estados Unidos e, assim como uma m√°quina, determina qual moeda ela
√© e retorna seu valor em <em>cents</em>, como mostra a Listagem 6-3:</p>
<blockquote>
<p><strong>Nota do tradutor:</strong> diferentemente do que acontece na maioria dos pa√≠ses,
as moedas dos Estados Unidos possuem nomes: as de 1 <em>cent</em> s√£o chamadas de
<em>Penny</em>; as de 5 <em>cents</em>, de <em>Nickel</em>; as de 10 <em>cents</em>, de <em>Dime</em>; e as de 25
<em>cents</em>, de <em>Quarter</em>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-3: Uma enum e uma express√£o <code>match</code> em que os
padr√µes comparados s√£o as variantes da enum.</span></p>
<p>Vamos analisar o <code>match</code> da fun√ß√£o <code>valor_em_cents</code>. Primeiro, usamos a
palavra-chave <code>match</code> seguida de uma express√£o, que neste caso √© o valor
<code>moeda</code>. √â parecido a uma express√£o utilizada com <code>if</code>, mas tem uma grande
diferen√ßa: com <code>if</code>, a express√£o precisa retornar um valor <em>booleano</em>. Aqui,
pode ser de qualquer tipo. O tipo da vari√°vel <code>moeda</code>, neste exemplo, √© a enum
<code>Moeda</code>, que definimos na Listagem 6-3.</p>
<p>Em seguida v√™m os bra√ßos do <code>match</code>. Um bra√ßo √© composto por duas partes: um
padr√£o e algum c√≥digo. O primeiro bra√ßo deste exemplo tem um padr√£o, que √© o
valor <code>Moeda::Penny</code>, e o operador <code>=&gt;</code> que separa o padr√£o do c√≥digo associado
a ele. O c√≥digo, nesse caso, √© apenas o valor <code>1</code>. Os bra√ßos s√£o separados uns
dos outros com uma v√≠rgula.</p>
<p>Quando o <code>match</code> √© executado, ele compara o valor resultante com o padr√£o de
cada bra√ßo, na ordem. Se o valor casar com um determinado padr√£o, o c√≥digo
associado a esse padr√£o ser√° executado. Se o valor n√£o se encaixa nesse padr√£o,
a execu√ß√£o passa para o pr√≥ximo bra√ßo, bem parecido com a m√°quina de contar
moedas. Podemos ter tantos bra√ßos quanto precisamos. No caso da Listagem 6-3,
nosso <code>match</code> tem quatro bra√ßos.</p>
<p>O c√≥digo associado a cada bra√ßo √© uma express√£o, e o seu valor resultante, no
bra√ßo que combinar, √© o que ser√° retornado pela express√£o <code>match</code>.</p>
<p>Tipicamente n√£o se usa chaves se o bra√ßo do <code>match</code> for curto, como √© o caso na
Listagem 6-3, em que cada bra√ßo retorna apenas um valor. Se voc√™ quiser
executar mais de uma linha de c√≥digo em um bra√ßo, voc√™ pode usar chaves para
delimit√°-las. Por exemplo, o c√≥digo seguinte vai escrever na tela &quot;Moeda da
sorte!&quot; sempre que o m√©todo for chamado com uma <code>Moeda::Penny</code>, mas ainda vai
retornar o √∫ltimo valor do bloco, <code>1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; {
            println!(&quot;Moeda da sorte!&quot;);
            1
        },
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#padr√µes-atrelados-a-valores" id="padr√µes-atrelados-a-valores"><h3>Padr√µes Atrelados a Valores</h3></a>
<p>Outra caracter√≠stica √∫til dos bra√ßos do <code>match</code> √© que eles podem ser atrelados
a partes dos valores que se encaixam no padr√£o. √â assim que podemos extrair
valores dentro de uma variante de uma enum.</p>
<p>Por exemplo, vamos alterar uma das nossas variantes, inserindo dados dentro
dela. De 1999 at√© 2008, os Estados Unidos cunhou <em>quarters</em> com um <em>design</em>
diferente para cada um dos 50 estados em um dos lados da moeda. Nenhuma outra
moeda tinha essa diferen√ßa no <em>design</em>, apenas os <em>quarters</em>. Podemos adicionar
essa informa√ß√£o √† nossa <code>enum</code> alterando a variante <code>Quarter</code> para incluir o
valor <code>Estado</code>, como √© feito na Listagem 6-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // Para podermos ver qual √© o estado com mais facilidade
enum Estado {
    Alabama,
    Alaska,
    // ... etc
}

enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter(Estado),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-4: Enum <code>Moeda</code>, cuja variante <code>Quarter</code>
tamb√©m guarda o valor <code>Estado</code>.</span></p>
<p>Vamos imaginar que um amigo nosso est√° tentando colecionar todas os <em>quarters</em>
dos 50 estados. Enquanto separamos nosso troco por tipo de moeda, vamos tamb√©m
dizer o nome do estado associado a cada <em>quarter</em>. Se for um dos que o nosso
amigo ainda n√£o tem, ele pode coloc√°-lo na sua cole√ß√£o.</p>
<p>Na express√£o <code>match</code> desse c√≥digo, vamos adicionar uma vari√°vel chamada
<code>estado</code> ao padr√£o que casa com os valores da variante <code>Moeda::Quarter</code>. Quando
uma <code>Moeda::Quarter</code> √© testada, a vari√°vel <code>estado</code> vai ser atrelada ao valor
do estado daquele <em>quarter</em>. Assim vamos poder usar o <code>estado</code> no c√≥digo do
bra√ßo, desse jeito:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter(estado) =&gt; {
            println!(&quot;Quarter do estado {:?}!&quot;, estado);
            25
        },
    }
}
#}</code></pre></pre>
<p>Se executarmos <code>valor_em_cents(Moeda::Quarter(Estado::Alaska))</code>, <code>moeda</code> seria
<code>Moeda::Quarter(Estado::Alaska)</code>. Quando comparamos esse valor em cada um dos
bra√ßos do <code>match</code>, nenhum deles vai casar enquanto n√£o chegar em
<code>Moeda::Quarter(estado)</code>. Nesse ponto, <code>estado</code> vai estar atrelado ao valor
<code>Estado::Alaska</code>. Podemos, ent√£o, usar esse valor na express√£o <code>println!</code>,
obtendo o estado contido na variante <code>Quarter</code> da enum <code>Moeda</code>.</p>
<a class="header" href="print.html#usando-match-com-optiont" id="usando-match-com-optiont"><h3>Usando <code>match</code> com <code>Option&lt;T&gt;</code></h3></a>
<p>Na se√ß√£o anterior, quer√≠amos obter o valor <code>T</code> contido em um <code>Some</code> quando era
o caso em uma <code>Option&lt;T&gt;</code>. Tamb√©m podemos manipular uma <code>Option&lt;T&gt; usando</code>match<code>, assim como fizemos com a enum</code>Moeda<code>! Em vez de comparar moedas, vamos comparar as variantes de</code>Option<T><code>, mas a forma de trabalhar com a express√£o</code>match` continua a mesma.</p>
<p>Digamos que queremos escrever uma fun√ß√£o que recebe um <code>Option&lt;i32&gt;</code>, e se
houver um valor embutido nele, soma um a esse valor. Se n√£o houver um valor,
a fun√ß√£o deve retornar <code>None</code>, e nem tentar executar nenhuma opera√ß√£o.</p>
<p>Essa fun√ß√£o √© bem f√°cil de implementar, gra√ßas ao <code>match</code>, e vai ficar conforme
visto na Listagem 6-5:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let cinco = Some(5);
let seis = mais_um(cinco);
let nenhum = mais_um(None);
#}</code></pre></pre>
<p><span class="caption">Listagem 6-5: Uma fun√ß√£o que usa um <code>match</code> para tratar
uma <code>Option&lt;i32&gt;</code>.</span></p>
<a class="header" href="print.html#casando-somet" id="casando-somet"><h4>Casando <code>Some(T)</code></h4></a>
<p>Vamos examinar a primeira execu√ß√£o de <code>mais_um</code> em mais detalhes. Quando
chamamos <code>mais_um(cinco)</code>, a vari√°vel <code>x</code> no corpo da fun√ß√£o <code>mais_um</code> vai ter
o valor <code>Some(5)</code>. Ent√£o comparamos ele a cada bra√ßo do <code>match</code>.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>O valor <code>Some(5)</code> n√£o casa com o padr√£o <code>None</code>, ent√£o seguimos para o
pr√≥ximo bra√ßo.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5) casa com</code>Some(i)<code>? Sim, casa! Temos a mesma variante. O</code>i<code>est√° atrelado ao valor contido em</code>Some<code>, ent√£o</code>i<code>passa a ter o valor</code>5<code>. O c√≥digo desse bra√ßo √© executado, ent√£o somamos um ao valor de</code>i<code>e criamos um novo</code>Some<code>contendo nosso total de</code>6`.</p>
<a class="header" href="print.html#casando-none" id="casando-none"><h4>Casando <code>None</code></h4></a>
<p>Agora vamos considerar a segunda chamada da fun√ß√£o <code>mais_um</code> na Listagem 6-5,
em que <code>x</code> √© <code>None</code>. N√≥s entramos no <code>match</code> e comparamos com o primeiro bra√ßo.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Confere! N√£o h√° nenhum valor para somar, ent√£o o programa p√°ra e retorna o
valor <code>None</code> do lado direito do <code>=&gt;</code>. Como o primeiro bra√ßo j√° casou, nenhum
dos demais ser√° testado.</p>
<p>A combina√ß√£o de enums e a express√£o <code>match</code> √© √∫til em diversas situa√ß√µes. Voc√™
ver√° muito esse padr√£o em Rust: fazer o <code>match</code> de uma enum, associar uma
vari√°vel ao valor embutido, e ent√£o executar um c√≥digo baseado nele. Pode
parecer complicado no come√ßo, mas uma vez que voc√™ se acostume, voc√™ vai querer
que tivesse isso em todas as linguagens. √â, sistematicamente, um favorito dos
usu√°rios.</p>
<a class="header" href="print.html#matches-s√£o-exaustivos" id="matches-s√£o-exaustivos"><h3><em>Matches</em> S√£o Exaustivos</h3></a>
<p>H√° outro aspecto do <code>match</code> que precisamos discutir. Considere essa vers√£o da
nossa fun√ß√£o <code>mais_um</code>:</p>
<pre><code class="language-rust ignore">fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>N√≥s n√£o tratamos o caso <code>None</code>, logo vai ocorrer um <em>bug</em> no nosso c√≥digo. Por
sorte, √© um <em>bug</em> que o Rust sabe detectar. Se tentarmos compilar esse c√≥digo,
vamos ter esse erro:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>O Rust sabe que n√≥s n√£o cobrimos todos os casos poss√≠veis, e sabe at√© de qual
padr√£o nos esquecemos! <em>Matches</em> em Rust s√£o <em>exaustivos</em>: precisamos extinguir
at√© a √∫ltima possibilidade pra que o nosso c√≥digo seja v√°lido. Especialmente no
caso de uma <code>Option&lt;T&gt;</code>, em que o Rust n√£o nos deixa esquecer de tratar
explicitamente o caso <code>None</code>. Ele nos impede de assumir que temos um valor
v√°lido quando possivelmente temos um valor nulo, e portanto, cometer o erro de
um bilh√£o de d√≥lares que vimos mais cedo.</p>
<a class="header" href="print.html#the-_-placeholder" id="the-_-placeholder"><h3>The <code>_</code> Placeholder</h3></a>
<a class="header" href="print.html#o-placeholder-_" id="o-placeholder-_"><h3>O <em>Placeholder</em> <code>_</code></h3></a>
<p>O Rust tamb√©m tem um padr√£o que podemos usar em situa√ß√µes em que n√£o queremos
listar todos os valores poss√≠veis. Por exemplo, um <code>u8</code> pode ter valores
v√°lidos de 0 a 255. Se nos importamos apenas com os valores 1, 3, 5 e 7, n√£o
queremos ser obrigados a listar o 0, 2, 4, 6, 8, 9, e assim por diante at√© 255.
Felizmente, nem precisamos: em vez disso, podemos usar o padr√£o especial <code>_</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = 0u8;
match algum_valor_u8 {
    1 =&gt; println!(&quot;um&quot;),
    3 =&gt; println!(&quot;tr√™s&quot;),
    5 =&gt; println!(&quot;cinco&quot;),
    7 =&gt; println!(&quot;sete&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>O padr√£o <code>_</code> casa com qualquer valor. Colocando ele depois dos demais
bra√ßos, o <code>_</code> vai casar com todos os casos poss√≠veis que n√£o foram
especificados antes dele. O <code>()</code> √© s√≥ o valor-unidade, pra que nada aconte√ßa no
caso <code>_</code>. Como resultado, podemos dizer que n√£o queremos fazer nada com os
poss√≠veis valores que n√£o listamos antes do <em>placeholder</em> <code>_</code>.</p>
<p>Contudo, a express√£o <code>match</code> pode ser um tanto verbosa em uma situa√ß√£o em que
queremos apenas lidar com <em>um</em> dos casos. Pra essa situa√ß√£o, o Rust oferece o
<code>if let</code>.</p>
<a class="header" href="print.html#controle-de-fluxo-conciso-com-if-let" id="controle-de-fluxo-conciso-com-if-let"><h2>Controle de Fluxo Conciso com <code>if let</code></h2></a>
<p>A sintaxe do <code>if let</code> permite combinar <code>if</code> e <code>let</code> em uma forma menos verbosa
de tratar apenas os valores que casam com um padr√£o e ignorar os demais.
Considere o programa da Listagem 6-6, que confere um valor do tipo
<code>Option&lt;u8&gt;</code>, mas s√≥ executa um c√≥digo se houver um valor associado igual a
tr√™s:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = Some(0u8);
match algum_valor_u8 {
    Some(3) =&gt; println!(&quot;tr√™s&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-6: Um <code>match</code> que s√≥ executa um c√≥digo quando
o valor √© <code>Some(3)</code>.</span></p>
<p>Queremos fazer alguma coisa com o <code>Some(3)</code>, mas n√£o queremos fazer nada com
nenhum outro valor, seja <code>Some&lt;u8&gt;</code> ou <code>None</code>. Pra satisfazer a express√£o
<code>match</code>, temos que colocar <code>_ =&gt; ()</code> ap√≥s processar apenas uma variante, ou
seja, √© muito c√≥digo para pouca coisa.</p>
<p>Em vez disso, poder√≠amos escrever o mesmo c√≥digo de uma forma mais compacta,
usando <code>if let</code>. O c√≥digo seguinte tem o mesmo comportamento do <code>match</code> na
Listagem 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let algum_valor_u8 = Some(0u8);
if let Some(3) = algum_valor_u8 {
    println!(&quot;tr√™s&quot;);
}
#}</code></pre></pre>
<p><code>if let</code> recebe um padr√£o e uma express√£o separados por um <code>=</code>. Isso funciona
da mesma forma que um <code>match</code>, em que a express√£o seria passada para o <code>match</code>,
e o padr√£o apareceria no primeiro bra√ßo.</p>
<p>Usar o <code>if let</code> implica menos c√≥digo pra digitar e menos indenta√ß√£o. Por√©m,
perdemos a verifica√ß√£o exaustiva que √© garantida pelo <code>match</code>. A escolhe entre
<code>match</code> e <code>if let</code> depende do que voc√™ est√° fazendo em uma situa√ß√£o particular,
e se a redu√ß√£o no volume de c√≥digo compensa a perda da verifica√ß√£o exaustiva.</p>
<p>Em outras palavras, voc√™ pode enxergar o <code>if let</code> como um <em>syntax sugar</em> (um
atalho) para um <code>match</code> que s√≥ executa um c√≥digo quando o valor casa com um
√∫nico padr√£o, e ignora todos os outros valores.</p>
<p>Tamb√©m podemos incluir um <code>else</code> em um <code>if let</code>. O bloco de c√≥digo que vai no
<code>else</code> √© o mesmo que iria no caso <code>_</code> da express√£o <code>match</code> equivalente.
Lembre-se da enum <code>Moeda</code> que definimos na Listagem 6-4, cuja variante
<code>Quarter</code> guardava um valor do tipo <code>Estado</code>. Se queremos contar todas as
moedas que n√£o forem <em>quarters</em>, enquanto tamb√©m anunciamos o estado dos
<em>quarters</em>, poder√≠amos fazer isso com uma express√£o <code>match</code> igual a esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Coin::Penny;
let mut contagem = 0;
match moeda {
    Moeda::Quarter(estado) =&gt; println!(&quot;Quarter do estado {:?}!&quot;, estado),
    _ =&gt; contagem += 1,
}
#}</code></pre></pre>
<p>Ou poder√≠amos usar um <code>if let</code> e um <code>else</code> desta forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Moeda::Penny;
let mut contagem = 0;
if let Moeda::Quarter(estado) = moeda {
    println!(&quot;Quarter do estado {:?}!&quot;, estado);
} else {
    contagem += 1;
}
#}</code></pre></pre>
<p>Se a l√≥gica do seu programa fica muito verbosa quando √© expressa por meio de um
<code>match</code>, lembre-se que voc√™ tamb√©m disp√µe do <code>if let</code>.</p>
<a class="header" href="print.html#resumo-2" id="resumo-2"><h2>Resumo</h2></a>
<p>N√≥s acabamos de ver como usar enums para criar tipos customizados a partir de
um conjunto de valores enumerados. Mostramos como o tipo <code>Option&lt;T&gt;</code>, da
biblioteca padr√£o, ajuda voc√™ a usar o sistema de tipos para evitar erros.
Quando as enums cont√™m dados, voc√™ pode usar <code>match</code> ou <code>if let</code> para extrair
e usar esses valores, dependendo de quantos casos voc√™ precisa tratar.</p>
<p>Agora, seus programas em Rust podem expressar conceitos em seu dom√≠nio usando
structs e enums. Criar tipos customizados para a sua <em>API</em> aumenta sua
seguran√ßa: o compilador vai se certificar de que suas fun√ß√µes recebem apenas
os valores que correspondem aos tipos esperados.</p>
<p>Para fornecer uma API bem organizada aos seus usu√°rios, que seja simples de
usar, e que exponha apenas o que √© necess√°rio aos usu√°rios, vamos agora passar
para os m√≥dulos em Rust.</p>
<a class="header" href="print.html#usando-m√≥dulos-para-reutilizar-e-organizar-c√≥digo" id="usando-m√≥dulos-para-reutilizar-e-organizar-c√≥digo"><h1>Usando M√≥dulos para Reutilizar e Organizar C√≥digo</h1></a>
<p>Quando voc√™ come√ßa a escrever programas em Rust, seu c√≥digo pode se manter apenas na
fun√ß√£o <code>main</code>. √Ä medida que seu c√≥digo cresce, voc√™ acabar√° por mover funcionalidades para
outras outras fun√ß√µes a fim de reutilizar c√≥digo e melhorar a organiza√ß√£o. Ao dividir seu c√≥digo em
pequenos peda√ßos, cada peda√ßo √© mais f√°cil de entender por si s√≥. Mas o que acontece
se voc√™ tem muitas fun√ß√µes? Rust possui um sistema de m√≥dulos que permite a reutiliza√ß√£o
de c√≥digo de forma organizada.</p>
<p>Da mesma forma que voc√™ extrai linhas de c√≥digo em uma fun√ß√£o, voc√™ pode extrair
fun√ß√µes (e outros c√≥digos, como structs e enums) em diferentes m√≥dulos. Um
<em>m√≥dulo</em> √© um namespace que cont√©m defini√ß√µes de fun√ß√µes ou tipos, e
voc√™ pode escolher se essas defini√ß√µes s√£o vis√≠veis fora de seu m√≥dulo
(p√∫blico) ou n√£o (privado). Aqui est√° uma vis√£o geral de como os m√≥dulos funcionam:</p>
<ul>
<li>A palavra-chave <code>mod</code> declara um novo m√≥dulo. O c√≥digo dentro do m√≥dulo aparece
¬†¬† imediatamente ap√≥s esta declara√ß√£o dentro de chaves ou em
¬†¬† outro arquivo.</li>
<li>Por padr√£o, as fun√ß√µes, tipos, constantes e m√≥dulos s√£o privados. A palavra-chave <code>pub</code>
¬†¬†  torna um item p√∫blico e, portanto, vis√≠vel fora do seu namespace.</li>
<li>A palavra-chave <code>use</code> traz m√≥dulos, ou as defini√ß√µes dentro dos m√≥dulos, ao
¬†¬† escopo, assim √© mais f√°cil se referir a eles.</li>
</ul>
<p>Examinaremos cada uma dessas partes para ver como elas se encaixam no todo.</p>
<a class="header" href="print.html#mod-e-o-sistema-de-arquivos" id="mod-e-o-sistema-de-arquivos"><h2><code>mod</code> e o Sistema de Arquivos</h2></a>
<p>Vamos iniciar o nosso exemplo de m√≥dulo fazendo um novo projeto com o Cargo, mas em vez de
criar um crate bin√°rio, faremos um crate de biblioteca: um projeto que
as outras pessoas podem puxar para os seus projetos como uma depend√™ncia. Por exemplo, o crate <code>rand</code>
discutido no Cap√≠tulo 2, √© um crate de biblioteca que usamos como uma depend√™ncia no
projeto do jogo de adivinha√ß√£o.</p>
<p>Criaremos um esqueleto de uma biblioteca que fornece algumas funcionalidades gerais
de rede; nos concentraremos na organiza√ß√£o dos m√≥dulos e fun√ß√µes,
mas n√£o nos preocuparemos com o c√≥digo que est√° dentro das fun√ß√µes. Chamaremos
nossa biblioteca de <code>communicator</code>. Por padr√£o, o Cargo criar√° uma biblioteca, a menos que
outro tipo de projeto seja especificado: se omitimos a op√ß√£o <code>--bin</code>, que temos
usado em todos os cap√≠tulos anteriores a este, nosso projeto ser√° um
biblioteca:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Observe que Cargo gerou <em>src/lib.rs</em> em vez de <em>src/main.rs</em>. Dentro de
<em>src/lib.rs</em> encontraremos o seguinte:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo cria um teste de exemplo para nos ajudar a come√ßar nossa biblioteca, em vez de
o bin√°rio ‚ÄúHello, world!‚Äù que recebemos quando usamos a op√ß√£o <code>--bin</code>. Olharemos
a sintaxe <code>#[]</code> e <code>mod tests</code> no ‚ÄúUsando <code>super</code> para Acessar um
M√≥dulo Pai‚Äù mais adiante neste cap√≠tulo, mas por agora, deixe este c√≥digo
na parte inferior de <em>src/lib.rs</em>.</p>
<p>Como n√£o temos um arquivo <em>src/main.rs</em>, n√£o h√° nada para ser executado pelo Cargo
com o comando <code>cargo run</code>. Portanto, usaremos o comando  <code>cargo build</code>
para compilar o c√≥digo da nossa biblioteca.</p>
<p>Examinaremos diferentes op√ß√µes para organizar o c√≥digo da sua biblioteca que ser√£o
adequados em uma variedade de situa√ß√µes, dependendo da inten√ß√£o do c√≥digo.</p>
<a class="header" href="print.html#defini√ß√µes-do-m√≥dulo" id="defini√ß√µes-do-m√≥dulo"><h3>Defini√ß√µes do M√≥dulo</h3></a>
<p>Para a nossa biblioteca de rede <code>communicator</code>, primeiro definiremos um m√≥dulo chamado
<code>network</code> que cont√©m a defini√ß√£o de uma fun√ß√£o chamada<code>connect</code>. Cada
defini√ß√£o de m√≥dulo em Rust come√ßa com a palavra-chave <code>mod</code>. Adicione este c√≥digo ao
in√≠cio do arquivo <em>src/lib.rs</em>, acima do c√≥digo de teste:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Ap√≥s a palavra-chave <code>mod</code>, colocamos o nome do m√≥dulo, <code>network</code> e, em seguida, um
bloco de c√≥digo entre chaves. Tudo dentro deste bloco est√° dentro do
namespace <code>network</code>. Neste caso, temos uma √∫nica fun√ß√£o, <code>connect</code>. Se n√≥s
quisermos chamar essa fun√ß√£o do c√≥digo fora do m√≥dulo <code>network</code>, n√≥s
precisaremos especificar o m√≥dulo e usar a sintaxe do namespace <code>::</code>, assim:
<code>network::connect()</code> em vez de apenas <code>connect()</code>.</p>
<p>Tamb√©m podemos ter m√∫ltiplos m√≥dulos, lado a lado, no mesmo arquivo <em>src/lib.rs</em>.
Por exemplo, para ter mais um m√≥dulo <code>client</code> que possui uma fun√ß√£o chamada <code>connect</code>
, podemos adicion√°-lo como mostrado na Listagem 7-1:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-1: O m√≥dulo <code>network</code> e o m√≥dulo <code>client</code>
definidos lado a lado em <em>src/lib.rs</em> </span></p>
<p>Agora, temos uma fun√ß√£o <code>network::connect</code> e uma fun√ß√£o <code>client::connect</code>.
Estas podem ter funcionalidades completamente diferentes, e os nomes das fun√ß√µes
n√£o est√£o em conflito entre si porque est√£o em m√≥dulos diferentes.</p>
<p>Nesse caso, como estamos construindo uma biblioteca, o arquivo que serve como
ponto de entrada para construir nossa biblioteca √© <em>src/lib.rs</em>. No entanto, em rela√ß√£o a
cria√ß√£o de m√≥dulos, n√£o h√° nada de especial sobre <em>src/lib.rs</em>. Poder√≠amos tamb√©m
criar m√≥dulos em <em>src/main.rs</em> para um crate bin√°rio da mesma forma que n√≥s
criamos m√≥dulos em <em>src/lib.rs</em> para o crate de biblioteca. Na verdade, podemos colocar m√≥dulos
dentro de m√≥dulos, o que pode ser √∫til √† medida que seus m√≥dulos crescem para manter juntas
funcionalidades relacionadas e separar funcionalidades n√£o relacionadas. A
escolha de como voc√™ organiza seu c√≥digo depende do que voc√™ pensa sobre a
rela√ß√£o entre as partes do seu c√≥digo. Por exemplo, o c√≥digo <code>client</code>
e a fun√ß√£o <code>connect</code> podem ter mais sentido para os usu√°rios de nossa biblioteca se
eles estivessem dentro do namespace <code>network</code>, como na Listagem 7-2:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-2: Movendo o m√≥dulo <code>client</code> para dentro do
m√≥dulo <code>network</code></span></p>
<p>No seu arquivo <em>src/lib.rs</em>, substitua as defini√ß√µes <code>mod network</code> e <code>mod client</code>
pelas da Listagem 7-2, que possuem o m√≥dulo <code>client</code> como um
m√≥dulo interno da <code>network</code>. Agora temos as fun√ß√µes <code>network::connect</code> e
<code>network::client::connect</code>: novamente, as duas fun√ß√µes denominadas <code>connect</code> n√£o conflitam
uma com a outra porque elas est√£o em diferentes namespaces.</p>
<p>Desta forma, os m√≥dulos formam uma hierarquia. O conte√∫do de <em>src/lib.rs</em> est√° no
n√≠vel superior mais alto, e os subm√≥dulos est√£o em n√≠veis mais baixos. Aqui est√°
a nossa organiza√ß√£o quando pensada de forma hier√°rquica na Listagem 7-1:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ network
 ‚îî‚îÄ‚îÄ client
</code></pre>
<p>E aqui est√° a hierarquia correspondente ao exemplo na Listagem 7-2:</p>
<pre><code class="language-text">communicator
 ‚îî‚îÄ‚îÄ network
     ‚îî‚îÄ‚îÄ client
</code></pre>
<p>Conforme a hierarquia mostrada na Listagem 7-2, <code>client</code> √© um filho do m√≥dulo <code>network</code>
em vez de um irm√£o. Projetos mais complicados podem ter muitos m√≥dulos, √© necess√°rio
organiz√°-los logicamente para mant√™-los sob controle. O que &quot;logicamente&quot; significa em
seu projeto fica a seu crit√©rio, e depende do que voc√™ e os usu√°rios da sua biblioteca
pensam sobre o dom√≠nio do seu projeto. Use as t√©cnicas mostradas
aqui para criar m√≥dulos lado a lado e m√≥dulos aninhados em qualquer estrutura que
voc√™ queira.</p>
<a class="header" href="print.html#movendo-m√≥dulos-para-outros-arquivos" id="movendo-m√≥dulos-para-outros-arquivos"><h3>Movendo M√≥dulos para Outros Arquivos</h3></a>
<p>Os m√≥dulos formam uma estrutura hier√°rquica, bem parecida com outra estrutura computacional
que voc√™ conhece: sistemas de arquivos! Podemos usar o sistema de m√≥dulos do Rust juntamente com
v√°rios arquivos para dividir projetos Rust de forma que nem tudo resida em
<em>src/lib.rs</em> ou <em>src/main.rs</em>. Para este exemplo, vamos come√ßar com o c√≥digo em
Listagem 7-3:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 7-3: Tr√™s m√≥dulos, <code>client</code>, <code>network</code>, e
<code>network::server</code>, todos definidos em <em>src/lib.rs</em></span></p>
<p>O arquivo <em>src/lib.rs</em> possui esta hierarquia de m√≥dulos:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ client
 ‚îî‚îÄ‚îÄ network
     ‚îî‚îÄ‚îÄ server
</code></pre>
<p>Se esses m√≥dulos tivessem muitas fun√ß√µes, e elas estivessem se alongando muito,
seria dif√≠cil percorrer esse arquivo para encontrar o c√≥digo com que queremos
trabalhar. Como as fun√ß√µes est√£o aninhadas dentro de um ou mais blocos <code>mod</code>,
as linhas de c√≥digo dentro das fun√ß√µes come√ßar√£o a se alongar tamb√©m.
Estes seriam bons motivos para separar os m√≥dulos <code>client</code>, <code>network</code>, e <code>server</code>
de <em>src/lib.rs</em> e coloc√°-los em seus pr√≥prios arquivos.</p>
<p>Primeiro, substitua o c√≥digo do m√≥dulo <code>client</code> por apenas a declara√ß√£o do
m√≥dulo <code>client</code>, para que seu <em>src/lib.rs</em> se pare√ßa com o c√≥digo mostrado na Listagem 7-4:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption"> Listagem 7-4: Extraindo o conte√∫do do m√≥dulo <code>client</code>, mas deixando a declara√ß√£o em <em>src/lib.rs</em> </span></p>
<p>Ainda estamos <em>declarando</em> o m√≥dulo <code>client</code> aqui, mas ao substituir o bloco
por um ponto e v√≠rgula, estamos dizendo ao Rust para que procure, em outro local, o c√≥digo
definido no escopo do m√≥dulo <code>client</code>. Em outras palavras, a linha <code>mod client;</code> significa:</p>
<pre><code class="language-rust ignore">mod client {
    // conte√∫do de client.rs
}
</code></pre>
<p>Agora precisamos criar o arquivo externo com o nome do m√≥dulo. Crie um
arquivo <em>client.rs</em> em <em>src/</em> e abra-o. Em seguida digite o seguinte,
que √© a fun√ß√£o <code>connect</code> do m√≥dulo <code>client</code> que foi
removida na etapa anterior:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Observe que n√£o precisamos de uma declara√ß√£o <code>mod</code> neste arquivo porque j√° fizemos
a declara√ß√£o do m√≥dulo <code>client</code> com <code>mod</code> em <em>src/lib.rs</em>. Este arquivo apenas
fornece o <em>conte√∫do</em> do m√≥dulo <code>client</code>. Se colocarmos um <code>mod client</code> aqui,
n√≥s estar√≠amos dando ao m√≥dulo <code>client</code> seu pr√≥prio subm√≥dulo chamado <code>client</code>!</p>
<p>Rust s√≥ sabe olhar em <em>src/lib.rs</em> por padr√£o. Se quisermos adicionar mais
arquivos para o nosso projeto, precisamos dizer ao Rust em <em>src/lib.rs</em> para procurar em outros
arquivos; √© por isso que <code>mod client</code> precisa ser definido em <em>src/lib.rs</em> e n√£o pode
ser definido em <em>src/client.rs</em>.</p>
<p>Agora, o projeto deve compilar com sucesso, embora voc√™ obtenha alguns
warnings (avisos). Lembre-se de usar <code>cargo build</code>, em vez de <code>cargo run</code>, porque temos
um crate de biblioteca em vez de um crate bin√°rio:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>Esses <em>warnings</em> nos dizem que temos fun√ß√µes que nunca s√£o usadas. N√£o se preocupe
com esses <em>warnings</em> por enquanto; vamos abord√°-los mais adiante neste cap√≠tulo, na
se√ß√£o ‚ÄúControlando a visibilidade com <code>pub</code>‚Äù. A boa not√≠cia √© que eles s√£o apenas
<em>warnings</em>; nosso projeto foi constru√≠do com sucesso!</p>
<p>Em seguida, vamos extrair o m√≥dulo <code>network</code> em seu pr√≥prio arquivo usando o mesmo
procedimento. Em <em>src/lib.rs</em>, exclua o corpo do m√≥dulo <code>network</code> e adicione um
ponto e v√≠rgula √† declara√ß√£o, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Em seguida, crie um novo arquivo <em>src/network.rs</em> e digite o seguinte:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Observe que ainda temos uma declara√ß√£o <code>mod</code> dentro deste arquivo de m√≥dulo; isto √©
porque ainda queremos que <code>server</code> seja um subm√≥dulo de <code>network</code>.</p>
<p>Execute <code>cargo build</code> novamente. Sucesso! Temos mais um m√≥dulo para extrair: <code>server</code>.
Como ele √© um subm√≥dulo - ou seja, um m√≥dulo dentro de outro - nossa t√°tica atual de
extrair um m√≥dulo para um arquivo com o nome do m√≥dulo n√£o funcionar√°. Iremos
tentar, de qualquer maneira, para que voc√™ possa ver o erro. Primeiro, altere o arquivo <em>src/network.rs</em> colocando
<code>mod server;</code> no lugar do conte√∫do do m√≥dulo <code>server</code>:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, crie um arquivo <em>src/server.rs</em> e insira o conte√∫do do m√≥dulo <code>server</code>
que extra√≠mos:</p>
<p><span class="filename">Arquivo: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Quando tentamos <code>cargo build</code>, obteremos o erro mostrado na Listagem 7-5:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listagem 7-5: Erro ao tentar extrair o subm√≥dulo <code>server</code>
em <em>src/server.rs</em> </span></p>
<p>O erro diz que n√£o podemos declarar um novo m√≥dulo neste local (<code>cannot declare a new module at this location</code>)
e est√° apontando para a linha <code>mod server</code>; em <em>src/network.rs</em>. Ent√£o <em>src/network.rs</em> √©
diferente de <em>src/lib.rs</em> de alguma forma: continue lendo para entender o porqu√™.</p>
<p>A nota no meio da Listagem 7-5 √© realmente muito √∫til,
porque ela aponta para algo de que n√£o falamos ainda:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>(<strong>Tradu√ß√£o:</strong> talvez mover este m√≥dulo network para o seu pr√≥prio diret√≥rio via <code>network/mod.rs</code>)</p>
<p>Em vez de continuar a seguir o mesmo padr√£o de nomea√ß√£o de arquivo usado
anteriormente, podemos fazer o que a nota sugere:</p>
<ol>
<li>Crie um novo <em>diret√≥rio</em> chamado <em>network</em>, o nome do m√≥dulo pai.</li>
<li>Mova o arquivo <em>src/network.rs</em> para o novo diret√≥rio <em>network</em> e
¬†¬†¬† renomeie para <em>src/network/mod.rs</em>.</li>
<li>Mova o arquivo de subm√≥dulo <em>src/server.rs</em> para o diret√≥rio <em>network</em>.</li>
</ol>
<p>Aqui est√£o os comandos para executar estas etapas:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>Agora, quando tentamos executar <code>cargo build</code>, a compila√ß√£o funcionar√° (embora ainda teremos
avisos). O layout dos nossos m√≥dulos ainda √© exatamente o
mesmo de quando t√≠nhamos todo o c√≥digo em <em>src/lib.rs</em> na Listagem 7-3:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ client
 ‚îî‚îÄ‚îÄ network
     ‚îî‚îÄ‚îÄ server
</code></pre>
<p>O layout dos arquivos correspondentes agora ficou assim:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ client.rs
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ network
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ       ‚îî‚îÄ‚îÄ server.rs
</code></pre>
<p>Quando quer√≠amos extrair o m√≥dulo <code>network::server</code>, por que precis√°vamos
tamb√©m mudar o arquivo <em>src/network.rs</em> para o arquivo <em>src/network/mod.rs</em> e colocar
o c√≥digo de <code>network::server</code> no diret√≥rio <em>network</em> em
<em>src/network/server.rs</em> em vez de apenas extrair o
m√≥dulo <code>network::server</code> em <em>src/server.rs</em>? O motivo √© que Rust n√£o
ser√° capaz de reconhecer que <code>server</code> deveria ser um subm√≥dulo de <code>network</code>
se o arquivo <em>server.rs</em> estiver no diret√≥rio <em>src</em>. Para esclarecer o comportamento de Rust
aqui, consideremos um exemplo diferente com a seguinte hierarquia de m√≥dulos,
onde todas as defini√ß√µes est√£o em <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ client
 ‚îî‚îÄ‚îÄ network
     ‚îî‚îÄ‚îÄ client
</code></pre>
<p>Neste exemplo, temos novamente tr√™s m√≥dulos : <code>client</code>,<code>network</code>, e
<code>network::client</code>. Seguindo os mesmos passos anteriores para extrair
m√≥dulos em arquivos, poder√≠amos criar <em>src/client.rs</em> para o m√≥dulo <code>client</code>.
Para o m√≥dulo <code>network</code>, poder√≠amos criar <em>src/network.rs</em>. Mas n√£o ser√≠amos
capazes de extrair o m√≥dulo <code>network::client</code> para um arquivo <em>src/client.rs</em>
porque ele j√° existe para o m√≥dulo <code>client</code> de n√≠vel superior! Se pud√©ssemos colocar
o c√≥digo para <em>ambos</em> os m√≥dulos <code>client</code> e<code>network::client</code> no arquivo
<em>src/client.rs</em>, Rust n√£o teria nenhuma maneira de saber se o c√≥digo era
para <code>client</code> ou para <code>network::client</code>.</p>
<p>Portanto, para extrair um arquivo para o subm√≥dulo <code>network::client</code> do
m√≥dulo <code>network</code>, precisamos criar um diret√≥rio para o m√≥dulo <code>network</code>
em vez de um arquivo <em>src/network.rs</em>. O c√≥digo que est√° no m√≥dulo <code>network</code>
entra no arquivo <em>src/network/mod.rs</em>, e o subm√≥dulo
<code>network::client</code> pode ter seu pr√≥prio arquivo <em>src/network/client.rs</em>. Agora o
o n√≠vel superior <em>src/client.rs</em> √© inequivocamente o c√≥digo que pertence ao
m√≥dulo <code>client</code>.</p>
<a class="header" href="print.html#regras-dos-m√≥dulos-e-seus-arquivos" id="regras-dos-m√≥dulos-e-seus-arquivos"><h3>Regras dos M√≥dulos e Seus Arquivos</h3></a>
<p>Vamos resumir as regras dos m√≥dulos em rela√ß√£o aos arquivos:</p>
<ul>
<li>Se um m√≥dulo chamado <code>foo</code> n√£o possui subm√≥dulos, voc√™ deve colocar as declara√ß√µes
¬†¬† para <code>foo</code> em um arquivo chamado <em>foo.rs</em>.</li>
<li>Se um m√≥dulo chamado <code>foo</code> possui subm√≥dulos, voc√™ deve colocar as declara√ß√µes
¬†¬† para <code>foo</code> em um arquivo chamado <em>foo/mod.rs</em>.</li>
</ul>
<p>Essas regras se aplicam de forma recursiva, ent√£o, se um m√≥dulo chamado <code>foo</code> tiver um subm√≥dulo chamado
<code>bar</code> e<code>bar</code> n√£o possui subm√≥dulos, voc√™ deve ter os seguintes arquivos
no seu diret√≥rio <em>src</em>:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ foo
‚îÇ   ‚îú‚îÄ‚îÄ bar.rs (cont√©m as declara√ß√µes em `foo::bar`)
‚îÇ   ‚îî‚îÄ‚îÄ mod.rs (cont√©m as declara√ß√µes em `foo`, incluindo `mod bar`)
</code></pre>
<p>Os m√≥dulos devem ser declarados no arquivo do m√≥dulo pai usando a palavra-chave <code>mod</code>.</p>
<p>Em seguida, vamos falar sobre a palavra-chave <code>pub</code> e nos livrar dessas warnings!</p>
<a class="header" href="print.html#controlando-a-visibilidade-com-pub" id="controlando-a-visibilidade-com-pub"><h2>Controlando a Visibilidade com <code>pub</code></h2></a>
<p>Resolvemos as mensagens de erro mostradas na Listagem 7-5 movendo o c√≥digo de <code>network</code> e
<code>network::server</code> para  os arquivos <em>src/network/mod.rs</em> e
<em>src/network/server.rs</em>, respectivamente. Nesse ponto, <code>cargo build</code> era
capaz de construir nosso projeto, mas ainda recebemos mensagens de <em>warning</em> sobre as
fun√ß√µes <code>client::connect</code>, <code>network::connect</code>, e <code>network::server::connect</code>
n√£o estarem em uso:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Ent√£o, por que estamos recebendo esses warnings(avisos)? Afinal, estamos construindo uma biblioteca
com fun√ß√µes que se destinam a ser usadas pelos nossos <em>usu√°rios</em>, n√£o necessariamente por
n√≥s dentro de nosso pr√≥prio projeto, por isso n√£o deveria importar que essas fun√ß√µes <code>connect</code>
n√£o sejam utilizadas. O ponto de cri√°-las √© que elas ser√£o usadas por
outro projeto, n√£o o nosso.</p>
<p>Para entender por que esse programa invoca esses warnings(avisos), vamos tentar usar a
biblioteca <code>connect</code> de outro projeto, chamando-a externamente. Para fazer isso,
vamos criar um crate bin√°rio no mesmo diret√≥rio que o nosso crate de biblioteca
inserindo um arquivo <em>src/main.rs</em> que cont√©m esse c√≥digo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p>Usamos o comando <code>extern crate</code> para trazer o crate de biblioteca <code>communicator</code>
para o escopo. Nosso pacote agora cont√©m <em>duas</em> crates. Cargo trata <em>src/main.rs</em>
como um arquivo raiz de um crate bin√°rio, que √© separado do crate de biblioteca existente
cujo arquivo raiz √© <em>src/lib.rs</em>. Esse padr√£o √© bastante comum para
projetos execut√°veis: a maioria das funcionalidades est√° em um crate de biblioteca e o crate bin√°rio
usa esse crate de biblioteca. Como resultado, outros programas tamb√©m podem usar o
crate de biblioteca, e √© uma boa separa√ß√£o de responsabilidades.</p>
<p>Do ponto de vista de um crate fora da biblioteca <code>communicator</code>
todos os m√≥dulos que criamos est√£o dentro de um m√≥dulo que tem o mesmo
nome como do crate, <code>communicator</code>. Chamamos o m√≥dulo de n√≠vel superior de um
crate de <em>m√≥dulo raiz</em>.</p>
<p>Observe tamb√©m que, mesmo que estejamos usando um crate externo dentro de um subm√≥dulo do nosso
projeto, o <code>extern crate</code> deve entrar em nosso m√≥dulo raiz (ent√£o em <em>src/main.rs</em>
ou <em>src/lib.rs</em>). Ent√£o, em nossos subm√≥dulos, podemos consultar itens de crates externos
como se os itens fossem m√≥dulos de n√≠vel superior.</p>
<p>Agora, nosso crate bin√°rio apenas chama a fun√ß√£o <code>connect</code> da nossa biblioteca do
m√≥dulo <code>client</code>. No entanto, invocar agora <code>cargo build</code> nos dar√° um erro
ap√≥s os <em>warnings</em>:</p>
<pre><code class="language-text">error[E0603]: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Ah ha! Este erro nos diz que o m√≥dulo <code>client</code> √© privado, que √© o
cerne das advert√™ncias. √â tamb√©m a primeira vez em que nos encontramos com os conceitos de
<em>p√∫blico</em> e <em>privado</em> no contexto do Rust. O estado padr√£o de todos os c√≥digos em
Rust √© privado: ningu√©m mais tem permiss√£o para usar o c√≥digo. Se voc√™ n√£o usar uma
fun√ß√£o privada dentro do seu programa, como ele √© o √∫nico c√≥digo
permitido a usar essa fun√ß√£o, Rust ir√° avis√°-lo de que a fun√ß√£o
n√£o foi utilizada.</p>
<p>Depois de especificar que uma fun√ß√£o como <code>client::connect</code> √© p√∫blica, n√£o s√≥
ser√° permitida a nossa chamada para essa fun√ß√£o a partir de nosso crate bin√°rio, mas o
warning(aviso) de que a fun√ß√£o n√£o √© utilizada ir√° desaparecer. Marcar uma fun√ß√£o como p√∫blica
permite ao Rust saber que a fun√ß√£o ser√° usada por c√≥digo fora do nosso programa.
Rust considera que agora √© poss√≠vel que a
fun√ß√£o esteja &quot;sendo usada&quot;. Assim, quando uma fun√ß√£o √© marcada como p√∫blica, Rust n√£o
exige que seja usada em nosso programa e deixar√° de avisar que a fun√ß√£o
n√£o √© utilizada.</p>
<a class="header" href="print.html#fazendo-uma-fun√ß√£o-p√∫blica" id="fazendo-uma-fun√ß√£o-p√∫blica"><h3>Fazendo uma Fun√ß√£o P√∫blica</h3></a>
<p>Para dizer ao Rust que torne p√∫blica uma fun√ß√£o, adicionamos a palavra-chave <code>pub</code> ao in√≠cio
da declara√ß√£o. Nos focaremos em corrigir o <em>warning</em> que indica
<code>client::connect</code> n√£o foi utilizado por enquanto, assim como o erro <code>module `client` is private</code> (<code>m√≥dulo `client` √© privado</code>) do nosso crate bin√°rio. Modifique <em>src/lib.rs</em> para tornar
o m√≥dulo <code>client</code> p√∫blico, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p>A palavra-chave <code>pub</code> √© colocada logo antes do <code>mod</code>. Vamos tentar fazer o build novamente:</p>
<pre><code class="language-text">error[E0603]: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Opa! Temos um erro diferente! Sim, mensagens diferentes de erro
s√£o motivo para comemorar. O novo erro mostra que que a fun√ß√£o <code>connect</code> √© privada
(function <code>connect</code> is private), ent√£o vamos editar <em>src/client.rs</em> para torn√°-la p√∫blica tamb√©m:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>Agora execute <code>cargo build</code> novamente:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>O c√≥digo compila, e o warning(aviso) sobre <code>client::connect</code> n√£o estar em uso
se foi!</p>
<p>Os avisos de c√≥digo n√£o utilizados nem sempre indicam que um item no seu c√≥digo precisa
se tornar p√∫blico: se voc√™ <em>n√£o</em> quiser que essas fun√ß√µes fa√ßam parte de sua
API p√∫blica, <em>warnings</em> de c√≥digo n√£o utilizado podem alert√°-lo de que esses c√≥digos n√£o s√£o mais necess√°rios,
e que podem ser exclu√≠dos com seguran√ßa. Eles tamb√©m podem estar alertando voc√™ para um bug, caso voc√™ tivesse apenas
acidentalmente removido todos os lugares dentro da sua biblioteca onde esta fun√ß√£o √©
chamada.</p>
<p>Mas neste caso, n√≥s <em>queremos</em> que as outras duas fun√ß√µes fa√ßam parte da nossa
API p√∫blica do crate, ent√£o vamos marc√°-las como <code>pub</code> tamb√©m para nos livrar dos
<em>warnings</em> remanescentes. Modifique <em>src/network/mod.rs</em> dessa forma:</p>
<p><span class="filename">Arquivo: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, compile o c√≥digo:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / pub fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Hmmm, ainda estamos recebendo um <em>warning</em> de fun√ß√£o n√£o utilizada, embora
<code>network::connect</code> esteja marcada como <code>pub</code>. A raz√£o √© que a fun√ß√£o √© p√∫blica
dentro do m√≥dulo, mas o m√≥dulo <code>network</code> na qual a fun√ß√£o reside n√£o √©
p√∫blico. Estamos trabalhando a partir do interior da biblioteca desta vez, enquanto que
com <code>client::connect</code> trabalhamos de fora. Precisamos mudar
<em>src/lib.rs</em> para tornar <code>network</code> p√∫blica tamb√©m, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>Agora, quando compilamos, esse aviso desapareceu:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>Apenas um warning(aviso) permanece. Tente consertar isso por conta pr√≥pria!</p>
<a class="header" href="print.html#regras-de-privacidade" id="regras-de-privacidade"><h3>Regras de Privacidade</h3></a>
<p>No geral, estas s√£o as regras para a visibilidade do item:</p>
<ol>
<li>Se um item for p√∫blico, ele pode ser acessado atrav√©s de qualquer um dos seus m√≥dulos pais.</li>
<li>Se um item √© privado, ele s√≥ pode ser acessado por seu m√≥dulo pai imediato e
¬†¬†¬†qualquer um dos m√≥dulos filhos do pai.</li>
</ol>
<a class="header" href="print.html#exemplos-de-privacidade" id="exemplos-de-privacidade"><h3>Exemplos de Privacidade</h3></a>
<p>Vejamos mais alguns exemplos de privacidade para obter alguma pr√°tica. Crie um novo
projeto de biblioteca e digite o c√≥digo da Listagem 7-6 no arquivo
<em>src/lib.rs</em> desse novo projeto:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">Lista 7-6: Exemplos de fun√ß√µes p√∫blicas e privadas,
alguns dos quais est√£o incorretos</span></p>
<p>Antes de tentar compilar este c√≥digo, tente um palpite sobre quais linhas na
fun√ß√£o <code>try_me</code> ter√° erros. Em seguida, tente compilar o c√≥digo para ver se
voc√™ estava certo e leia sobre a discuss√£o dos erros!</p>
<a class="header" href="print.html#olhando-para-os-erros" id="olhando-para-os-erros"><h4>Olhando para os Erros</h4></a>
<p>A fun√ß√£o <code>try_me</code> est√° no m√≥dulo raiz do nosso projeto. O m√≥dulo chamado
<code>outermost</code> √© privado, mas a segunda regra de privacidade afirma que a fun√ß√£o <code>try_me</code>
pode acessar o m√≥dulo <code>outermost</code> porque <code>outermost</code> est√° no
m√≥dulo atual (raiz), bem como <code>try_me</code>.</p>
<p>A chamada para <code>outermost::middle_function</code> funcionar√° porque <code>middle_function</code> √©
p√∫blica e <code>try_me</code> est√° acessando <code>middle_function</code> atrav√©s do seu m√≥dulo pai
<code>outermost</code>. Determinamos no par√°grafo anterior que este m√≥dulo √©
acess√≠vel.</p>
<p>A chamada para <code>outermost::middle_secret_function</code> causar√° um erro de compila√ß√£o.
<code>middle_secret_function</code> √© privado, ent√£o a segunda regra se aplica. O m√≥dulo raiz
n√£o √© nem o m√≥dulo atual de <code>middle_secret_function</code> (que seria o <code>outermost</code>),
nem um m√≥dulo filho do m√≥dulo atual de <code>middle_secret_function</code>.</p>
<p>O m√≥dulo denominado <code>inside</code> √© privado e n√£o tem m√≥dulos filhos, portanto, ele s√≥ pode
ser acessado pelo seu m√≥dulo atual <code>outermost</code>. Isso significa que a fun√ß√£o <code>try_me</code>
n√£o tem permiss√£o de chamar <code>outermost::inside::inner_function</code> ou
<code>outermost::inside::secret_function</code>.</p>
<a class="header" href="print.html#reparando-os-erros" id="reparando-os-erros"><h4>Reparando os Erros</h4></a>
<p>Aqui est√£o algumas sugest√µes para alterar o c√≥digo na tentativa de corrigir os
erros. Antes de tentar cada uma, tente adivinhar se ela ir√° consertar os
erros e, em seguida, compile o c√≥digo para ver se voc√™ est√° certo ou n√£o, usando as
regras de privacidade para entender o porqu√™.</p>
<ul>
<li>E se o m√≥dulo <code>inside</code> fosse p√∫blico?</li>
<li>E se <code>outermost</code> fosse p√∫blico e <code>inside</code> fosse privado?</li>
<li>E se, no corpo de <code>inner_function</code>, voc√™ chamasse o
¬†¬†<code>::outermost::middle_secret_function()</code>? (Os dois dois pontos no in√≠cio significam
¬†¬† que queremos consultar os m√≥dulos a partir do m√≥dulo raiz.)</li>
</ul>
<p>Sinta-se livre para projetar mais experimentos que lhe vierem √† mente!</p>
<p>Em seguida, vamos falar sobre trazer itens ao escopo com a palavra-chave <code>use</code>.</p>
<a class="header" href="print.html#referindo-se-a-nomes-em-m√≥dulos-diferentes" id="referindo-se-a-nomes-em-m√≥dulos-diferentes"><h2>Referindo-se a Nomes em M√≥dulos Diferentes</h2></a>
<p>Vimos como chamar fun√ß√µes definidas dentro de um m√≥dulo usando o nome do m√≥dulo
como parte da chamada, como na chamada para a fun√ß√£o <code>nested_modules</code> mostrada
aqui na Listagem 7-7:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">Listagem 7-7: Chamando uma fun√ß√£o especificando completamente
o caminho do m√≥dulo que a cerca</span></p>
<p>Como voc√™ pode ver, referir-se ao nome totalmente qualificado pode ficar bastante longo.
Felizmente, Rust tem uma palavra-chave para tornar estas chamadas mais concisas.</p>
<a class="header" href="print.html#trazendo-nomes-no-escopo-com-a-palavra-chave-use" id="trazendo-nomes-no-escopo-com-a-palavra-chave-use"><h3>Trazendo Nomes no Escopo com a Palavra-Chave <code>use</code></h3></a>
<p>A palavra-chave <code>use</code> de Rust encurta as chamadas de fun√ß√£o longas, trazendo os m√≥dulos e
a fun√ß√£o que deseja chamar para o escopo. Aqui est√° um exemplo de como trazer o
m√≥dulo <code>a::series::of</code> para dentro do escopo raiz de um crate bin√°rio:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p>A linha <code>use a::series::of;</code> significa que, em vez de usar todo o caminho
<code>a::series::of</code> sempre que quisermos nos referir ao m√≥dulo <code>of</code>, podemos usar
<code>of</code>.</p>
<p>A palavra-chave <code>use</code> traz apenas o que especificamos no escopo: ela n√£o
leva os filhos dos m√≥dulos ao escopo. √â por isso que ainda temos que usar
<code>of::nested_modules</code> quando queremos chamar a fun√ß√£o <code>nested_modules</code>.</p>
<p>Poder√≠amos ter escolhido trazer a fun√ß√£o para o escopo, em vez de especificar a fun√ß√£o
no <code>use</code> da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>Isso nos permite excluir todos os m√≥dulos e fazer refer√™ncia √† fun√ß√£o
diretamente.</p>
<p>Como as enums tamb√©m formam uma esp√©cie de <em>namespace</em>, assim como os m√≥dulos, podemos trazer
as variantes de uma enum para o escopo com <code>use</code> tamb√©m. Para qualquer tipo de declara√ß√£o de <code>use</code>
se voc√™ estiver trazendo v√°rios itens de um <em>namespace</em> para o escopo, voc√™ pode list√°-los
usando chaves e v√≠rgulas na √∫ltima posi√ß√£o, assim:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<p>N√≥s ainda estamos especificando o <em>namespace</em> <code>TrafficLight</code> para a variante <code>Green</code>
porque n√£o inclu√≠mos <code>Green</code> na declara√ß√£o <code>use</code>.</p>
<a class="header" href="print.html#trazendo-todos-os-nomes-para-o-escopo-com-um-glob" id="trazendo-todos-os-nomes-para-o-escopo-com-um-glob"><h3>Trazendo Todos os Nomes para o Escopo com um Glob</h3></a>
<p>Para trazer todos os itens de um <em>namespace</em> para o escopo ao mesmo tempo, podemos usar a sintaxe <code>*</code>, que √© chamada de <em>operador glob</em>. Este exemplo traz todas as variantes de uma enum ao escopo sem ter que listar cada uma especificamente:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p>O <code>*</code> trar√° para o escopo todos os itens vis√≠veis no <em>namespace</em> <code>TrafficLight</code>.
Voc√™ deve usar globs com modera√ß√£o: eles s√£o convenientes, mas isso pode
tamb√©m trazer mais itens do que se esperava e causar conflitos de nomea√ß√£o.</p>
<a class="header" href="print.html#usando-super-para-acessar-um-m√≥dulo-pai" id="usando-super-para-acessar-um-m√≥dulo-pai"><h3>Usando <code>super</code> para Acessar um M√≥dulo Pai</h3></a>
<p>Como vimos no in√≠cio deste cap√≠tulo, quando voc√™ cria um crate de biblioteca,
o Cargo faz um m√≥dulo <code>tests</code> para voc√™. Vamos ver isso em mais detalhes agora.
No seu projeto <code>communicator</code>, abra <em>src/lib.rs</em>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>O Cap√≠tulo 11 explica mais sobre testes, mas algumas partes deste exemplo devem fazer
sentido agora: temos um m√≥dulo chamado <code>tests</code> que se situa ao lado de nossos outros m√≥dulos
e cont√©m uma fun√ß√£o chamada <code>it_works</code>. Embora existam anota√ß√µes especiais,
o m√≥dulo <code>tests</code> √© apenas outro m√≥dulo! Ent√£o nossa hierarquia de m√≥dulos
se parece com isso:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ client
 ‚îú‚îÄ‚îÄ network
 |   ‚îî‚îÄ‚îÄ client
 ‚îî‚îÄ‚îÄ tests
</code></pre>
<p>Os testes servem para exercitar o c√≥digo dentro da nossa biblioteca, ent√£o vamos tentar chamar nossa
fun√ß√£o <code>client :: connect</code> a partir da fun√ß√£o<code>it_works</code>, mesmo que n√£o verefiquemos nenhuma
funcionalidade agora. Isso ainda n√£o funcionar√°:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Execute os testes invocando o comando <code>cargo test</code>:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>A compila√ß√£o falhou, mas por qu√™? N√£o precisamos colocar <code>communicator ::</code> em
frente da fun√ß√£o como fizemos em <em>src/main.rs</em> porque estamos definitivamente
dentro do crate da biblioteca <code>communicator</code> aqui. A raz√£o √© que os caminhos s√£o
sempre relativos ao m√≥dulo atual, que aqui √© <code>tests</code>. A √∫nica
exce√ß√£o est√° em uma instru√ß√£o <code>use</code>, onde os caminhos s√£o relativos √† crate raiz
por padr√£o. Nosso m√≥dulo <code>tests</code> precisa do m√≥dulo <code>client</code> no seu escopo!</p>
<p>Ent√£o, como podemos retroceder um m√≥dulo na hierarquia para chamar a
fun√ß√£o <code>client::connect</code> no m√≥dulo <code>tests</code>? No m√≥dulo <code>tests</code>, temos a op√ß√£o de
usar <code>::</code> na frente para indicar ao Rust que queremos come√ßar a partir da raiz
e listar todo o caminho, assim:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>Ou, podemos usar <code>super</code> para voltar um m√≥dulo na hierarquia a partir de nosso
m√≥dulo atual, assim:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>Essas duas op√ß√µes n√£o parecem t√£o diferentes neste exemplo, mas se voc√™ estiver
mais fundo em uma hierarquia de m√≥dulos, come√ßar sempre a partir da raiz tornaria
seu c√≥digo muito longo. Nesses casos, usar <code>super</code> para ir do m√≥dulo atual aos
m√≥dulos irm√£os √© um bom atalho. Al√©m disso, se voc√™ especificou o caminho a partir da
raiz em muitos lugares do seu c√≥digo e depois vai reorganizar seus m√≥dulos movendo
uma sub-√°rvore para outro lugar, voc√™ acabaria precisando atualizar o caminho em v√°rios
lugares, o que seria tedioso.</p>
<p>Tamb√©m seria chato ter que digitar <code>super ::</code> em cada teste, mas voc√™
j√° viu a ferramenta para essa solu√ß√£o: <code>use</code>! A funcionalidade <code>super ::</code>
altera o caminho que voc√™ d√° para <code>use</code>, tornando-o relativo ao m√≥dulo pai
em vez do m√≥dulo raiz.</p>
<p>Por estas raz√µes, especialmente no m√≥dulo <code>tests</code>, <code>use super::alguma_coisa</code> √©
geralmente a melhor solu√ß√£o. Ent√£o, agora nosso teste ficou assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Quando executarmos novamente <code>cargo test</code>, o teste passar√° e a primeira parte do
resultado do teste ser√° o seguinte:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#resumo-3" id="resumo-3"><h2>Resumo</h2></a>
<p>Agora voc√™ conhece algumas t√©cnicas novas para organizar o seu c√≥digo! Use estas t√©cnicas
para agrupar as funcionalidades relacionadas, evitar que os arquivos tornem-se muito longos, e
apresentar uma API p√∫blica arrumada para os usu√°rios da sua biblioteca.</p>
<p>Em seguida, analisaremos algumas estruturas de dados de cole√ß√µes na biblioteca padr√£o
que voc√™ pode usar em seu c√≥digo limpo e elegante!</p>
<a class="header" href="print.html#fundamental-collections" id="fundamental-collections"><h1>Fundamental Collections</h1></a>
<a class="header" href="print.html#vetores" id="vetores"><h2>Vetores</h2></a>
<p>O primeiro tipo que iremos ver √© <code>Vec&lt;T&gt;</code>, tamb√©m conhecido como <em>vetor</em>. Vetores
permitem guardar mais de um valor na mesma estrutura de dados que coloca todos
os valores um ao lado do outro na mem√≥ria. Vetores s√≥ podem guardar valores do
mesmo tipo. Eles s√£o √∫teis em situa√ß√µes onde h√° uma lista de itens, como
as linha de texto em um arquivo ou pre√ßos de itens em um carrinho de compras.</p>
<a class="header" href="print.html#criando-um-novo-vetor" id="criando-um-novo-vetor"><h3>Criando um Novo Vetor</h3></a>
<p>Para criar um novo vetor, vazio, chamamos a fun√ß√£o <code>Vec::new</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p>Note que adicionamos uma anota√ß√£o de tipo aqui. Como n√£o estamos inserindo nenhum valor
no vetor, Rust n√£o sabe o tipo de elementos que ir√° guardar.
Isto √© um ponto importante. Vetores s√£o homog√™neos: eles podem guardar muitos
valores, mas todos esses valores devem ser do mesmo tipo. Vetores s√£o implementados
usando gen√©ricos, onde o cap√≠tulo 10 ir√° cobrir como usar em seus tipos. Por
agora, tudo o que precisa saber √© que o tipo <code>Vec</code> fornecido pela biblioteca
padr√£o pode conter qualquer tipo, e quando um <code>Vec</code> espec√≠fico possui um tipo espec√≠fico, o
tipo vai dentro de <code>&lt; &gt;</code>. Falamos para Rust que <code>Vec</code> em <code>v</code> guardar√°
elementos do tipo <code>i32</code>.</p>
<p>No c√≥digo real, a Rust pode inferir o tipo de valor que queremos armazenar uma vez que inserimos
valores, ent√£o voc√™ raramente precisa fazer essa anota√ß√£o de tipo. √â mais comum
criar um <code>Vec</code> que possui valores iniciais, e o Rust fornece a macro <code>vec!</code> por
conveni√™ncia. A macro criar√° um novo <code>Vec</code> que cont√©m os valores que damos
. Isso criar√° um novo <code>Vec &lt;i32&gt;</code> que cont√©m os valores <code>1</code>,<code>2</code> e <code>3</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p>Como n√≥s damos valores iniciais  <code>i32</code>, Rust pode inferir que o tipo de <code>v</code>
√© <code>Vec &lt;i32&gt;</code>, e a anota√ß√£o de tipo n√£o √© necess√°ria. Vejamos a seguir como
modificar um vetor.</p>
<a class="header" href="print.html#modificando-um-vetor" id="modificando-um-vetor"><h3>Modificando um Vetor</h3></a>
<p>Para criar um vetor e adicionar elementos a ele, podemos usar o m√©todo <code>push</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p>Como qualquer vari√°vel que discutimos no Cap√≠tulo 3, se quisermos poder
alterar seu valor, precisamos faz√™-lo mut√°vel com a palavra-chave <code>mut</code>. Os
n√∫meros que inserimos s√£o todos do tipo <code>i32</code>, e Rust infere isso dos
dados, por isso n√£o precisamos da anota√ß√£o <code>Vec &lt;i32&gt;</code>.</p>
<a class="header" href="print.html#descartar-um-vetor-descarta-seus-elementos" id="descartar-um-vetor-descarta-seus-elementos"><h3>Descartar um Vetor Descarta seus Elementos</h3></a>
<p>Como qualquer outro <code>struct</code>, um vetor ser√° liberado quando ele sair do escopo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // use as informa√ß√µes em v

} // &lt;- v sai do escopo e √© liberado aqui
#}</code></pre></pre>
<p>Quando o vetor √© descartado, todos os seus conte√∫dos tamb√©m ser√° descartado, o que significa
esses inteiros que ele cont√©m ser√£o limpos. Isso pode parecer um
ponto direto, mas pode ficar um pouco mais complicado quando come√ßamos a
introduzir refer√™ncias aos elementos do vetor. Vamos abordar isso em seguida!</p>
<a class="header" href="print.html#lendo-elementos-do-vetor" id="lendo-elementos-do-vetor"><h3>Lendo Elementos do Vetor</h3></a>
<p>Agora que voc√™ sabe como criar, atualizar e destruir vetores,
saber ler o seu conte√∫do √© um bom passo seguinte. Existem duas maneiras de fazer refer√™ncia a
valores armazenados em um vetor. Nos exemplos, anotamos os tipos de
valores que s√£o retornados dessas fun√ß√µes para maior clareza.</p>
<p>Este exemplo mostra os dois m√©todos de acesso a um valor em um vetor com
sintaxe de indexa√ß√£o ou o m√©todo <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<p>H√° algumas coisas a serem observadas aqui. Primeiro, que usamos o valor do √≠ndice de <code>2</code>
para obter o terceiro elemento: os vetores s√£o indexados por n√∫mero, come√ßando em zero.
Em segundo lugar, as duas maneiras diferentes de obter o terceiro elemento s√£o: usando <code>&amp;</code> e
<code>[]</code>, que nos d√° uma refer√™ncia, ou usando o m√©todo <code>get</code> com o √≠ndice
passado como um argumento, o que nos d√° uma <code>Option&lt;&amp;T&gt;</code>.</p>
<p>A raz√£o pela qual Rust tem duas maneiras de fazer refer√™ncia a um elemento √© para que voc√™ possa escolher
como o programa se comporta quando voc√™ tenta usar um valor de √≠ndice para o qual
o vetor n√£o tem um elemento correspondente. Por exemplo, o que um programa deve fazer se tiver
um vetor que cont√©m cinco elementos, ent√£o tenta acessar um elemento no √≠ndice 100
dessa maneira:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p>Quando voc√™ executar isso, voc√™ ver√° que com o primeiro m√©todo <code>[]</code>, Rust ir√°
causar um <code>panic!</code> quando um elemento inexistente √© referenciado. Este m√©todo seria
prefer√≠vel se voc√™ quiser que seu programa considere uma tentativa de acessar um
elemento, passado o fim do vetor, para ser um erro fatal que deve finalizar o
programa.</p>
<p>Quando √© passado um √≠ndice que est√° fora da matriz para o m√©todo <code>get</code>, ele
retorna <code>None</code> sem entrar em p√¢nico. Voc√™ usaria isso se acessar um elemento
al√©m do alcance do vetor ocorrer√° ocasionalmente sob
circunst√¢ncias normais. Seu c√≥digo pode ent√£o ter l√≥gica para lidar tanto com
<code>Some(&amp;element)</code> ou <code>None</code>, como discutimos no Cap√≠tulo 6. Por exemplo, o
O √≠ndice pode ser proveniente de uma pessoa que digite um n√∫mero. Se eles acidentalmente
insira um n√∫mero que √© muito grande e seu programa recebe um valor <code>None</code>, voc√™ poderia
dizer ao usu√°rio quantos itens est√£o no atual <code>Vec</code> e dar uma nova
chance de inserir um valor v√°lido. Isso seria mais amig√°vel do que quebrar o
programa por um erro de digita√ß√£o!</p>
<a class="header" href="print.html#refer√™ncias-inv√°lidas" id="refer√™ncias-inv√°lidas"><h4>Refer√™ncias Inv√°lidas</h4></a>
<p>Uma vez que o programa tenha uma refer√™ncia v√°lida, o verificador de empr√©stimo (borrow checker) faz valer
as regras de propriedade e empr√©stimo abrangidas no Cap√≠tulo 4 para garantir que essa refer√™ncia e
quaisquer outras refer√™ncias aos conte√∫dos do vetor permane√ßam v√°lidas. Lembre-se da regra
que diz que n√£o podemos ter refer√™ncias mut√°veis e imut√°veis no mesmo escopo.
Essa regra se aplica neste exemplo, onde mantemos uma refer√™ncia imut√°vel ao
primeiro elemento em um vetor e tentamos adicionar um elemento ao final:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>Compilar isso nos dar√° esse erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Este c√≥digo pode parecer que deveria funcionar: por que uma refer√™ncia ao primeiro
elemento deveria se preocupar com o que muda sobre o final do vetor? A raz√£o porque
este c√≥digo n√£o √© permitido √© devido √† forma como os vetores funcionam. Adicionando um novo elemento
no final do vetor pode exigir a atribui√ß√£o de nova aloca√ß√£o de mem√≥ria e copiar os
elementos antigos para o novo espa√ßo, na circunst√¢ncia de n√£o haver espa√ßo suficiente
para colocar todos os elementos pr√≥ximos um do outro onde o vetor estava. Nesse
caso, a refer√™ncia ao primeiro elemento apontaria para mem√≥ria n√£o alocada.
As regras de empr√©stimo impedem que os programas acabem nessa situa√ß√£o.</p>
<blockquote>
<p>Nota: para mais informa√ß√µes, veja o Rustonomicon em
<em>https://doc.rust-lang.org/stable/nomicon/vec.html</em>.</p>
</blockquote>
<a class="header" href="print.html#usando-um-enum-para-armazenar-v√°rios-tipos" id="usando-um-enum-para-armazenar-v√°rios-tipos"><h3>Usando um Enum para Armazenar V√°rios Tipos</h3></a>
<p>No in√≠cio deste cap√≠tulo, dissemos que os vetores s√≥ podem armazenar valores
que s√£o todos do mesmo tipo. Isso pode ser inconveniente; definitivamente h√° casos
de uso para a necessidade de armazenar uma lista de coisas de diferentes tipos. Felizmente,
as variantes de um enum s√£o todas definidas sob o mesmo tipo de enum, ent√£o, quando precisamos
armazenar elementos de um tipo diferente em um vetor, podemos definir e usar um
enum!</p>
<p>Por exemplo, digamos que queremos obter valores de uma linha em uma planilha, onde
algumas das colunas da linha cont√™m n√∫meros inteiros, alguns n√∫meros de ponto flutuante,
e algumas strings. Podemos definir um enum cujas variantes guardar√£o os diferentes
tipos de valor, e ent√£o todas as variantes de enum ser√£o consideradas do mesmos
tipo, o do enum. Ent√£o, podemos criar um vetor que contenha esse enum e
ent√£o, em √∫ltima inst√¢ncia, possui diferentes tipos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">Listagem 8-1: Definindo um enum para poder guardar
diferentes tipos de dados em um vetor</span></p>
<p>A raz√£o pela qual Rust precisa saber exatamente quais tipos estar√£o no vetor em
tempo de compila√ß√£o √© para que ele saiba exatamente a quantidade de mem√≥ria no heap que ser√°
necess√°ria para armazenar cada elemento. Uma vantagem secund√°ria para isso √© que podemos ser
expl√≠citos sobre quais tipos s√£o permitidos neste vetor. Se Rust permitisse um vetor
guardar qualquer tipo, haveria uma chance de que um ou mais dos tipos
causar erros com as opera√ß√µes realizadas nos elementos do vetor. Usando
um enum mais um <code>match</code> significa que a Rust garantir√° no tempo de compila√ß√£o que n√≥s
sempre lidaremos com todos os casos poss√≠veis, como discutimos no Cap√≠tulo 6.</p>
<p>Se voc√™ n√£o sabe no momento em que voc√™ est√° escrevendo um programa, o conjunto exaustivo
dos tipos que o programa ir√° precisar no tempo de execu√ß√£o para armazenar em um vetor, a t√©cnica de usar
o enum n√£o funcionar√°. Em vez disso, voc√™ pode usar um objeto trait, que abordaremos no
Cap√≠tulo 17.</p>
<p>Agora que examinamos algumas das maneiras mais comuns de usar vetores, certifique-se
para dar uma olhada na documenta√ß√£o da API para todos os muitos m√©todos √∫teis
definidos no <code>Vec</code> pela biblioteca padr√£o. Por exemplo, al√©m de <code>push</code>
existe um m√©todo <code>pop</code> que ir√° remover e retornar o √∫ltimo elemento. Vamos mover
para o pr√≥ximo tipo de cole√ß√£o: <code>String</code>!</p>
<a class="header" href="print.html#strings" id="strings"><h2>Strings</h2></a>
<p>N√≥s j√° conversamos sobre as strings no cap√≠tulo 4, mas vamos dar uma olhada mais
em profundidade agora. As strings s√£o uma √°rea que os novos Rust√°ceos geralmente tem maior
dificuldade. Isto √© devido a uma combina√ß√£o de tr√™s coisas: a propens√£o de Rust de
certificar-se de expor poss√≠veis erros, as strings s√£o estruturas de dados mais complicadas
que muitos programadores lhes d√£o cr√©dito, e UTF-8. Essas coisas
combina de tal forma que parecem dif√≠cil quando se vem de outras linguagens.</p>
<p>A raz√£o pela qual as strings est√£o no cap√≠tulo de cole√ß√µes √© que as strings s√£o
implementadas como uma cole√ß√£o de bytes mais alguns m√©todos para fornecer informa√ß√µes √∫teis e
funcionalidade quando esses bytes s√£o interpretados como texto. Nesta se√ß√£o, iremos
falar sobre as opera√ß√µes em <code>String</code> que todo tipo de cole√ß√£o tem, como
criar, atualizar e ler. Tamb√©m discutiremos as formas em que <code>String</code>
√© diferente das outras cole√ß√µes, a saber, como a indexa√ß√£o em um <code>String</code> √©
complicada pelas diferen√ßas entre como as pessoas e os computadores interpretam
dados <code>String</code>.</p>
<a class="header" href="print.html#o-que-√©-string" id="o-que-√©-string"><h3>O que √© String?</h3></a>
<p>Antes de podermos explorar esses aspectos, precisamos falar sobre o que exatamente
significa o termo <em>string</em>. Rust realmente s√≥ tem um tipo de string no n√∫cleo
da pr√≥pria linguagem: <code>str</code>, a fatia de string, que geralmente √© vista na forma emprestada
, <code>&amp;str</code>. N√≥s falamos sobre <em>fatias de strings</em> no Cap√≠tulo 4: estas s√£o uma
refer√™ncia a alguns dados de string codificados em UTF-8 armazenados em outro lugar. Literais de strings,
por exemplo, s√£o armazenados na sa√≠da bin√°ria do programa e, portanto, s√£o
fatias de string.</p>
<p>O tipo chamado <code>String</code> √© fornecido na biblioteca padr√£o do Rust, em vez de
codificado no n√∫leo da linguagem, e √© um extens√≠vel, mut√°vel, <code>owned</code>, tipo string
codificado UTF-8. Quando Rust√°ceos falam sobre ‚Äústrings‚Äù em Rust, geralmente significa
tanto os tipos <code>String</code> quanto os tipos de string<code>&amp;str</code>, normalmente ambos.
Esta se√ß√£o, √© em grande parte sobre <code>String</code>, mas ambos esses tipos s√£o usados em grande parte
na biblioteca padr√£o da Rust. Tanto o <code>String</code> como as fatias de string s√£o codificadas em UTF-8.</p>
<p>A biblioteca padr√£o do Rust tamb√©m inclui uma s√©rie de outros tipos de string, como
<code>OsString</code>,<code>OsStr</code>, <code>CString</code> e<code>CStr</code>. Bibliotecas crates podem fornecer
mais op√ß√µes para armazenar dados de string. Semelhante ao nome <code>*String</code>/<code>*Str</code>,
elas geralmente fornecem uma variante owned e borrowed, assim como <code>String</code>/<code>&amp;str</code>.
Esses tipos de string podem armazenar diferentes codifica√ß√µes ou ser representados na mem√≥ria de
maneira diferente, por exemplo. N√≥s n√£o estaremos falando sobre esse outro tipo de string
neste cap√≠tulo; veja a documenta√ß√£o da API para obter mais informa√ß√µes sobre como us√°-los
e quando cada um √© apropriado.</p>
<a class="header" href="print.html#criando-uma-nova-string" id="criando-uma-nova-string"><h3>Criando uma Nova String</h3></a>
<p>Muitas das mesmas opera√ß√µes dispon√≠veis com <code>Vec</code> tamb√©m est√£o dispon√≠veis em <code>String</code>,
come√ßando com a fun√ß√£o <code>new</code> para criar uma string, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>Isso cria uma nova string vazia chamada <code>s</code> na qual podemos carregar dados.</p>
<p>Muitas vezes, teremos alguns dados iniciais que gostar√≠amos de j√° colocar na string.
Para isso, usamos o m√©todo <code>to_string</code>, que est√° dispon√≠vel em qualquer tipo
que implementa a trait <code>Display</code>, como as strings literais:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// o m√©todo tamb√©m funciona em literais diretamente
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>Isso cria uma string contendo <code>initial contents</code>.</p>
<p>Tamb√©m podemos usar a fun√ß√£o <code>String :: from</code> para criar uma<code>String</code> de uma string
literal. Isso equivale a usar <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>Como as strings s√£o usadas para tantas coisas, existem v√°rias APIs gen√©ricas diferentes
que podem ser usadas para strings, ent√£o h√° muitas op√ß√µes. Algumas delas
podem parecer redundantes, mas todas t√™m seu lugar! Nesse caso, <code>String :: from</code>
e <code>.to_string</code> acabam fazendo exatamente o mesmo, ent√£o a que voc√™ escolher √© uma
quest√£o de estilo.</p>
<p>Lembre-se de que as string s√£o codificadas em UTF-8, para que possamos incluir qualquer dados apropriadamente codificados
neles:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;;
let hello = &quot;Dobr√Ω den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;;
let hello = &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;;
let hello = &quot;„Åì„Çì„Å´„Å°„ÅØ&quot;;
let hello = &quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;;
let hello = &quot;‰Ω†Â•Ω&quot;;
let hello = &quot;Ol√°&quot;;
let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#atualizando-uma-string" id="atualizando-uma-string"><h3>Atualizando uma String</h3></a>
<p>Uma <code>String</code> pode crescer em tamanho e seu conte√∫do pode mudar assim como o conte√∫do
de um <code>Vec</code>, empurrando mais dados para ela. Al√©m disso, <code>String</code> tem
opera√ß√µes de concatena√ß√£o implementadas com o operador <code>+</code> por conveni√™ncia.</p>
<a class="header" href="print.html#anexando-a-uma-string-com-push" id="anexando-a-uma-string-com-push"><h4>Anexando a uma String com Push</h4></a>
<p>Podemos criar uma <code>String</code> usando o m√©todo <code>push_str</code> para adicionar uma  seq√º√™ncia de caracteres:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><code>s</code> conter√° ‚Äúfoobar‚Äú ap√≥s essas duas linhas. O m√©todo <code>push_str</code> leva um
fatia de string porque n√£o necessariamente queremos ownership do
par√¢metro. Por exemplo, seria lament√°vel se n√£o pud√©ssemos usar <code>s2</code>
depois de atualizar o seu conte√∫do a <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);
#}</code></pre></pre>
<p>O m√©todo <code>push</code> √© definido para ter um √∫nico caractere como par√¢metro e adicionar
√† <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>Ap√≥s isso, <code>s</code> ir√° conter ‚Äúlol‚Äù.</p>
<a class="header" href="print.html#concatena√ß√£o-com-o-operador--ou-a-macro-format" id="concatena√ß√£o-com-o-operador--ou-a-macro-format"><h4>Concatena√ß√£o com o Operador + ou a macro <code>format!</code></h4></a>
<p>Muitas vezes, queremos combinar duas strings existentes. Uma maneira √© usar
o operador <code>+</code> dessa forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note que s1 foi movido aqui e n√£o pode ser mais usado
#}</code></pre></pre>
<p>Ap√≥s este c√≥digo, a String <code>s3</code> conter√° <code>Hello, world!</code>. O motivo que
<code>s1</code> n√£o √© mais v√°lido ap√≥s a adi√ß√£o e o motivo que usamos uma
refer√™ncia a <code>s2</code> tem a ver com a assinatura do m√©todo que √© chamado
quando usamos o operador <code>+</code>. O operador <code>+</code> usa o m√©todo <code>add</code>, cuja
assinatura parece algo assim:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta n√£o √© a assinatura exata que est√° na biblioteca padr√£o; l√° o <code>add</code> √©
definido usando gen√©ricos. Aqui, estamos olhando a assinatura do <code>add</code> com
tipos de concreto substitu√≠dos pelos gen√©ricos, o que acontece quando n√≥s
chamamos esse m√©todo com valores <code>String</code>. Vamos discutir gen√©ricos no
Cap√≠tulo 10. Esta assinatura nos d√° as pistas que precisamos para entender o complicado
operador <code>+</code>.</p>
<p>Antes de tudo, <code>s2</code> tem um <code>&amp;</code>, o que significa que estamos adicionando uma <em>refer√™ncia</em> da
segunda string para a primeira string. Isso √© devido ao par√¢metro <code>s</code> na
fun√ß√£o <code>add</code>: s√≥ podemos adicionar um <code>&amp;str</code> √† <code>String</code>, n√£o podemos adicionar dois
valores <code>String</code> juntos. Mas espere - o tipo de <code>&amp;s2</code> √© <code>&amp;String</code>, n√£o
<code>&amp;str</code>, conforme especificado no segundo par√¢metro para<code>add</code>. Por que nosso exemplo
compila? Podemos usar <code>&amp;s2</code> na chamada para <code>add</code> porque um <code>&amp;String</code>
o argumento pode ser <em>coerced</em> em um <code>&amp;str</code> - quando a fun√ß√£o<code>add</code> √© chamada,
Rust usa algo chamado de <em>deref coercion</em>, o que voc√™ poderia pensar aqui como
virando <code>&amp;s2</code> para<code>&amp;s2[..]</code> para uso na fun√ß√£o <code>add</code>. Vamos discutir deref
coercion  em maior profundidade no Cap√≠tulo 15. Como o <code>add</code> n√£o se apropria
o par√¢metro <code>s2</code> ainda ser√° uma <code>String</code> v√°lida ap√≥s essa opera√ß√£o.</p>
<p>Em segundo lugar, podemos ver na assinatura que <code>add</code> toma posse de<code>self</code>,
porque <code>self</code> <em>n√£o</em> tem <code>&amp;</code>. Isso significa <code>s1</code> no exemplo acima
ser√° transferido para a chamada <code>add</code> e n√£o ser√° mais v√°lido depois disso. Por enquanto
<code>let s3 = s1 + &amp;s2;</code> parece que ir√° copiar ambas as strings e criar uma nova,
esta declara√ß√£o realmente adere a <code>s1</code>, acrescenta uma c√≥pia do conte√∫do
de <code>s2</code>, ent√£o retorna ownership do resultado. Em outras palavras, parece
estar fazendo muitas c√≥pias, mas n√£o √©: a implementa√ß√£o √© mais eficiente
do que copiar.</p>
<p>Se precisarmos concatenar v√°rias strings, o comportamento de <code>+</code> fica complicado:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p><code>s</code> ser√° ‚Äútic-tac-toe‚Äù neste momento. Com todos os <code>+</code> e <code>&quot;</code>,
fica dif√≠cil ver o que est√° acontecendo. Para strings mais complicadas
, podemos usar o macro <code>format!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>Este c√≥digo tamb√©m definir√° <code>s</code> para ‚Äútic-tac-toe‚Äù. A macro <code>format!</code> funciona
do mesmo modo que <code>println!</code>, mas em vez de imprimir a sa√≠da para a tela, ela
retorna uma <code>String</code> com o conte√∫do. Esta vers√£o √© muito mais f√°cil de ler, e
tamb√©m n√£o incide ownership em nenhum dos seus par√¢metros.</p>
<a class="header" href="print.html#indexa√ß√£o-em-strings" id="indexa√ß√£o-em-strings"><h3>Indexa√ß√£o em Strings</h3></a>
<p>Em muitas outras linguagens, acessar caracteres individuais em uma string por
referenciando por √≠ndice √© uma opera√ß√£o v√°lida e comum. Em Rust, no entanto, se
n√≥s tentamos acessar partes de uma <code>String</code> usando sintaxe de indexa√ß√£o, vamos ter um erro.
Ou seja, este c√≥digo:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>resultar√° neste erro:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>O erro e a nota contam a hist√≥ria: as strings em Rust n√£o suportam a indexa√ß√£o. Assim
a pr√≥xima pergunta √©, por que n√£o? Para responder a isso, temos que conversar um
pouco sobre como o Rust armazena strings na mem√≥ria.</p>
<a class="header" href="print.html#representa√ß√£o-interna" id="representa√ß√£o-interna"><h4>Representa√ß√£o Interna</h4></a>
<p>Uma <code>String</code> √© um inv√≥lucro sobre um <code>Vec &lt;u8&gt;</code>. Vejamos alguns dos nossos
exemplos UTF-8, codificadas corretamente, de strings vistas anteriormente. Primeiro, este:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>Neste caso, <code>len</code> ter√° valor de quatro, o que significa que o<code>Vec</code> armazena a string
‚ÄùHola‚Äù tem quatro bytes de comprimento: cada uma dessas letras leva um byte quando codificado em
UTF-8. E o que acontece para esse exemplo?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;).len();
#}</code></pre></pre>
<p>Uma pessoa que pergunte pelo comprimento da string pode dizer que ela deva ter 12.No entanto, a resposta de Rust
√© 24. Este √© o n√∫mero de bytes que √© necess√°rio para codificar ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äú em
UTF-8, uma vez que cada valor escalar Unicode leva dois bytes de armazenamento. Assim sendo,
um √≠ndice nos bytes da string nem sempre se correlaciona com um  valor escalar Unicode v√°lido.</p>
<p>Para demonstrar, considere este c√≥digo inv√°lido do Rust:</p>
<pre><code class="language-rust ignore">let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Qual deve ser o valor da <code>answer</code>? Seria <code>–ó</code>, a primeira letra? Quando
codificado em UTF-8, o primeiro byte de <code>–ó</code> √© <code>208</code>, e o segundo √© <code>151</code>, ent√£o
a <code>answer</code> deve, na verdade, ser <code>208</code>, mas <code>208</code> n√£o √© um caractere v√°lido em
si. Retornar <code>208</code> provavelmente n√£o √© o que uma pessoa gostaria se eles pedissem
a primeira letra desta string, mas esse √© o √∫nico dado que Rust tem no byte
de √≠ndice 0. O retorno do valor do byte provavelmente n√£o √© o que as pessoas querem, mesmo com
caracteres contendo acentua√ß√£o: <code>&amp;&quot;hello&quot;[0]</code> retornaria <code>104</code>, n√£o<code>h</code>. Para evitar o
retornando um valor inesperado e causando erros que podem n√£o ser descobertos
imediatamente, Rust escolhe n√£o compilar este c√≥digo e previne
mal-entendidos anteriormente.</p>
<a class="header" href="print.html#bytes-e-valores-escalares-e-clusters-de-grafemas-nossa" id="bytes-e-valores-escalares-e-clusters-de-grafemas-nossa"><h4>Bytes e Valores Escalares e Clusters de Grafemas! Nossa!</h4></a>
<p>Isso leva a outro ponto sobre UTF-8: existem realmente tr√™s maneiras relevantes
de olhar para as strings, da perspectiva do Rust: como bytes, valores escalares e
clusters de grafemas (a coisa mais pr√≥xima do que as pessoas chamariam <em>letras</em>).</p>
<p>Se olharmos para a palavra Hindi ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù escrita na escrita Devanagari, √©
em √∫ltima inst√¢ncia, armazenada como um <code>Vec</code> de valores <code>u8</code> que se parece com isto:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Isso √© 18 bytes, e √© como os computadores de fato armazenam esses dados. Se olharmos para
eles como valores escalares Unicode, que s√£o o tipo <code>char</code> de Rust, aqueles
bytes se parecem com isto:</p>
<pre><code class="language-text">['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
</code></pre>
<p>Existem seis valores <code>char</code> aqui, mas o quarto e o sexto n√£o s√£o letras,
Eles s√£o diacr√≠ticos que n√£o fazem sentido por conta pr√≥pria. Finalmente, se olharmos para
eles como clusters de grafemas, ter√≠amos o que uma pessoa chamaria as quatro letras
que comp√µem esta palavra:</p>
<pre><code class="language-text">[&quot;‡§®&quot;, &quot;‡§Æ&quot;, &quot;‡§∏‡•ç&quot;, &quot;‡§§‡•á&quot;]
</code></pre>
<p>Rust fornece diferentes maneiras de interpretar os dados de uma string bruta que os computadores
armazenem para que cada programa possa escolher a interpreta√ß√£o que necessite, n√£o importa
em que idioma humano os dados est√£o.</p>
<p>Uma raz√£o final do Rust n√£o permitir que voc√™ indexe uma <code>String</code> para obter um
caracter √© que as opera√ß√µes de indexa√ß√£o sempre esperam um tempo constante
(O(1)). N√£o √© poss√≠vel garantir que o desempenho com uma <code>String</code>,
entretanto, j√° que o Rust teria que percorrer todo o conte√∫do desde o in√≠cio
at√© o √≠ndice para determinar quantos caracteres v√°lidos havia.</p>
<a class="header" href="print.html#fatiando-strings" id="fatiando-strings"><h3>Fatiando Strings</h3></a>
<p>Porque n√£o est√° claro qual seria o tipo de retorno da indexa√ß√£o de string, e
muitas vezes √© uma m√° id√©ia indexar uma string, Rust dissuade-o de faz√™-lo
pedindo que voc√™ seja mais espec√≠fico se voc√™ realmente precisar disso. Do jeito que voc√™ pode ser
mais espec√≠fico que a indexa√ß√£o usando <code>[]</code> com um √∫nico n√∫mero √© usando <code>[]</code> com
um intervalo para criar uma fatia de string contendo bytes espec√≠ficos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Aqui, <code>s</code> ser√° um <code>&amp;str</code> que cont√©m os primeiros quatro bytes da string.
Mais cedo, mencionamos que cada um desses personagens era de dois bytes, de modo que
significa que <code>s</code> ser√° ‚Äú–ó–¥‚Äù.</p>
<p>O que aconteceria se fiz√©ssemos <code>&amp;hello[0..1]</code>? A resposta: entrar√° em p√¢nico
em tempo de execu√ß√£o, da mesma maneira que acessar um √≠ndice inv√°lido em um vetor:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>Voc√™ deve usar isso com cautela, pois isso pode fazer com que seu programa falhe.</p>
<a class="header" href="print.html#m√©todos-para-interagir-sobre-strings" id="m√©todos-para-interagir-sobre-strings"><h3>M√©todos para Interagir Sobre Strings</h3></a>
<p>Felizmente, existem outras maneiras de acessar elementos em um String.</p>
<p>Se precisarmos realizar opera√ß√µes em valores escalares Unicode individuais, a melhor
maneira de fazer isso √© usar o m√©todo <code>chars</code>. Chamando <code>chars</code> em ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù
√© separado e retorna seis valores do tipo <code>char</code>, e voc√™ pode interar
no resultado para acessar cada elemento:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>Este c√≥digo ir√° imprimir:</p>
<pre><code class="language-text">‡§®
‡§Æ
‡§∏
‡•ç
‡§§
‡•á
</code></pre>
<p>O m√©todo <code>bytes</code> retorna cada byte bruto, que pode ser apropriado para o seu
dom√≠nio:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>Este c√≥digo imprimir√° os 18 bytes que comp√µem esse <code>String</code>, come√ßando por:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>Mas lembre-se de que os valores escalares Unicode v√°lidos podem ser constitu√≠dos por
mais de um byte.</p>
<p>Obter clusters de grafemas de strings √© complexo, ent√£o esta funcionalidade n√£o √©
fornecida pela biblioteca padr√£o. Existem crates dispon√≠veis em crates.io se
Esta √© a funcionalidade que voc√™ precisa.</p>
<a class="header" href="print.html#as-strings-n√£o-s√£o-t√£o-simples" id="as-strings-n√£o-s√£o-t√£o-simples"><h3>As Strings N√£o s√£o t√£o Simples</h3></a>
<p>Para resumir, as strings s√£o complicadas. Diferentes linguagens de programa√ß√£o fazem
escolhas diferentes sobre como apresentar essa complexidade ao programador. Rust
optou por fazer o tratamento correto dos dados <code>String</code> o comportamento padr√£o
para todos os programas Rust, o que significa que os programadores devem pensar mais
no gerenciamento de dados UTF-8 antecipadamente. Este tradeoff exp√µe mais da complexidade
de strings do que outras linguagens de programa√ß√£o, mas isso ir√° impedi-lo de
ter que lidar com erros envolvendo caracteres n√£o-ASCII mais tarde em seu
ciclo de desenvolvimento.</p>
<p>Vamos mudar para algo um pouco menos complexo: hash maps!</p>
<a class="header" href="print.html#hash-maps" id="hash-maps"><h2>Hash Maps</h2></a>
<p>A √∫ltima das nossas cole√ß√µes comuns √© o <em>hash map</em>. O tipo <code>HashMap &lt;K, V&gt;</code>
armazena um mapeamento de chaves do tipo <code>K</code> para valores do tipo<code>V</code>. Ele faz isso atrav√©s de um
<em>hashing function</em>, que determina como ele coloca essas chaves e valores em
mem√≥ria. Muitas linguagens de programa√ß√£o diferentes suportam este tipo de
estrutura de dados, mas muitas vezes com um nome diferente: hash, map, object, hash table ou
associative array, apenas para citar alguns.</p>
<p>Os Hash maps s√£o √∫teis para quando voc√™ deseja poder procurar dados sem uso de
√≠ndice, como voc√™ pode com vetores, mas usando uma chave que pode ser de qualquer tipo. Por
exemplo, em um jogo, voc√™ poderia acompanhar a pontua√ß√£o de cada equipe em um hash map
onde cada chave √© o nome de uma equipe e os valores s√£o cada pontua√ß√£o da equipe. Dado um
nome da equipe, voc√™ pode recuperar sua pontua√ß√£o.</p>
<p>Examinaremos a API b√°sica dos hash map neste cap√≠tulo, mas h√° muitos
mais coisas escondidas nas fun√ß√µes definidas no <code>HashMap</code> pela biblioteca
padr√£o. Como sempre, verifique a documenta√ß√£o da biblioteca padr√£o para mais
informa√ß√£o.</p>
<a class="header" href="print.html#criando-um-novo-hash-map" id="criando-um-novo-hash-map"><h3>Criando um novo Hash Map</h3></a>
<p>Podemos criar um <code>HashMap</code> vazio com <code>new</code>, e adicionar elementos com <code>insert</code>.
Aqui, estamos acompanhando as pontua√ß√µes de duas equipes cujos nomes s√£o Blue e
Yellow. A equipe blue come√ßar√° com 10 pontos e a equipe yellow come√ßa com
50:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p>Observe que precisamos primeiro <code>use</code> o <code>HashMap</code> da parte de cole√ß√µes da
biblioteca padr√£o. De nossas tr√™s cole√ß√µes comuns, esta √© a de menor
frequencia de uso, por isso n√£o est√° inclusa nos recursos importados automaticamente no
prel√∫dio. Os Hash maps tamb√©m t√™m menos suporte da biblioteca padr√£o; n√£o h√°
macro embutida para constru√≠-los, por exemplo.</p>
<p>Assim como os vetores, os mapas hash armazenam seus dados no heap. Este <code>HashMap</code> tem
chaves do tipo <code>String</code> e valores do tipo <code>i32</code>. Como vetores, os hash maps s√£o
homog√™neos: todas as chaves devem ter o mesmo tipo e todos os valores
devem ter o mesmo tipo.</p>
<p>Outra maneira de construir um hash map √© usando o m√©todo <code>collect</code> em um
vetor de tuplas, onde cada tupla consiste de uma chave e seu valor. O
m√©todo <code>collect</code> re√∫ne dados em v√°rios tipos de cole√ß√£o, incluindo
<code>HashMap</code>. Por exemplo, se tiv√©ssemos os nomes das equipes e as pontua√ß√µes iniciais em dois
vetores separados, podemos usar o m√©todo <code>zip</code> para criar um vetor de tuplas
onde ‚ÄúBlue‚Äù √© emparelhado com 10, e assim por diante. Ent√£o podemos usar o m√©todo <code>collect</code>
para transformar esse vetor de tuplas em um <code>HashMap</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p>A anota√ß√£o de tipo <code>HashMap &lt;_, _&gt;</code> √© necess√°ria aqui porque √© poss√≠vel
<code>collect</code> em muitas estruturas de dados diferentes, e Rust n√£o sabe qual voc√™
deseja, a menos que voc√™ especifique. Para os par√¢metros de tipo, para os tipos de chave e valor,
no entanto, usamos underscores e Rust pode inferir os tipos que o hash map
cont√©m com base nos tipos de dados no vetor.</p>
<a class="header" href="print.html#hash-maps-e-ownership" id="hash-maps-e-ownership"><h3>Hash Maps e Ownership</h3></a>
<p>Para os tipos que implementam a <code>Copy</code> trait, como <code>i32</code>, os valores s√£o copiados
no hash map. Para valores owned como <code>String</code>, os valores ser√£o movidos e
o hash map ser√° o owner desses valores:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name e field_value s√£o inv√°lidos neste ponto
#}</code></pre></pre>
<p>N√£o poder√≠amos usar as liga√ß√µes <code>field_name</code> e<code>field_value</code> depois
que foram transferidos para o hash map com a chamada para <code>insert</code>.</p>
<p>Se inserimos refer√™ncias a valores no hash map, os pr√≥prios valores
n√£o ser√£o movido para o hash map. Os valores que as refer√™ncias apontam devem ser
v√°lido pelo menos enquanto o hash map seja v√°lido, no entanto. Falaremos mais
sobre esses problemas na se√ß√£o Lifetimes do Cap√≠tulo 10.</p>
<a class="header" href="print.html#acessando-valores-em-um-hash-map" id="acessando-valores-em-um-hash-map"><h3>Acessando Valores em um Hash Map</h3></a>
<p>Podemos obter um valor do hash map fornecendo a chave para o m√©todo <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p>Aqui, <code>score</code> ter√° o valor que est√° associado √† equipe Blue, e o
resultado ser√° <code>Some(&amp;10)</code>. O resultado est√° envolvido em <code>Some</code> porque <code>get</code>
retorna <code>Option&lt;&amp;V&gt;</code>; se n√£o houver valor para essa chave no hash map, <code>get</code>
retornar√° <code>None</code>. O programa precisar√° lidar com <code>Option</code> em uma das
formas que abordamos no Cap√≠tulo 6.</p>
<p>Podemos iterar sobre cada par chave/valor em um hash map de uma maneira similar √† que
fazemos com vetores, usando um loop <code>for</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>Isso imprimir√° cada par, em uma ordem arbitr√°ria:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#atualizando-um-hash-map" id="atualizando-um-hash-map"><h3>Atualizando um Hash Map</h3></a>
<p>Embora o n√∫mero de chaves e valores sejam crescentes, cada chave individual pode apenas
tem um valor associado a ele por vez. Quando queremos mudar os dados em
um hash map, temos que decidir como lidar com o caso quando uma chave j√° possui uma
valor atribu√≠do. Poder√≠amos optar por substituir o valor antigo pelo novo valor,
desconsiderando completamente o valor antigo. Poder√≠amos escolher manter o valor antigo
e ignorar o novo valor, e apenas adicione o novo valor se a chave ainda <em>n√£o</em>
tem um valor. Ou podemos combinar o valor antigo ao valor novo.
Vejamos como fazer cada um desses!</p>
<a class="header" href="print.html#sobrescrevendo-um-valor" id="sobrescrevendo-um-valor"><h4>Sobrescrevendo um Valor</h4></a>
<p>Se inserimos uma chave e um valor em um hash map, ent√£o  se inserir essa mesma chave com
um valor diferente, o valor associado a essa chave ser√° substitu√≠do. Eembora
o seguinte c√≥digo chame <code>insert</code> duas vezes, o hash map s√≥ conter√°
um par de chave/valor porque inserimos o valor da chave da equipe Blue
ambas as vezes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>Isso imprimir√° <code>{&quot;Blue&quot;: 25}</code>. O valor original de 10 foi substitu√≠do.</p>
<a class="header" href="print.html#insira-apenas-se-a-chave-n√£o-possui-valor" id="insira-apenas-se-a-chave-n√£o-possui-valor"><h4>Insira Apenas se a Chave N√£o Possui Valor</h4></a>
<p>√â comum querer verificar se uma determinada chave tem um valor e, se
n√£o tiver, inserir um valor para ela. Os Hash maps possuem uma API especial para isso, chamada
<code>entry</code>, que leva a chave que queremos verificar como um argumento. O valor de retorno
da fun√ß√£o <code>entry</code> √© um enum, <code>Entry</code>, que representa um valor que pode
ou n√£o existir. Digamos que queremos verificar se a chave para o time Yellow
tem um valor associado a ela. Se n√£o tiver, queremos inserir o valor
50, e o mesmo para a equipe Blue. Com a API de entrada, o c√≥digo ir√° parecer
com:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>O m√©todo <code>or_insert</code> em <code>Entry</code> retorna o valor para o <code>Entry</code> correspondente
se a chave existir, e se n√£o, insere seu argumento como o novo valor para
esta chave e retorna a <code>Entry</code> modificada. Isso √© muito mais limpo do que escrever
a l√≥gica por n√≥s mesmos e, al√©m disso, trabalha-se de forma mais limpa com o borrow checker.</p>
<p>Este c√≥digo imprimir√° <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. A primeira chamada para <code>entry</code>
ir√° inserir a chave para a equipe Yellow com o valor 50, uma vez que o time Yellow
j√° n√£o possua um valor. A segunda chamada para <code>entry</code> n√£o vai mudar
o hash map pois o time Blue j√° possui o valor 10.</p>
<a class="header" href="print.html#atualize-um-valor-com-base-no-valor-antigo" id="atualize-um-valor-com-base-no-valor-antigo"><h4>Atualize um Valor com Base no Valor Antigo</h4></a>
<p>Outro caso de uso comum para hash maps √© procurar o valor de uma chave e, em seguida, atualiza-la
, com base no valor antigo. Por exemplo, se quisermos contar quantas vezes
cada palavra apareceu em algum texto, podemos usar um hash map com as palavras como chaves
e incrementar o valor para acompanhar quantas vezes vimos essa palavra.
Se esta √© a primeira vez que vimos uma palavra, primeiro inseriremos o valor <code>0</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p>Isso imprimir√° <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. O m√©todo <code>or_insert</code>
na verdade retorna uma refer√™ncia mut√°vel (<code>&amp; mutV</code>) para o valor desta
chave. Aqui n√≥s armazenamos essa refer√™ncia mut√°vel na vari√°vel <code>count</code>, ent√£o,
para poder atribuir esse valor, devemos primeiro desreferenciar <code>count</code> usando o asterisco
(<code>*</code>). A refer√™ncia mut√°vel fica fora do escopo no final do loop <code>for</code>, ent√£o
todas essas mudan√ßas s√£o seguras e permitidas pelas regras de borrow.</p>
<a class="header" href="print.html#fun√ß√µes-hashing" id="fun√ß√µes-hashing"><h3>Fun√ß√µes Hashing</h3></a>
<p>Por padr√£o, <code>HashMap</code> usa uma fun√ß√£o de hashing criptogr√°ficamente segura que pode
fornecer resist√™ncia aos ataques de Nega√ß√£o de Servi√ßo (DoS). Este n√£o √© o algoritmo
mais r√°pido de hashing por a√≠, mas a compensa√ß√£o por uma melhor seguran√ßa que vem
com a queda na performance vale a pena. Se voc√™ testar a velocidade do seu c√≥digo e encontrar
que a fun√ß√£o de hash padr√£o √© muito lenta para seus prop√≥sitos, voc√™ pode mudar para
outra fun√ß√£o especificando um <em>hasher</em> diferente. Um hasher √© um tipo que
implementa a trait <code>BuildHasher</code>. Vamos falar sobre traits e como
implement√°-los no Cap√≠tulo 10. Voc√™ n√£o precisa necessariamente implementar o seu pr√≥prio
hasher do zero; crates.io tem bibliotecas de hashers de uso comum que
outras pessoas compartilharam l√°.</p>
<a class="header" href="print.html#sum√°rio" id="sum√°rio"><h2>Sum√°rio</h2></a>
<p>Vetores, strings e hash maps ir√£o lev√°-lo longe em programas onde voc√™ precisa
armazenar, acessar e modificar dados. Aqui est√£o alguns exerc√≠cios que voc√™ deve estar
capacitado para resolver:</p>
<ul>
<li>Dada uma lista de inteiros, use um vetor e retorne a m√©dia, a mediana
¬†¬† (quando classificado, o valor na posi√ß√£o do meio) e modo (o valor que
¬†¬† ocorre com mais frequ√™ncia; um hash map ser√° √∫til aqui) da lista.</li>
<li>Converta strings para Pig Latin, onde a primeira consoante de cada palavra √© movida
¬†¬† para o final da palavra adicionado um &quot;ay&quot; , ent√£o ‚Äúfirst‚Äù se torna ‚Äúirst-fay‚Äù.
¬†¬† Palavras que come√ßam com uma vogal recebem ‚Äúhay‚Äù adicionado ao final (‚Äúapple‚Äù
¬†¬† torna-se ‚Äúapple-hay‚Äù). Lembre-se sobre a codifica√ß√£o UTF-8!</li>
<li>Usando um hash map e vetores, crie uma interface de texto para permitir que um usu√°rio adicione
¬†¬† nomes de funcion√°rios para um departamento da empresa. Por exemplo, ‚ÄúAdd Sally to
Engineering‚Äù ou ‚ÄúAdd Amir to Sales‚Äù. Em seguida, deixe o usu√°rio recuperar uma lista de todas
¬†¬† as pessoas de um departamento ou todas as pessoas na empresa por departamento, ordenadas
¬†¬† alfabeticamente.</li>
</ul>
<p>A documenta√ß√£o da API da biblioteca padr√£o descreve m√©todos que esses tipos possuem
que ser√° √∫til para esses exerc√≠cios!</p>
<p>Estamos entrando em programas mais complexos onde as opera√ß√µes podem falhar, o que significa
que √© um momento perfeito para passar pelo tratamento de erros em seguida!</p>
<a class="header" href="print.html#tratamento-de-erros" id="tratamento-de-erros"><h1>Tratamento de Erros</h1></a>
<p>O comprometimento de Rust √† seguran√ßa se extende ao tratamento de erros. Erros
s√£o um fato da vida em software, portanto Rust possui um n√∫mero de <em>features</em>
para lidar com situa√ß√µes em que algo d√° errado. Em v√°rios casos, Rust requer que
voc√™ reconhe√ßa a possibilidade de um erro acontecer e aja preventivamente antes
que seu c√≥digo compile. Esse requisito torna seu programa mais robusto ao assegurar
que voce ir√° descobrir erros e lidar com eles apropriadamente antes de mandar seu
c√≥digo para produ√ß√£o!</p>
<p>Rust agrupa erros em duas categorias principais: <em>recuper√°veis</em> e <em>irrecuper√°veis</em>.
Erros recuper√°veis s√£o situa√ß√µes em que √© razo√°vel reportar o problema ao usu√°rio
e tentar a opera√ß√£o novamente, como um erro de arquivo n√£o encontrado. Erros
irrecuper√°veis s√£o sempre sintomas de bugs, como tentar acessar uma localiza√ß√£o
al√©m do fim de um <em>array</em>.</p>
<p>A maioria das linguagens n√£o distingue esses dois tipos de erros e lida
com ambos da mesma maneira usando mecanismos como exce√ß√µes. Rust n√£o tem
exce√ß√µes. Em vez disso, ele tem o valor <code>Result&lt;T, E&gt;</code> para erros recuper√°veis
e a macro <code>panic!</code> que para a execu√ß√£o ao encontrar um erro irrecuper√°vel. Esse
cap√≠tulo cobre primeiro como chamar <code>panic!</code> e depois fala sobre retornar valores
<code>Result&lt;T, E&gt;</code>. Adicionalmente, vamos explorar o que se levar em considera√ß√£o
para decidir entre tentar se recuperar de um erro ou parar execu√ß√£o.</p>
<a class="header" href="print.html#erros-irrecuper√°veis-com-panic" id="erros-irrecuper√°veis-com-panic"><h2>Erros Irrecuper√°veis com <code>panic!</code></h2></a>
<p>√Äs vezes coisas ruins acontecem no seu c√≥digo, e n√£o h√° nada que voc√™ possa fazer
sobre isso. Nesses casos, Rust tem a macro <code>panic!</code>. Quando ela √© executada, seu
programa vai imprimir uma mensagem de falha, resolver e limpar a pilha e ent√£o
terminar. A situa√ß√£o mais comum em que isso acontece √© quando algum tipo de bug
foi detectado, e n√£o √© claro para o programador como tratar esse erro.</p>
<blockquote>
<a class="header" href="print.html#resolver-a-pilha-ou-abortar-em-resposta-a-panic" id="resolver-a-pilha-ou-abortar-em-resposta-a-panic"><h3>Resolver a Pilha ou Abortar em Resposta a <code>panic!</code></h3></a>
<p>Por padr√£o, quando acontece um <code>panic!</code>, o programa come√ßa a <em>resolver</em> a pilha,
o que significa que Rust percorre a pilha e limpa os dados de cada fun√ß√£o que encontra.
Mas essa limpeza d√° bastante trabalho. A alternativa √© imediatamente <em>abortar</em>,
que termina o programa sem fazer a limpeza. A mem√≥ria que o programa estava usando vai ent√£o
precisar ser limpada pelo sistema operacional. Se no seu projeto voc√™ precisa tornar
o bin√°rio final o menor poss√≠vel, voc√™ pode deixar de resolver e sim abortar no <em>panic</em>
adicionando <code>panic = 'abort'</code> √† se√ß√£o apropriadada de <code>[profile]</code> no seu arquivo
<em>Cargo.toml</em>. Por exemplo, se voc√™ quiser abortar no <em>panic</em> no modo de <em>release</em>, adicione
isso:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Vamos tentar chamar <code>panic!</code> em um programa simples:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    panic!(&quot;Quebra tudo&quot;);
}
</code></pre></pre>
<p>Quando voc√™ roda o programa, ver√° algo como isso:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'Quebra tudo', src/main.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>A chamada a <code>panic!</code> causa a mensagem de erro contida nas √∫ltimas tr√™s linhas.
A primeira linha mostra nossa mensagem de p√¢nico e a posi√ß√£o no c√≥digo fonte
em que ocorreu o p√¢nico: <em>src/main.rs:2</em> indica que √© a segunda linha do nosso
arquivo <em>src/main.rs</em>.</p>
<p>Nesse caso, a linha indicada √© parte do nosso c√≥digo, e se formos √†quela linha
veremos a chamada √† macro <code>panic!</code>. Em outros casos, a chamada a <code>panic!</code> pode
estar em c√≥digo que nosso c√≥digo chama. O nome do arquivo e n√∫mero de linha
reportado pela mensagem de erro ser√° no c√≥digo de outra pessoa quando a macro
<code>panic!</code> for chamada, n√£o a linha do nosso c√≥digo que eventualmente levou a chamada
de <code>panic!</code>. Podemos usar o <em>backtrace</em> das fun√ß√µes de onde veio a chamada a <code>panic!</code>
para entender qual parte de nosso c√≥digo est√° causando o problema. Vamos discutir
o que √© um <em>backtrace</em> em seguida.</p>
<a class="header" href="print.html#usando-um-backtrace-de-panic" id="usando-um-backtrace-de-panic"><h3>Usando um Backtrace de <code>panic!</code></h3></a>
<p>Vamos ver outro exemplo para ver o que acontece quando uma chamada <code>panic!</code> vem de uma
biblioteca por causa de um bug no nosso c√≥digo em vez de nosso c√≥digo chamar
a macro diretamente. A Listagem 9-1 tem c√≥digo que tenta acessar um elemento em
um vetor por meio de um √≠ndice:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Listagem 9-1: Tentativa de acessar um elemento al√©m do fim
de um vetor, que causar√° um <code>panic!</code></span></p>
<p>Aqui, estamos tentando acessar o cent√©simo elemento (cent√©simo pois o √≠ndice
come√ßa em zero) de nosso vetor, mas ele s√≥ tem tr√™s elementos. Nesse caso, Rust
entrar√° em p√¢nico. Supostamente <code>[]</code> devolve um elemento, mas se voc√™ passa um
√≠ndice inv√°lido, n√£o h√° elemento que Rust possa retornar que fosse correto.</p>
<p>Outras linguagens, como C, v√£o tentar te dar exatamente o que voc√™ pediu nessa
situa√ß√£o, mesmo que n√£o seja o que voc√™ quer: voc√™ vai receber o que quer que
esteja na localiza√ß√£o na mem√≥ria que corresponderia √†quele elemento no vetor,
mesmo que a mem√≥ria n√£o perten√ßa ao vetor. Isso se chama um <em>buffer overread</em> e
pode levar a vulnerabilidades de seguran√ßa se um agressor for capaz de manipular
o √≠ndice de forma a ler dados guardados depois do array aos quais ele n√£o deveria
ter acesso.</p>
<p>Para proteger seu programa desse tipo de vulnerabilidade, se voc√™ tentar ler
um elemento em um √≠ndice que n√£o exista, Rust vai parar a execu√ß√£o e se recusar
a continar. Vamos fazer isso e ver o que acontece:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
100', /stable-dist-rustc/build/src/libcollections/vec.rs:1362
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>Esse erro aponta para um arquivo que n√£o escrevemos, <em>libcollections/vec.rs</em>.
Essa √© a implementa√ß√£o de <code>Vec&lt;T&gt;</code> na biblioteca padr√£o. O c√≥digo que roda
quando usamos <code>[]</code> em nosso vetor <code>v</code> est√° em <em>libcollections/vec.rs</em>, e √© a√≠
que o <code>panic!</code> est√° de fato acontecendo.</p>
<p>A pr√≥xima linha nos diz que podemos definir a vari√°vel de ambiente <code>RUST_BACKTRACE</code>
para ter um <em>backtrace</em> (rastro) do que aconteceu, exatamente, para causar o erro. Um
<em>backtrace</em> √© uma lista de todas as fun√ß√µes que foram chamadas para chegar a esse
ponto. <em>Backtraces</em> em Rust funcionam como em outras linguagens: a chave para ler
o <em>backtrace</em> √© come√ßar do topo e ler at√© voc√™ ver os arquivos que voc√™ escreveu.
Esse √© o ponto em que o problema se originou. As linhas acima das que mencionam seu
c√≥digo s√£o fun√ß√µes que voc√™ chamou; as linhas abaixo s√£o fun√ß√µes que chamaram seu
c√≥digo. Essas linhas podem incluir c√≥digo do n√∫cleo do Rust, c√≥digo das bibliotecas
padr√£o, ou <em>crates</em> que voc√™ est√° usando. Vamos tentar ver um backtrace: a Listagem 9-2
mostra uma sa√≠da semelhante a o que voc√™ ver√°:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 100', /stable-dist-rustc/build/src/libcollections/vec.rs:1392
stack backtrace:
   1:     0x560ed90ec04c - std::sys::imp::backtrace::tracing::imp::write::hf33ae72d0baa11ed
                        at /stable-dist-rustc/build/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:42
   2:     0x560ed90ee03e - std::panicking::default_hook::{{closure}}::h59672b733cc6a455
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:351
   3:     0x560ed90edc44 - std::panicking::default_hook::h1670459d2f3f8843
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:367
   4:     0x560ed90ee41b - std::panicking::rust_panic_with_hook::hcf0ddb069e7abcd7
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:555
   5:     0x560ed90ee2b4 - std::panicking::begin_panic::hd6eb68e27bdf6140
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:517
   6:     0x560ed90ee1d9 - std::panicking::begin_panic_fmt::abcd5965948b877f8
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:501
   7:     0x560ed90ee167 - rust_begin_unwind
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:477
   8:     0x560ed911401d - core::panicking::panic_fmt::hc0f6d7b2c300cdd9
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:69
   9:     0x560ed9113fc8 - core::panicking::panic_bounds_check::h02a4af86d01b3e96
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:56
  10:     0x560ed90e71c5 - &lt;collections::vec::Vec&lt;T&gt; as core::ops::Index&lt;usize&gt;&gt;::index::h98abcd4e2a74c41
                        at /stable-dist-rustc/build/src/libcollections/vec.rs:1392
  11:     0x560ed90e727a - panic::main::h5d6b77c20526bc35
                        at /home/you/projects/panic/src/main.rs:4
  12:     0x560ed90f5d6a - __rust_maybe_catch_panic
                        at /stable-dist-rustc/build/src/libpanic_unwind/lib.rs:98
  13:     0x560ed90ee926 - std::rt::lang_start::hd7c880a37a646e81
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:436
                        at /stable-dist-rustc/build/src/libstd/panic.rs:361
                        at /stable-dist-rustc/build/src/libstd/rt.rs:57
  14:     0x560ed90e7302 - main
  15:     0x7f0d53f16400 - __libc_start_main
  16:     0x560ed90e6659 - _start
  17:                0x0 - &lt;unknown&gt;

</code></pre>
<p><span class="caption">Listagem 9-2: O <em>backtrace</em> gerado por uma chamada
a <code>panic!</code> mostrado quando a vari√°vel de ambiente <code>RUST_BACKTRACE</code> est√° definida.</span></p>
<p>Isso √© bastante sa√≠da! A sa√≠da exata que voc√™ recebe pode ser diferente dependendo
do seu sistema operacional e vers√£o de Rust. Para conseguir <em>backtraces</em> com essa
informa√ß√£o, s√≠mbolos de debug devem estar ativados. S√≠mbolos de debug est√£o ativados
por padr√£o quando usamos cargo build ou cargo run sem a op√ß√£o de --release,
como temos aqui.</p>
<p>Na sa√≠da da Listagem 9-2, a linha 11 do <em>backtrace</em> aponta para a linha no nosso
projeto que est√° causando o problema: <em>src/main.rs</em> na linha 4. Se n√£o
queremos que nosso programa entre em p√¢nico, a localiza√ß√£o apontada pela primeira
linha mencionando um arquivo que escrevemos √© onde dever√≠amos come√ßar a investigar
para entender como chegamos nesse ponto com valores que causaram o p√¢nico. Na lista
9-1 onde n√≥s deliberadamente escrevemos c√≥digo que causaria p√¢nico para demonstrar
como usar <em>backtraces</em>, a forma de consertar o p√¢nico √© n√£o requisitar um elemento
no √≠ndice 100 de um vetor que cont√©m apenas tr√™s itens. Quando seu c√≥digo entrar
em p√¢nico no futuro, voc√™ precisar√° descobrir quais a√ß√µes o seu c√≥digo est√° tomando,
e com quais valores, que est√£o causando o p√¢nico, e o que deveria ser feito em vez
disso.</p>
<p>Voltaremos ao <code>panic!</code> e veremos mais adiante no cap√≠tulo quando us√°-lo, ou n√£o,
para lidar com erros. Em seguida, olharemos como se recuperar de um erro usando
<code>Result</code>.</p>
<a class="header" href="print.html#erros-recuper√°veis-com-result" id="erros-recuper√°veis-com-result"><h2>Erros recuper√°veis com <code>Result</code></h2></a>
<p>A maior parte dos erros n√£o s√£o s√©rios o suficiente para precisar que o
programa pare totalmente. √Äs vezes, quando uma fun√ß√£o falha, √© por uma
raz√£o que n√≥s podemos facilmente interpretar e responder. Por exemplo,
se tentamos abrir um arquivo e essa opera√ß√£o falhar porque o arquivo n√£o
existe, n√≥s podemos querer criar o arquivo em vez de terminar o processo.</p>
<p>Lembre-se do Cap√≠tulo 2, na se√ß√£o ‚Äú<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">Tratando Potenciais Falhas com o Tipo Result</a></p>
<!-- ignore -->‚Äù  que o enum `Result` √© definido como tendo duas variantes,
`Ok` e `Err`, como mostrado a seguir:
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>O <code>T</code> e <code>E</code> s√£o par√¢metros de tipos gen√©ricos: n√≥s os discutiremos em mais
detalhe no Cap√≠tulo 10. O que voc√™ precisa saber agora √© que <code>T</code> representa
o tipo do valor que vai ser retornado dentro da variante <code>Ok</code> em caso de sucesso,
e <code>E</code> representa o tipo de erro que ser√° retornado dentro da variante <code>Err</code>
em caso de falha. Por <code>Result</code> ter esses par√¢metros de tipo gen√©ricos, n√≥s
podemos usar o tipo <code>Result</code> e as fun√ß√µes que a biblioteca padr√£o definiu sobre
ele em diversas situa√ß√µes em que o valor de sucesso e o valor de erro que
queremos retornar possam divergir.</p>
<p>Vamos chamar uma fun√ß√£o que retorna um valor <code>Result</code> porque a fun√ß√£o poderia
falhar: na Listagem 9-3 tentamos abrir um arquivo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listagem 9-3: Abrindo um arquivo</span></p>
<p>Como sabemos que <code>File::open</code> retorna um <code>Result</code>? Poder√≠amos olhar na documenta√ß√£o
da API da biblioteca padr√£o, ou poder√≠amos perguntar para o compilador! Se damos √† <code>f</code>
uma anota√ß√£o de tipo que sabemos <em>n√£o</em> ser o tipo retornado pela fun√ß√£o e tentamos
compilar o c√≥digo, o compilador nos dir√° que os tipos n√£o casam. A mensagem de erro
vai ent√£o nos dizer qual √©, <em>de fato</em>, o tipo de <code>f</code>. Vamos tentar isso: n√≥s sabemos que
o tipo retornado por <code>File::open</code> n√£o √© <code>u32</code>, ent√£o vamos mudar a declara√ß√£o
<code>let f</code> para isso:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>Tentar compilar agora nos d√° a seguinte sa√≠da:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  = note:    found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>Isso nos diz que o valor de retorno de <code>File::open</code> √© um <code>Result&lt;T, E&gt;</code>.
O par√¢metro gen√©rico <code>T</code> foi preenchido aqui com o tipo do valor de sucesso,
<code>std::fs::File</code>, que √© um <em>handle</em> de arquivo. O tipo de <code>E</code> usado no valor
de erro √© <code>std::io::Error</code>.</p>
<p>Esse tipo de retorno significa que a chamada a <code>File::open</code> pode dar certo
e retornar para n√≥s um <em>handle</em> de arquivo que podemos usar pra ler ou escrever
nele. Essa chamada de fun√ß√£o pode tamb√©m falhar: por exemplo, o arquivo pode n√£o
existir ou talvez n√£o tenhamos permiss√£o para acessar o arquivo. A fun√ß√£o <code>File::open</code>
precisa ter uma maneira de nos dizer se ela teve sucesso ou falhou e ao mesmo tempo
nos dar ou o <em>handle</em> de arquivo ou informa√ß√£o sobre o erro. Essa informa√ß√£o √©
exatamente o que o enum <code>Result</code> comunica.</p>
<p>No caso em que <code>File::open</code> tem sucesso, o valor na vari√°vel <code>f</code> ser√° uma inst√¢ncia
de <code>Ok</code> que cont√©m um <em>handle</em> de arquivo. No caso em que ela falha, o valor em <code>f</code>
ser√° uma inst√¢ncia de <code>Err</code> que cont√©m mais informa√ß√£o sobre o tipo de erro que
aconteceu.</p>
<p>Devemos fazer com que o c√≥digo na Listagem 9-3 fa√ßa diferentes a√ß√µes dependendo
do valor retornado por <code>File::open</code>. A Listagem 9-4 mostra uma maneira de lidar
com o <code>Result</code> usando uma ferramenta b√°sica: a express√£o <code>match</code> que discutimos
no Cap√≠tulo 6.</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;Houve um problema ao abrir o arquivo: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listagem 9-4: Usando uma express√£o <code>match</code> para tratar as
variantes de <code>Result</code> que podemos encontrar.</span></p>
<p>Note que, como no enum <code>Option</code>, o enum <code>Result</code> e suas variantes foram importadas
no prel√∫dio, ent√£o n√£o precisamos especificar <code>Result::</code> antes das variantes <code>Ok</code>
e <code>Err</code> nas linhas de <code>match</code>.</p>
<p>Aqui dizemos ao Rust que quando o resultado √© <code>Ok</code> ele deve retornar o valor
interno <code>file</code> de dentro da variante <code>Ok</code> e n√≥s ent√£o podemos atribuir este
valor de <em>handle</em> de arquivo √† vari√°vel <code>f</code>. Depois do <code>match</code>, n√≥s podemos ent√£o
usar o <em>handle</em> de arquivo para ler ou escrever.</p>
<p>A outra linha de <code>match</code> trata do caso em que recebemos um valor de <code>Err</code> de
<code>File::open</code>. Nesse exemplo, n√≥s escolhemos chamar a macro <code>panic!</code>. Se n√£o
h√° nenhum arquivo chamado <em>hello.txt</em> no diret√≥rio atual e rodarmos esse c√≥digo,
veremos a seguinte sa√≠da da macro <code>panic!</code>:</p>
<pre><code class="language-text">thread 'main' panicked at 'Houve um problema ao abrir o arquivo: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12

</code></pre>
<p>Como sempre, essa sa√≠da nos diz exatamente o que aconteceu de errado.</p>
<a class="header" href="print.html#usando-match-com-diferentes-erros" id="usando-match-com-diferentes-erros"><h3>Usando <code>match</code> com Diferentes Erros</h3></a>
<p>O c√≥digo na Listagem 9-4 chamar√° <code>panic!</code> n√£o importa a raz√£o pra <code>File::open</code>
ter falhado. O que queremos fazer em vez disso √© tomar diferentes a√ß√µes para diferentes
motivos de falha: se <code>File::open</code> falhou porque o arquivo n√£o existe, n√≥s
queremos criar um arquivo e retornar o <em>handle</em> para ele. Se <code>File::open</code>
falhou por qualquer outra raz√£o, por exemplo porque n√£o temos a permiss√£o para
abrir o arquivo, n√≥s ainda queremos chamar <code>panic!</code> da mesma maneira que fizemos
na Listagem 9-4. Veja a Listagem 9-5, que adiciona outra linha ao <code>match</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tentou criar um arquivo e houve um problema: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;Houve um problema ao abrir o arquivo: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">Listagem 9-5: Tratando diferentes tipos de erros de diversas
maneiras.</span></p>
<p>O tipo do valor que <code>File::open</code> retorna dentro da variante <code>Err</code> √© <code>io::Error</code>,
que √© uma struct fornecida pela biblioteca padr√£o. Essa struct tem o m√©todo
<code>kind</code> que podemos chamar para receber um valor de <code>io::ErrorKind</code>. <code>io::ErrorKind</code>
√© um enum fornecido pela biblioteca padr√£o que tem variantes representanto diversos
tipos de erros que podem ocorrer em uma opera√ß√£o de <code>io</code>. A variante que queremos
usar √© <code>ErrorKind::NotFound</code>, que indica que o arquivo que queremos abrir n√£o existe
ainda.</p>
<p>A condi√ß√£o <code>if error.kind() == ErrorKind::NotFound</code> √© chamada de um <em>match guard</em>:
√© uma condi√ß√£o extra dentro de uma linha de <code>match</code> que posteriormente refina
o padr√£o da linha. Essa condi√ß√£o deve ser verdadeira para o c√≥digo da linha ser
executado; caso contr√°rio a an√°lise de padr√µes vai continuar considerando as
pr√≥ximas linhas no <code>match</code>. O <code>ref</code> no padr√£o √© necess√°rio para que o <code>error</code>
n√£o seja movido para a condi√ß√£o do <em>guard</em>, mas meramente referenciado por ele.
A raz√£o de <code>ref</code> ser utilizado em vez de <code>&amp;</code> para pegar uma refer√™ncia vai ser
discutida em detalhe no Cap√≠tulo 18. Resumindo, no contexto de um padr√£o, <code>&amp;</code>
corresponde a uma refer√™ncia e nos d√° seu valor, enquanto <code>ref</code> corresponde a um valor
e nos d√° uma refer√™ncia a ele.</p>
<p>A condi√ß√£o que queremos checar no <em>match guard</em> √© se o valor retornado pelo
<code>error.kind()</code> √© a variante <code>NotFound</code> do enum <code>ErrorKind</code>. Se √©, queremos
tentar criar um arquivo com <code>File::create</code>. No entanto, como <code>File::create</code>
pode tamb√©m falhar, precisamos adicionar um <code>match</code> interno tamb√©m. Quando
o arquivo n√£o pode ser aberto, outro tipo de mensagem de erro ser√° mostrada.
A √∫ltima linha do <code>match</code> externo continua a mesma de forma que o programa
entre em p√¢nico pra qualquer erro al√©m do de arquivo ausente.</p>
<a class="header" href="print.html#atalhos-para-p√¢nico-em-erro-unwrap-e-expect" id="atalhos-para-p√¢nico-em-erro-unwrap-e-expect"><h3>Atalhos para P√¢nico em Erro: <code>unwrap</code> e <code>expect</code></h3></a>
<p>Usar <code>match</code> funciona bem o suficiente, mas pode ser um pouco verboso e nem
sempre comunica t√£o bem a inten√ß√£o. O tipo <code>Result&lt;T, E&gt;</code> tem v√°rios m√©todos
auxiliares definidos para fazer diversas tarefas. Um desses m√©todos, chamado
<code>unwrap</code>, √© um m√©todo de atalho que √© implementado justamente como o <code>match</code> que
escrevemos na Listagem 9-4. Se o valor de <code>Result</code> for da variante <code>Ok</code>, <code>unwrap</code>
vai retornar o valor dentro de <code>Ok</code>. Se o <code>Result</code> for da variante <code>Err</code>, <code>unwrap</code>
vai chamar a macro <code>panic!</code>. Aqui um exemplo de <code>unwrap</code> em a√ß√£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Se rodarmos esse c√≥digo sem um arquivo <em>hello.txt</em>, veremos uma mensagem de erro
da chamada de <code>panic!</code> que o m√©todo <code>unwrap</code> faz:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>Outro m√©todo, <code>expect</code>, que √© semelhante a <code>unwrap</code>, nos deixa tamb√©m escolher
a mensagem de erro do <code>panic!</code>. Usar <code>expect</code> em vez de <code>unwrap</code> e fornecer
boas mensagens de erros podem transmitir sua inten√ß√£o e tornar a procura pela
fonte de p√¢nico mais f√°cil. A sintaxe de <code>expect</code> √© a seguinte:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Falhou ao abrir hello.txt&quot;);
}
</code></pre></pre>
<p>N√≥s usamos <code>expect</code> da mesma maneira que <code>unwrap</code>: para retornar o <em>handle</em> de arquivo
ou chamar a macro de <code>panic!</code>. A mensagem de erro usada por <code>expect</code> na sua chamada
de <code>panic!</code> ser√° o par√¢mtero que passamos para <code>expect</code> em vez da mensagem padr√£o
que o <code>unwrap</code> usa. Aqui est√° como ela aparece:</p>
<pre><code class="language-text">thread 'main' panicked at 'Falhou ao abrir hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>Como essa mensagem de erro come√ßa com o texto que especificamos, <code>Falhou ao abrir hello.txt</code>, ser√° mais f√°cil encontrar o trecho do c√≥digo de onde vem essa mensagem de erro. Se usamos <code>unwrap</code> em diversos lugares, pode tomar mais tempo encontrar
exatamente qual dos <code>unwrap</code> est√° causando o p√¢nico, dado que todas as chamadas
a <code>unwrap</code> chamam o print de p√¢nico com a mesma mensagem.</p>
<a class="header" href="print.html#propagando-erros" id="propagando-erros"><h3>Propagando Erros</h3></a>
<p>Quando voc√™ est√° escrevendo uma fun√ß√£o cuja implementa√ß√£o chama algo que pode
falhar, em vez de tratar o erro dentro dessa fun√ß√£o, voc√™ pode retornar o
erro ao c√≥digo que a chamou de forma que ele possa decidir o que fazer. Isso √©
conhecido como <em>propagar</em> o erro e d√° mais controle ao c√≥digo que chamou sua
fun√ß√£o, onde talvez haja mais informa√ß√£o sobre como tratar o erro
do que voc√™ tem dispon√≠vel no contexto do seu c√≥digo.</p>
<p>Por exemplo, a Listagem 9-6 mostra uma fun√ß√£o que l√™ um nome de usu√°rio de um arquivo.
Se o arquivo n√£o existe ou n√£o pode ser lido, essa fun√ß√£o vai retornar esses erros
ao c√≥digo que chamou essa fun√ß√£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-6: Uma fun√ß√£o que retorna erros ao c√≥digo que a chamou
usando <code>match</code></span></p>
<p>Vamos olhar primeiro ao tipo retornado pela fun√ß√£o: <code>Result&lt;String, io::Error&gt;</code>.
Isso significa que a fun√ß√£o est√° retornando um valor do tipo <code>Result&lt;T, E&gt;</code> onde
o par√¢metro gen√©rico <code>T</code> foi preenchido pelo tipo concreto <code>String</code> e o tipo gen√©rico
<code>E</code> foi preenchido pelo tipo concreto <code>io::Error</code>. Se essa fun√ß√£o tem sucesso sem
nenhum problema, o c√≥digo que chama essa fun√ß√£o vai receber um valor <code>Ok</code> que cont√©m
uma <code>String</code>- o nome de usu√°rio que essa fun√ß√£o leu do arquivo. Se essa fun√ß√£o
encontra qualquer problema, o c√≥digo que a chama receber√° um valor de <code>Err</code>
que cont√©m uma inst√¢ncia de <code>io::Error</code>, que cont√©m mais informa√ß√£o
sobre o que foi o problema. Escolhemos <code>io::Error</code> como o tipo de retorno
dessa fun√ß√£o porque √© este o tipo de erro retornado pelas
duas opera√ß√µes que estamos chamando no corpo dessa fun√ß√£o que podem falhar:
a fun√ß√£o <code>File::open</code> e o m√©todo <code>read_to_string</code>.</p>
<p>O corpo da fun√ß√£o come√ßa chamando a fun√ß√£o <code>File::open</code>. N√≥s ent√£o tratamos
o valor de <code>Result</code> retornado usando um <code>match</code> semelhante ao da Listagem 9-4,
s√≥ que em vez de chamar <code>panic!</code> no caso de <code>Err</code>, retornamos mais cedo dessa fun√ß√£o
e passamos o valor de erro de <code>File::open</code> de volta ao c√≥digo que a chamou, como o
valor de erro da nossa fun√ß√£o. Se <code>File::open</code> tem sucesso, n√≥s guardamos o <em>handle</em> de
arquivo na vari√°vel <code>f</code> e continuamos.</p>
<p>Ent√£o, criamos uma nova <code>String</code> na vari√°vel <code>s</code> e chamamos o m√©todo <code>read_to_string</code>
no <em>handle</em> de arquivo <code>f</code> para ler o conte√∫do do arquivo e armazen√°-lo em <code>s</code>. O m√©todo
<code>read_to_string</code> tamb√©m retorna um <code>Result</code> porque ele pode falhar, mesmo que
<code>File::open</code> teve sucesso. Ent√£o precisamos de outro <code>match</code> para tratar esse
<code>Result</code>: se <code>read_to_string</code> teve sucesso, ent√£o nossa fun√ß√£o teve sucesso, e n√≥s
retornamos o nome de usu√°rio lido do arquivo que est√° agora em <code>s</code>, encapsulado em um <code>Ok</code>.
Se <code>read_to_string</code> falhou, retornamos o valor de erro da mesma maneira que retornamos
o valor de erro no <code>match</code> que tratou o valor de retorno de <code>File::open</code>.
No entanto, n√£o precisamos explicitamente escrever <code>return</code>, porque essa j√° √© a
√∫ltima express√£o na fun√ß√£o.</p>
<p>O c√≥digo que chama nossa fun√ß√£o vai ent√£o receber ou um valor <code>Ok</code> que
cont√©m um nome de usu√°rio ou um valor de <code>Err</code> que cont√©m um <code>io::Error</code>. N√≥s
n√£o sabemos o que o c√≥digo que chamou nossa fun√ß√£o far√° com esses valores. Se o
c√≥digo que chamou recebe um valor de <code>Err</code>, ele poderia chamar <code>panic!</code> e causar
um crash, usar um nome de usu√°rio padr√£o, ou procurar o nome de usu√°rio em outro
lugar que n√£o um arquivo, por exemplo. N√≥s n√£o temos informa√ß√£o o suficiente sobre
o que o c√≥digo que chamou est√° de fato tentando fazer, ent√£o propagamos toda a
informa√ß√£o de sucesso ou erro para cima para que ele a trate apropriadamente.</p>
<p>Esse padr√£o de propaga√ß√£o de erros √© t√£o comum em Rust que a linguagem disponibiliza
o operador de interroga√ß√£o <code>?</code> para tornar isso mais f√°cil.</p>
<a class="header" href="print.html#um-atalho-para-propagar-erros-" id="um-atalho-para-propagar-erros-"><h4>Um Atalho Para Propagar Erros: <code>?</code></h4></a>
<p>A Listagem 9-7 mostra uma implementa√ß√£o de <code>read_username_from_file</code> que tem a
mesma funcionalidade que tinha na Listagem 9-6, mas esta implementa√ß√£o usa o operador
de interroga√ß√£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-7: Uma fun√ß√£o que retorna erros para o c√≥digo
que a chamou usando <code>?</code>.</span></p>
<p>O <code>?</code> colocado ap√≥s um valor de <code>Result</code> √© definido para funcionar quase
da mesma maneira que as express√µes <code>match</code> que definimos para tratar o valor
de <code>Result</code> na Listagem 9-6. Se o valor de <code>Result</code> √© um <code>Ok</code>, o valor dentro dele
vai ser retornado dessa express√£o e o programa vai continuar. Se o valor
√© um <code>Err</code>, o valor dentro dele vai ser retornado da fun√ß√£o inteira como se
tiv√©ssemos usado a palavra-chave <code>return</code> de modo que o valor de erro √© propagado
ao c√≥digo que chamou a fun√ß√£o.</p>
<p>A √∫nica diferen√ßa entre a express√£o <code>match</code> da Listagem 9-6 e o que o operador
de interroga√ß√£o faz √© que quando usamos o operador de interroga√ß√£o, os valores
de erro passam pela fun√ß√£o <code>from</code> definida no <em>trait</em> <code>From</code> na biblioteca
padr√£o. V√°rios tipos de erro implementam a fun√ß√£o <code>from</code> para converter um
erro de um tipo em outro. Quando usado pelo operador de
interroga√ß√£o, a chamada √† fun√ß√£o <code>from</code> converte o tipo de erro que o
operador recebe no tipo de erro definido no tipo de retorno da fun√ß√£o em
que estamos usando <code>?</code>. Isso √© √∫til quando partes de uma fun√ß√£o podem falhar
por v√°rias raz√µes diferentes, mas a fun√ß√£o retorna um tipo de erro que
representa todas as maneiras que a fun√ß√£o pode falhar. Enquanto cada
tipo de erro implementar a fun√ß√£o <code>from</code> para definir como se converter
ao tipo de erro retornado, o operador de interroga√ß√£o lida com a convers√£o
automaticamente.</p>
<p>No contexto da Listagem 9-7, o <code>?</code> no final da chamada de <code>File::open</code> vai
retornar o valor dentro do <code>Ok</code> √† vari√°vel <code>f</code>. Se um erro ocorrer, <code>?</code>
vai retornar mais cedo a fun√ß√£o inteira e dar um valor de <code>Err</code> ao c√≥digo
que a chamou. O mesmo se aplica ao <code>?</code> ao final da chamada de <code>read_to_string</code>.</p>
<p>O <code>?</code> elimina um monte de excesso e torna a implementa√ß√£o dessa
fun√ß√£o mais simples. Poder√≠amos at√© encurtar ainda mais esse c√≥digo
ao encadear chamadas de m√©todo imediatamente depois do <code>?</code>, como mostrado
na Listagem 9-8:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-8: Encadeando chamadas de m√©todo ap√≥s o operador
de interroga√ß√£o.</span></p>
<p>N√≥s movemos a cria√ß√£o da nova <code>String</code> em <code>s</code> para o come√ßo da fun√ß√£o;
essa parte n√£o mudou. Em vez de criar uma vari√°vel <code>f</code>, n√≥s encadeamos
a chamada para <code>read_to_string</code> diretamente ao resultado de
<code>File::open(&quot;hello.txt&quot;)?</code>. N√≥s ainda temos um <code>?</code> ao fim da chamada a
<code>read_to_string</code>, e ainda retornamos um valor de <code>Ok</code> contendo o nome de usu√°rio
em <code>s</code> quando ambos os m√©todos <code>File::open</code> e <code>read_to_string</code> tiveram sucesso ao inv√©s
de retornarem erros. Essa funcionalidade √© novamente a mesma da Listagem 9-6 e
Listagem 9-7; essa √© s√≥ uma maneira diferente e mais ergon√¥mica de escrev√™-la.</p>
<a class="header" href="print.html#-somente-pode-ser-usado-em-fun√ß√µes-que-retornam-result" id="-somente-pode-ser-usado-em-fun√ß√µes-que-retornam-result"><h4><code>?</code> Somente Pode Ser Usado em Fun√ß√µes Que Retornam Result</h4></a>
<p>O <code>?</code> s√≥ pode ser usado em fun√ß√µes que tem um tipo de retorno de <code>Result</code>,
porque est√° definido a funcionar da mesma maneira que a express√£o <code>match</code> que
definimos na Listagem 9-6. A parte do <code>match</code> que requer um tipo de retorno de
<code>Result</code> √© <code>return Err(e)</code>, ent√£o o tipo de retorno da fun√ß√£o deve ser
um <code>Result</code> para ser compat√≠vel com esse <code>return</code>.</p>
<p>Vamos ver o que ocorre quando usamos <code>?</code> na fun√ß√£o <code>main</code>, que como vimos, tem
um tipo de retorno de <code>()</code>:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>Quando compilamos esse c√≥digo recebemos a seguinte mensagem de erro:</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns
`Result` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             cannot use the `?` operator in a function that returns `()`
  |             in this macro invocation
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>Esse erro aponta que s√≥ podemos usar o operador de interroga√ß√£o em fun√ß√µes
que retornam <code>Result</code>. Em fun√ß√µes que n√£o retornam <code>Result</code>, quando voc√™ chama
outras fun√ß√µes que retornam <code>Result</code>, voc√™ deve usar um <code>match</code> ou um dos m√©todos
de <code>Result</code> para trat√°-lo em vez de usar <code>?</code> para potencialmente
propagar o erro ao c√≥digo que a chamou.</p>
<p>Agora que discutimos os detalhes de chamar <code>panic!</code> ou retornar <code>Result</code>, vamos
retornar ao t√≥pico de como decidir qual √© apropriado para utilizar em quais
casos.</p>
<a class="header" href="print.html#entrar-em-panic-ou-n√£o-entrar-em-panic" id="entrar-em-panic-ou-n√£o-entrar-em-panic"><h2>Entrar em <code>panic!</code> ou N√£o Entrar em <code>panic!</code></h2></a>
<p>Ent√£o como voc√™ decide quando entrar em <code>panic!</code> e quando voc√™ deveria retornar
um <code>Result</code>? Quando o c√≥digo entra em p√¢nico, n√£o h√° maneira de se recuperar. Voc√™
poderia chamar <code>panic!</code> para qualquer situa√ß√£o de erro, tendo uma maneira de se recuperar
ou n√£o, mas ent√£o voc√™ estaria decidindo no lugar do c√≥digo que chama seu c√≥digo
que a situa√ß√£o √© irrecuper√°vel. Quando voc√™ decide retornar um valor de <code>Result</code>,
voc√™ lhe d√° op√ß√µes em vez de tomar a decis√£o por ele. O c√≥digo
que chama seu c√≥digo pode tentar se recuperar de uma maneira que √© apropriada para
a situa√ß√£o, ou ele pode decidir que um valor de <code>Err</code> nesse caso √© irrecuper√°vel,
chamando <code>panic!</code> e transformando seu erro recuper√°vel em um irrecuper√°vel.
Portanto, retornar <code>Result</code> √© uma boa escolha padr√£o quando voc√™ est√° definindo
uma fun√ß√£o que pode falhar.</p>
<p>Em algumas situa√ß√µes √© mais apropriado escrever c√≥digo que entra em p√¢nico em vez
de retornar um <code>Result</code>, mas eles s√£o menos comuns. Vamos explorar porque √© apropriado
entrar em p√¢nico em alguns exemplos, prot√≥tipos de c√≥digo e testes; depois situa√ß√µes
em que voc√™ como humano pode saber que um m√©todo n√£o vai falhar, mas que o compilador n√£o
tem como saber; e concluir com algumas diretrizes sobre como decidir entrar ou
n√£o em p√¢nico em c√≥digo de biblioteca.</p>
<a class="header" href="print.html#exemplos-prot√≥tipos-e-testes-s√£o-todos-lugares-em-que-√â-perfeitamente-ok-entrar-em-p√¢nico" id="exemplos-prot√≥tipos-e-testes-s√£o-todos-lugares-em-que-√â-perfeitamente-ok-entrar-em-p√¢nico"><h3>Exemplos, Prot√≥tipos, e Testes S√£o Todos Lugares em que √â Perfeitamente Ok Entrar em P√¢nico</h3></a>
<p>Quando voc√™ est√° escrevendo um exemplo para ilustrar algum conceito, ter c√≥digo
de tratamento de erro robusto junto do exemplo pode torn√°-lo menos claro. Em exemplos,
√© compreens√≠vel que uma chamada a um m√©todo como <code>unwrap</code> que poderia chamar <code>panic!</code>
apenas substitua a maneira como voc√™ trataria erros na sua aplica√ß√£o,
que pode ser diferente baseado no que o resto do seu c√≥digo est√° fazendo.</p>
<p>De forma semelhante, os m√©todos <code>unwrap</code> e <code>expect</code> s√£o bem √∫teis ao fazer
prot√≥tipos, antes de voc√™ estar pronto para decidir como tratar erros. Eles deixam
marcadores claros no seu c√≥digo para quando voc√™ estiver pronto para tornar
seu programa mais robusto.</p>
<p>Se uma chamada de m√©todo falha em um teste, queremos que o teste inteiro falhe,
mesmo se esse m√©todo n√£o √© a funcionalidade sendo testada. Como <code>panic!</code> √© o modo
que um teste √© marcado como falha, chamar <code>unwrap</code> ou <code>expect</code> √© exatamente o que
deveria acontecer.</p>
<a class="header" href="print.html#casos-em-que-voc√™-tem-mais-informa√ß√£o-que-o-compilador" id="casos-em-que-voc√™-tem-mais-informa√ß√£o-que-o-compilador"><h3>Casos em que Voc√™ Tem Mais Informa√ß√£o Que o Compilador</h3></a>
<p>Seria tamb√©m apropriado chamar <code>unwrap</code> quando voc√™ tem outra l√≥gica que
assegura que o <code>Result</code> vai ter um valor <code>Ok</code>, mas essa l√≥gica n√£o √© algo
que o compilador entenda. Voc√™ ainda vai ter um valor de <code>Result</code> que precisa
lidar: seja qual for a opera√ß√£o que voc√™ est√° chamando, ela ainda tem uma possibilidade
de falhar em geral, mesmo que seja logicamente imposs√≠vel que isso ocorra nessa
situa√ß√£o particular. Se voc√™ consegue assegurar ao inspecionar manualmente o c√≥digo que
voc√™ nunca tera uma variante <code>Err</code>, √© perfeitamente aceit√°vel chamar <code>unwrap</code>.
Aqui temos um exemplo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home = &quot;127.0.0.1&quot;.parse::&lt;IpAddr&gt;().unwrap();
#}</code></pre></pre>
<p>N√≥s estamos criando uma inst√¢ncia <code>IpAddr</code> ao analisar uma string <em>hardcoded</em>. N√≥s
podemos ver que <code>127.0.0.1</code> √© um endere√ßo de IP v√°lido, ent√£o √© aceit√°vel usar
<code>unwrap</code> aqui. No entanto, ter uma string v√°lida <em>hardcoded</em> n√£o muda o tipo retornado
pelo m√©todo <code>parse</code>: ainda teremos um valor de <code>Result</code>, e o compilador ainda
vai nos fazer tratar o <code>Result</code> como se a variante <code>Err</code> fosse uma
possibilidade, porque o compilador n√£o √© inteligente o bastante para ver que essa string
√© sempre um endere√ßo IP v√°lido. Se a string de endere√ßo IP viesse de um usu√°rio ao inv√©s
de ser <em>hardcoded</em> no programa, e portanto, de fato tivesse uma possibilidade de falha, n√≥s
definitivamente ir√≠amos querer tratar o <code>Result</code> de uma forma mais robusta.</p>
<a class="header" href="print.html#diretrizes-para-tratamento-de-erro" id="diretrizes-para-tratamento-de-erro"><h3>Diretrizes para Tratamento de Erro</h3></a>
<p>√â aconselh√°vel fazer que seu c√≥digo entre em <code>panic!</code> quando √© poss√≠vel que
ele entre em um mau estado. Nesse contexto, mau estado √© quando
alguma hip√≥tese, garantia, contrato ou invariante foi quebrada, tal como
valores inv√°lidos, valores contradit√≥rios, ou valores faltando que s√£o passados
a seu c√≥digo - al√©m de um ou mais dos seguintes:</p>
<ul>
<li>O mau estado n√£o √© algo que √© <em>esperado</em> que aconte√ßa ocasionalmente.</li>
<li>Seu c√≥digo ap√≥s certo ponto precisa confiar que ele n√£o est√° nesse mau estado.</li>
<li>N√£o h√° uma forma boa de codificar essa informa√ß√£o nos tipos que voc√™ usa.</li>
</ul>
<p>Se algu√©m chama seu c√≥digo e passa valores que n√£o fazem sentido, a melhor escolha
talvez seja entrar em <code>panic!</code> e alertar a pessoa usando sua biblioteca do bug no
c√≥digo dela para que ela possa consert√°-la durante o desenvolvimento. Similarmente,
<code>panic!</code> √© em geral apropriado se voc√™ est√° chamando c√≥digo externo que est√° fora
do seu controle e ele retorna um estado inv√°lido que voc√™ n√£o tem como consertar.</p>
<p>Quando se chega a um mau estado, mas isso √© esperado que aconte√ßa n√£o importa
qu√£o bem voc√™ escreva seu c√≥digo, ainda √© mais apropriado retornar um <code>Result</code>
a fazer uma chamada a <code>panic!</code>. Um exemplo disso √© um <em>parser</em> recebendo dados
malformados ou uma requisi√ß√£o HTTP retornando um status que indique que voc√™ atingiu
um limite de taxa. Nesses casos, voc√™ deveria indicar que falha √© uma possibilidade
esperada ao retornar um <code>Result</code> para propagar esses estados ruins para cima,
de forma que o c√≥digo que chamou seu c√≥digo pode decidir como tratar o problema.
Entrar em <code>panic!</code> n√£o seria a melhor maneira de lidar com esses casos.</p>
<p>Quando seu c√≥digo realiza opera√ß√µes em valores, ele deveria verificar que os valores
s√£o v√°lidos primeiro, e entrar em <code>panic!</code> caso n√£o sejam. Isso √©
em boa parte por raz√µes de seguran√ßa: tentar operar em dados inv√°lidos pode expor seu
c√≥digo a vulnerabilidades. Essa √© a principal raz√£o para a biblioteca padr√£o entrar em
<code>panic!</code> se voc√™ tentar um acesso de mem√≥ria fora dos limites: tentar acessar mem√≥ria
que n√£o pertence √† estrutura de dados atual √© um problema de seguran√ßa comum. Fun√ß√µes
frequentemente tem <em>contratos</em>: seu comportamento somente √© garantido se os inputs cumprem
requerimentos espec√≠ficos. Entrar em p√¢nico quando o contrato √© violado faz sentido
porque uma viola√ß√£o de contrato sempre indica um bug da parte do chamador, e n√£o √© o tipo
de erro que voc√™ quer que seja tratado explicitamente. De fato,
n√£o h√° nenhuma maneira razo√°vel para o c√≥digo chamador se recuperar: os <em>programadores</em>
que precisam consertar o c√≥digo. Contratos para uma fun√ß√£o, especialmente quando uma
viola√ß√£o leva a p√¢nico, devem ser explicados na documenta√ß√£o da API da fun√ß√£o.</p>
<p>No entanto, ter v√°rias checagens de erro em todas suas fun√ß√µes pode ser verboso
e irritante. Felizmente, voc√™ pode usar o sistema de tipos do Rust (e portanto a
checagem que o compilador faz) para fazer v√°rias dessas checagens para voc√™. Se
sua fun√ß√£o tem um tipo particular como par√¢metro, voc√™ pode continuar com a l√≥gica
do seu c√≥digo sabendo que o compilador j√° assegurou que voc√™ tem um valor v√°lido.
Por exemplo, se voc√™ tem um tipo em vez de uma <code>Option</code>, seu programa espera
ter <em>algo</em> ao inv√©s de <em>nada</em>. Seu c√≥digo n√£o precisa tratar dois casos para
as variantes <code>Some</code> e <code>None</code>: ele vai somente ter um caso para definitivamente ter
um valor. Um c√≥digo que tente passar nada para sua fun√ß√£o n√£o vai nem compilar,
ent√£o sua fun√ß√£o n√£o precisa checar esse caso em tempo de execu√ß√£o. Outro exemplo √© usar
um tipo de inteiro sem sinal como <code>u32</code>, que assegura que o par√¢metro nunca √©
negativo.</p>
<a class="header" href="print.html#criando-tipos-customizados-para-valida√ß√£o" id="criando-tipos-customizados-para-valida√ß√£o"><h3>Criando Tipos Customizados para Valida√ß√£o</h3></a>
<p>Vamos dar um passo al√©m na ideia de usar o sistema de tipos de Rust para assegurar que temos
um valor v√°lido e ver como criar um tipo customizado para valida√ß√£o.
Lembre do jogo de adivinha√ß√£o no Cap√≠tulo 2 onde nosso c√≥digo pedia ao usu√°rio
para adivinhar um n√∫mero entre 1 e 100. N√≥s nunca validamos que o chute do usu√°rio
fosse entre esses n√∫meros antes de compar√°-lo com o n√∫mero secreto; n√≥s somente
validamos que o chute era positivo. Nesse caso, as consequ√™ncias n√£o foram t√£o
dr√°sticas: nosso output de &quot;Muito alto&quot; ou &quot;Muito baixo&quot; ainda estariam corretos. Seria
uma melhoria √∫til guiar o usu√°rio para chutes v√°lidos, e ter um comportamento distinto
quando um usu√°rio chuta um n√∫mero fora do limite e quando um usu√°rio digita letras, por exemplo.</p>
<p>Uma maneira de fazer isso seria interpretar o chute como um <code>i32</code> em vez de
somente um <code>u32</code> para permitir n√∫meros potenciamente negativos, e ent√£o adicionar
uma checagem se o n√∫mero est√° dentro dos limites, conforme a seguir:</p>
<pre><code class="language-rust ignore">loop {
    // snip

    let palpite: i32 = match palpite.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if palpite &lt; 1 || palpite &gt; 100 {
        println!(&quot;O n√∫mero secreto vai estar entre 1 e 100.&quot;);
        continue;
    }

    match palpite.cmp(&amp;numero_secreto) {
    // snip
}
</code></pre>
<p>A express√£o <code>if</code> checa se nosso valor est√° fora dos limites, informa o usu√°rio
sobre o problema, e chama <code>continue</code> para come√ßar a pr√≥xima itera√ß√£o do loop
e pedir por outro chute. Depois da express√£o <code>if</code> podemos proceder com as
compara√ß√µes entre <code>palpite</code> e o n√∫mero secreto sabendo que <code>palpite</code> est√°
entre 1 e 100.</p>
<p>No entanto, essa n√£o √© a solu√ß√£o ideal: se fosse absolutamente cr√≠tico que o
programa somente operasse em valores entre 1 e 100, e ele tivesse v√°rias fun√ß√µes
com esse requisito, seria tedioso (e potencialmente impactante na performance)
ter uma checagem dessa em cada fun√ß√£o.</p>
<p>Em vez disso, podemos fazer um novo tipo e colocar as valida√ß√µes em uma fun√ß√£o
para criar uma inst√¢ncia do tipo em vez de repetir as valida√ß√µes em todo lugar.
Dessa maneira, √© seguro para fun√ß√µes usarem o novo tipo nas suas assinaturas e
confidentemente usar os valores que recebem. A Listagem 9-9  mostra uma maneira de
definir um tipo <code>Palpite</code> que vai somente criar uma inst√¢ncia de <code>Palpite</code> se a fun√ß√£o
<code>new</code> receber um valor entre 1 e 100:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Palpite {
    valor: u32,
}

impl Palpite {
    pub fn new(valor: u32) -&gt; Palpite {
        if valor &lt; 1 || valor &gt; 100 {
            panic!(&quot;Valor de chute deve ser entre 1 e 100, recebi {}.&quot;, valor);
        }

        Palpite {
            valor
        }
    }

    pub fn valor(&amp;self) -&gt; u32 {
        self.valor
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 9-9: Um tipo <code>Palpite</code> que somente funciona com valores
entre 1 e 100.</span></p>
<p>Primeiro, definimos uma struct chamada <code>Palpite</code> que tem um campo chamado <code>valor</code>
que guarda um <code>u32</code>. Isso √© onde o n√∫mero vai ser guardado.</p>
<p>Ent√£o n√≥s implementamos uma fun√ß√£o associada chamada <code>new</code> em <code>Palpite</code> que cria
inst√¢ncias de valores <code>Palpite</code>. A fun√ß√£o <code>new</code> √© definida a ter um par√¢metro
chamado <code>valor</code> de tipo <code>u32</code> e retornar um <code>Palpite</code>. O c√≥digo no corpo da fun√ß√£o
<code>new</code> testa para ter certeza que <code>valor</code> est√° entre 1 e 100. Se <code>valor</code> n√£o passa
nesse teste, fazemos uma chamada a <code>panic!</code>, que vai alertar ao programador que
est√° escrevendo o c√≥digo chamando a fun√ß√£o que ele tem um bug que precisa ser
corrigido, porque criar um <code>Palpite</code> com um <code>valor</code> fora desses limites violaria
o contrato em que <code>Palpite::new</code> se baseia. As condi√ß√µes em que <code>Palpite::new</code> pode
entrar em p√¢nico devem ser discutidas na sua documenta√ß√£o da API voltada ao p√∫blico;
no Cap√≠tulo 14 n√≥s cobriremos conven√ß√µes de documenta√ß√£o indicando a possibilidade de um <code>panic!</code>
na documenta√ß√£o de API. Se <code>valor</code> de fato passa no
teste, criamos um novo <code>Palpite</code> com o campo <code>valor</code> preenchido com o par√¢metro
<code>valor</code> e retornamos o <code>Palpite</code>.</p>
<p>Em seguida, implementamos um m√©todo chamado <code>valor</code> que pega <code>self</code> emprestado, n√£o
tem nenhum outro par√¢metro, e retorna um <code>u32</code>. Esse √© o tipo de m√©todo √†s vezes
chamado de <em>getter</em>, pois seu prop√≥sito √© pegar um dado de um dos campos e o retornar.
Esse m√©todo p√∫blico √© necess√°rio porque o campo <code>valor</code> da struct <code>Palpite</code> √© privado.
√â importante que o campo <code>valor</code> seja privado para que c√≥digo usando a struct <code>Palpite</code>
n√£o tenha permiss√£o de definir o valor de <code>valor</code> diretamente: c√≥digo de fora do m√≥dulo
<em>deve</em> usar a fun√ß√£o <code>Palpite::new</code> para criar uma inst√¢ncia de <code>Palpite</code>, o que certifica
que n√£o h√° maneira de um <code>Palpite</code> ter um <code>valor</code> que n√£o foi checado pelas condi√ß√µes
definidas na fun√ß√£o <code>Palpite::new</code>.</p>
<p>Uma fun√ß√£o que tem um par√¢metro ou retorna somente n√∫meros entre 1 e 100 pode
ent√£o declarar na sua assinatura que ela recebe ou retorna um <code>Palpite</code> em vez
de um <code>u32</code> e n√£o precisaria fazer nenhuma checagem adicional no seu corpo.</p>
<a class="header" href="print.html#resumo-4" id="resumo-4"><h2>Resumo</h2></a>
<p>As ferramentas de tratamento de erros de Rust s√£o feitas para te ajudar a escrever
c√≥digo mais robusto. A macro <code>panic!</code> sinaliza que seu programa est√° num estado que
n√£o consegue lidar e deixa voc√™ parar o processo ao inv√©s de tentar prosseguir com
valores inv√°lidos ou incorretos. O enum <code>Result</code> usa o sistema de tipos de Rust para
indicar que opera√ß√µes podem falhar de uma maneira que seu c√≥digo pode se recuperar.
Voc√™ pode usar <code>Result</code> para dizer ao c√≥digo que chama seu c√≥digo que ele precisa
tratar potenciais sucessos ou falhas tamb√©m. Usar <code>panic!</code> e <code>Result</code> nas situa√ß√µes
apropriadas far√° seu c√≥digo mais confi√°vel em face aos problemas inevit√°veis.</p>
<p>Agora que voc√™ viu as maneiras √∫teis em que a biblioteca padr√£o usa gen√©ricos com
os enums <code>Option</code> e <code>Result</code>, n√≥s falaremos como gen√©ricos funcionam e como voc√™
pode us√°-los em seu c√≥digo no pr√≥ximo cap√≠tulo.</p>
<a class="header" href="print.html#generics" id="generics"><h1>Generics</h1></a>
<a class="header" href="print.html#syntax" id="syntax"><h1>Syntax</h1></a>
<a class="header" href="print.html#traits" id="traits"><h1>Traits</h1></a>
<a class="header" href="print.html#lifetime-syntax" id="lifetime-syntax"><h1>Lifetime syntax</h1></a>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<a class="header" href="print.html#writing-tests" id="writing-tests"><h1>Writing tests</h1></a>
<a class="header" href="print.html#running-tests" id="running-tests"><h1>Running tests</h1></a>
<a class="header" href="print.html#test-organization" id="test-organization"><h1>Test Organization</h1></a>
<a class="header" href="print.html#an-io-project" id="an-io-project"><h1>An I/O Project</h1></a>
<a class="header" href="print.html#accepting-command-line-arguments" id="accepting-command-line-arguments"><h1>Accepting Command Line Arguments</h1></a>
<a class="header" href="print.html#reading-a-file" id="reading-a-file"><h1>Reading a File</h1></a>
<a class="header" href="print.html#improving-error-handling-and-modularity" id="improving-error-handling-and-modularity"><h1>Improving Error Handling and Modularity</h1></a>
<a class="header" href="print.html#testing-the-librarys-functionality" id="testing-the-librarys-functionality"><h1>Testing the Library's Functionality</h1></a>
<a class="header" href="print.html#working-with-environment-variables" id="working-with-environment-variables"><h1>Working with Environment Variables</h1></a>
<a class="header" href="print.html#writing-to-stderr-instead-of-stdout" id="writing-to-stderr-instead-of-stdout"><h1>Writing to <code>stderr</code> instead of <code>stdout</code></h1></a>
<a class="header" href="print.html#functional-language-features-in-rust" id="functional-language-features-in-rust"><h1>Functional Language Features in Rust</h1></a>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<a class="header" href="print.html#iterators" id="iterators"><h1>Iterators</h1></a>
<a class="header" href="print.html#improving-our-io-project" id="improving-our-io-project"><h1>Improving our I/O Project</h1></a>
<a class="header" href="print.html#performance" id="performance"><h1>Performance</h1></a>
<a class="header" href="print.html#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio"><h1>More about Cargo and Crates.io</h1></a>
<a class="header" href="print.html#release-profiles" id="release-profiles"><h1>Release Profiles</h1></a>
<a class="header" href="print.html#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio"><h1>Publishing a Crate to Crates.io</h1></a>
<a class="header" href="print.html#cargo-workspaces" id="cargo-workspaces"><h1>Cargo Workspaces</h1></a>
<a class="header" href="print.html#installing-binaries-from-cratesio-with-cargo-install" id="installing-binaries-from-cratesio-with-cargo-install"><h1>Installing Binaries from Crates.io with <code>cargo install</code></h1></a>
<a class="header" href="print.html#extending-cargo-with-custom-commands" id="extending-cargo-with-custom-commands"><h1>Extending Cargo with Custom Commands</h1></a>
<a class="header" href="print.html#smart-pointers" id="smart-pointers"><h1>Smart Pointers</h1></a>
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<a class="header" href="print.html#is-rust-oop" id="is-rust-oop"><h1>Is Rust OOP?</h1></a>
<a class="header" href="print.html#patterns" id="patterns"><h1>Patterns</h1></a>
<a class="header" href="print.html#more-lifetimes" id="more-lifetimes"><h1>More Lifetimes</h1></a>
<a class="header" href="print.html#advanced-type-system-features" id="advanced-type-system-features"><h1>Advanced Type System Features</h1></a>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="print.html#keywords" id="keywords"><h1>Keywords</h1></a>
<a class="header" href="print.html#operators" id="operators"><h1>Operators</h1></a>
<a class="header" href="print.html#derivable-traits" id="derivable-traits"><h1>Derivable Traits</h1></a>
<a class="header" href="print.html#nightly-rust" id="nightly-rust"><h1>Nightly Rust</h1></a>
<a class="header" href="print.html#macros" id="macros"><h1>Macros</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
