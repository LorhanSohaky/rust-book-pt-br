<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Slices - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> üáßüá∑ Introdu√ß√£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> üáßüá∑ Instala√ß√£o</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> üáßüá∑ Ol√°, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> üáßüá∑ Jogo de Adivinha√ß√£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> üáßüá∑ Conceitos Comuns de Programa√ß√£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> üáßüá∑ Vari√°veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html" class="active"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> üáßüá∑ Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> üáßüá∑ Enums e Casamento de Padr√µes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> üáßüá∑ Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> üáßüá∑ Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> üáßüá∑ Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> üáßüá∑ M√≥dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> üáßüá∑ mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> üáßüá∑ Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> üáßüá∑ Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> üáßüá∑ Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> üáßüá∑ Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> üáßüá∑ Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generics</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Syntax</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Lifetime syntax</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust OOP?</a></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch04-03-slices.html#slices" id="slices"><h2><em>Slices</em></h2></a>
<p>Outro tipo de dados em que n√£o h√° ownership √© a <em>slice</em> (do ingl√™s, fatia).
Slices lhe permitem referenciar uma sequ√™ncia cont√≠gua de elementos em uma
cole√ß√£o em vez de referenciar a cole√ß√£o inteira.</p>
<p>Aqui est√° um pequeno problema de programa√ß√£o: escrever uma fun√ß√£o que pega uma
string e retorna a primeira palavra que encontrar dentro dela. Se a fun√ß√£o n√£o
encontrar um espa√ßo na string, significa que a string inteira √© uma palavra s√≥,
ent√£o a string toda deve ser retornada.</p>
<p>Vamos pensar sobre a assinatura desta fun√ß√£o:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; ?
</code></pre>
<p>Esta fun√ß√£o, <code>primeira_palavra</code>, tem uma <code>&amp;String</code> como par√¢metro. N√≥s n√£o
queremos tomar posse dela, ent√£o tudo bem. Mas o que n√≥s dever√≠amos retornar?
N√£o temos uma forma de falar sobre <em>parte</em> de uma string. No entanto, poder√≠amos
retornar o √≠ndice do final de uma palavra. Vamos tentar fazer isso, conforme
mostrado na Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<p><span class="caption">Listagem 4-5: A fun√ß√£o <code>primeira_palavra</code>, que retorna um
√≠ndice para um byte da <code>String</code> passada como par√¢metro.</span></p>
<p>Vamos dividir este c√≥digo em algumas partes. Como precisamos varrer a <code>String</code>
elemento por elemento, e verificar se algum valor √© um espa√ßo, vamos converter
nossa <code>String</code> em um array de bytes usando o m√©todo <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Depois, criamos um iterador sobre o array de bytes usando o m√©todo <code>iter</code>:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Vamos discutir sobre iteradores em mais detalhes no Cap√≠tulo 13. Por enquanto,
saiba que <code>iter</code> √© um m√©todo que retorna cada elemento em uma cole√ß√£o, e
<code>enumerate</code> encapsula o resultado do <code>iter</code> e retorna cada elemento como parte
de uma tupla. O primeiro elemento da tupla √© o √≠ndice, e o segundo elemento √©
uma refer√™ncia ao valor. Isto √© um pouco mais conveniente do que calcular o
√≠ndice n√≥s mesmos.</p>
<p>Como o m√©todo <code>enumerate</code> retorna uma tupla, podemos usar padr√µes para
desestruturar esta tupla, assim como qualquer outra coisa em Rust. Ent√£o, no
<code>for</code>, especificamos um padr√£o que tem <code>i</code> para o √≠ndice na tupla e <code>&amp;item</code> para
o byte. Como pegamos uma refer√™ncia ao elemento atrav√©s do
<code>.iter().enumerate()</code>, usamos um <code>&amp;</code> neste padr√£o.</p>
<p>N√≥s procuramos o byte que representa um espa√ßo usando a sintaxe de byte literal.
Se encontrarmos um espa√ßo, retornamos a posi√ß√£o dele. Caso contr√°rio, retornamos
o tamanho da string usando <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>Agora temos uma forma de descobrir o √≠ndice do fim da primeira palavra na
string, mas tem um problema. Estamos retornando um <code>usize</code> por si s√≥, mas ele s√≥
possui um significado no contexto da <code>&amp;String</code>. Em outras palavras, como √© um
valor separado da <code>String</code>, n√£o h√° garantia de que ele ainda ser√° v√°lido no
futuro. Considere o programa na Listagem 4-6, que usa a fun√ß√£o da Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = primeira_palavra(&amp;s); // palavra vai ter o valor 5.

    s.clear(); // Isso esvazia a String, deixando ela igual a &quot;&quot;.

    // palavra ainda tem o valor 5 aqui, mas j√° n√£o h√° mais uma string para a
    // qual o valor 5 fa√ßa algum sentido. palavra agora √© totalmente inv√°lida!
}
</code></pre></pre>
<p><span class="caption">Listagem 4-6: Armazenando o resultado de uma chamada √†
fun√ß√£o <code>primeira_palavra</code>, e depois, mudando o conte√∫do da <code>String</code>.</span></p>
<p>Este programa compila sem erros, e tamb√©m o faria se us√°ssemos a vari√°vel
<code>palavra</code> depois de chamar <code>s.clear()</code>. <code>palavra</code> n√£o est√° conectada ao estado
de <code>s</code> de nenhuma forma, ent√£o, <code>palavra</code> ainda cont√©m o valor <code>5</code>. Poder√≠amos
usar esse valor <code>5</code> com a vari√°vel <code>s</code> para tentar extrair a primeira palavra da
string, mas isso seria um bug, pois o conte√∫do de <code>s</code> j√° mudou ap√≥s termos salvo
o valor <code>5</code> na vari√°vel <code>word</code>.</p>
<p>Ter que se preocupar sobre o √≠ndice da <code>palavra</code> ficar fora de sincronia com os
dados em <code>s</code> √© tedioso e propenso a erros! Gerenciar esses √≠ndices √© ainda mais
delicado se escrevermos uma fun√ß√£o <code>segunda_palavra</code>. Sua assinatura teria que
ser algo do tipo:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Agora estamos rastreando os √≠ndices do in√≠cio <em>e</em> do final, e temos ainda mais
valores que s√£o calculados a partir dos dados em um estado particular, mas que
n√£o est√£o vinculados a este estado de nenhuma forma. Agora temos tr√™s vari√°veis
n√£o relacionadas flutuando que precisam ser mantidas em sincronia.</p>
<p>Felizmente, Rust possui uma solu√ß√£o para este problema: slices de string.</p>
<a class="header" href="ch04-03-slices.html#slices-de-string" id="slices-de-string"><h3>Slices de String</h3></a>
<p>Uma <em>slice de string</em> √© uma refer√™ncia para uma parte de uma <code>String</code>, e tem a
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto longo&quot;);

let texto = &amp;s[0..5];
let longo = &amp;s[6..11];
#}</code></pre></pre>
<p>Isto √© similar a pegar uma refer√™ncia √† <code>String</code> inteira, mas com um <code>[0..5]</code> a
mais. Em vez de uma refer√™ncia √† <code>String</code> inteira, trata-se de uma refer√™ncia a
uma por√ß√£o da <code>String</code>. A sintaxe <code>in√≠cio..fim</code> representa um <em>range</em>
(uma faixa) que come√ßa em <code>in√≠cio</code> e continua at√©, mas n√£o incluindo, <code>fim</code>.</p>
<p>Podemos criar slices usando um range entre colchetes especificando
<code>[√≠ndice_inicial..√≠ndice_final]</code>, em que <code>√≠ndice_inicial</code> √© a primeira posi√ß√£o
inclusa na slice, e <code>√≠ndice_final</code> √© um a mais que a √∫ltima posi√ß√£o inclusa na
slice. Internamente, a estrutura de dados de uma slice armazena a posi√ß√£o
inicial e o tamanho da slice, que corresponde a <code>√≠ndice_final</code> menos
<code>√≠ndice_inicial</code>. Ent√£o, no caso do <code>let longo = &amp;s[6..11];</code>, <code>longo</code> seria uma
slice que cont√©m um ponteiro para o s√©timo byte de <code>s</code> (√≠ndice 6) e um tamanho
igual a 5.</p>
<p>A Figura 4-6 mostra isto em um diagrama.</p>
<p><img alt="mundo contendo um ponteiro para o 7o byte da String s e um tamanho 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figura 4-6: Slice referente a uma parte de uma
<code>String</code></span></p>
<p>Com a sintaxe de range do Rust (<code>..</code>), se voc√™ quiser come√ßar com o primeiro
elemento (√≠ndice zero), voc√™ pode omitir o valor antes dos dois pontos. Em
outras palavras, estas formas s√£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>Da mesma forma, se a sua slice inclui o √∫ltimo byte da <code>String</code>, voc√™ pode
omitir o √∫ltimo n√∫mero. Isso significa que as seguintes formas s√£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[3..tamanho];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>Voc√™ tamb√©m pode omitir ambos os valores para pegar uma slice da string inteira.
Logo, essas duas formas s√£o equivalentes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[0..tamanho];
let slice = &amp;s[..];
#}</code></pre></pre>
<blockquote>
<p>Nota: Os √≠ndices do range de uma slice de string devem coincidir com os
limites entre caracteres UTF-8 v√°lidos. Se voc√™ tentar criar uma slice de
string no meio de um caractere que tenha mais de um byte, seu programa vai
terminar com erro. Para introduzir slices de string, estamos utilizando
apenas caracteres ASCII nesta se√ß√£o; uma discuss√£o mais detalhada sobre
manipula√ß√£o de caracteres UTF-8 ser√° feita na se√ß√£o &quot;Strings&quot; do Cap√≠tulo 8.</p>
</blockquote>
<p>Com toda essa informa√ß√£o em mente, vamos reescrever a fun√ß√£o <code>primeira_palavra</code>
para retornar uma slice. O tipo que representa &quot;slice de string&quot; √© escrito como
<code>&amp;str</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>Pegamos o √≠ndice para o fim da palavra da mesma forma como fizemos na Listagem
4-5, buscando a primeira ocorr√™ncia de um espa√ßo. Quando o encontramos,
retornamos uma slice de string usando o in√≠cio da string e o √≠ndice do espa√ßo
como √≠ndices inicial e final, respectivamente.</p>
<p>Agora, quando chamamos <code>primeira_palavra</code>, pegamos de volta um √∫nico valor que
est√° vinculado √† string. O valor √© composto de uma refer√™ncia para o ponto
inicial da slice e o n√∫mero de elementos que ela cont√©m.</p>
<p>Retornar uma slice tamb√©m funcionaria para uma fun√ß√£o <code>segunda_palavra</code>:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Agora, temos uma API bem direta que √© bem mais dif√≠cil de bagun√ßar, uma vez que
o compilador vai se certificar que as refer√™ncias dentro da <code>String</code>
permanecer√£o v√°lidas. Lembra do bug do programa na Listagem 4-6, quando
obtivemos o √≠ndice para o fim da primeira palavra mas depois limpamos a string,
invalidando o √≠ndice obtido? Aquele c√≥digo era logicamente incorreto, mas n√£o
mostrava nenhum erro imediato. Os problemas apareceriam mais tarde quando
tent√°ssemos usar o √≠ndice da primeira palavra com uma string que foi esvaziada.
Slices tornam esse bug imposs√≠vel de acontecer e nos permitem saber que temos um
problema no c√≥digo muito mais cedo. Na vers√£o usando slice, a fun√ß√£o
<code>primeira_palavra</code> vai lan√ßar um erro em tempo de compila√ß√£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = first_word(&amp;s);

    s.clear(); // Erro!
}
</code></pre>
<p>Aqui est√° o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let word = primeira_palavra(&amp;s);
  |                                  - immutable borrow occurs here
5 |
6 |     s.clear(); // Erro!
  |     ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Voltando √†s regras de borrowing, lembre-se que, se temos uma refer√™ncia imut√°vel
para algum valor, n√£o podemos tamb√©m obter uma refer√™ncia mut√°vel do mesmo. Como
<code>clear</code> precisa truncar a <code>String</code>, esse m√©todo tenta obter uma refer√™ncia
mut√°vel, e acaba falhando. O Rust n√£o s√≥ tornou nossa API mais f√°cil de usar,
como tamb√©m eliminou uma classe inteira de erros em tempo de compila√ß√£o!</p>
<a class="header" href="ch04-03-slices.html#strings-literais-s√£o-slices" id="strings-literais-s√£o-slices"><h4>Strings Literais S√£o Slices</h4></a>
<p>Lembre-se de que falamos sobre strings literais serem armazenadas dentro do
bin√°rio. Agora que conhecemos slices, podemos entender strings literais
adequadamente:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Ol√°, mundo!&quot;;
#}</code></pre></pre>
<p>O tipo de <code>s</code> aqui √© <code>&amp;str</code>: √© uma slice apontando para aquele ponto espec√≠fico
do bin√°rio. Tamb√©m √© por isso que strings literais s√£o imut√°veis; <code>&amp;str</code> √© uma
refer√™ncia imut√°vel.</p>
<a class="header" href="ch04-03-slices.html#slices-de-strings-como-par√¢metros" id="slices-de-strings-como-par√¢metros"><h4>Slices de Strings como Par√¢metros</h4></a>
<p>Saber que voc√™ pode obter slices de literais e <code>String</code>s nos levam a mais um
aprimoramento da fun√ß√£o <code>primeira_palavra</code>, e aqui est√° sua assinatura:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Um Rust√°ceo mais experiente escreveria esta fun√ß√£o conforme a seguir, permitindo
utilizar a mesma fun√ß√£o com <code>String</code>s e <code>&amp;str</code>s:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Se temos uma slice de string, podemos pass√°-la diretamente. Se temos uma
<code>String</code>, podemos passar uma slice da <code>String</code> inteira. Definir uma fun√ß√£o que
recebe uma slice em vez de uma refer√™ncia para uma String deixa nossa API mais
gen√©rica e √∫til sem perder nenhuma funcionalidade:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let minha_string = String::from(&quot;texto longo&quot;);

    // primeira_palavra funciona com slices de `String`s
    let palavra = primeira_palavra(&amp;minha_string[..]);

    let minha_string_literal = &quot;texto longo&quot;;

    // primeira_palavra funciona com strings literais
    let palavra = primeira_palavra(&amp;minha_string_literal[..]);
    
    // uma vez que strings literais *s√£o* slices de strings,
    // isso tamb√©m funciona, sem nem usar sintaxe de slice!
    let palavra = primeira_palavra(minha_string_literal);
}
</code></pre></pre>
<a class="header" href="ch04-03-slices.html#outras-slices" id="outras-slices"><h3>Outras Slices</h3></a>
<p>Slices de string, como voc√™ pode imaginar, s√£o espec√≠ficas de strings. Mas h√°
tamb√©m um tipo de slice mais gen√©rico. Considere esta array:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Assim como √†s vezes queremos nos referir a uma parte de uma string, podemos
tamb√©m querer nos referir a uma parte de uma array, e far√≠amos isso da seguinte
forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>Essa slice tem o tipo <code>&amp;[i32]</code>. Ela funciona da mesma forma que as slices de
string, armazenando uma refer√™ncia para o primeiro elemento e um tamanho. Voc√™
vai usar esse tipo de slice para todos os tipos de cole√ß√µes. Vamos discutir
essas cole√ß√µes em mais detalhe quando falarmos sobre vetores no Cap√≠tulo 8.</p>
<a class="header" href="ch04-03-slices.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Os conceitos de ownership, borrowing, e slices s√£o o que garante a seguran√ßa de
mem√≥ria dos programas em Rust em tempo de compila√ß√£o. A linguagem Rust lhe d√°
controle sobre o uso da mem√≥ria, assim como outras linguagens de programa√ß√£o de
sistemas, mas como o dono dos dados limpa automaticamente a mem√≥ria quando ele
sai de escopo, voc√™ n√£o tem que escrever e debugar c√≥digo extra para ter esse
controle.</p>
<p>O ownership afeta o funcionamento de v√°rias outras partes do Rust, por isso
vamos falar um pouco mais sobre esses conceitos neste livro daqui para a frente.
Vamos seguir para o pr√≥ximo cap√≠tulo e ver como agrupar dados em uma <code>struct</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
